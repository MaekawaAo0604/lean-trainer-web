function x1(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();var Hp=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function b1(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function w1(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Ba={},jp;function v1(){return jp||(jp=1,(function(){var n;function e(m){var b=0;return function(){return b<m.length?{done:!1,value:m[b++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(m,b,C){return m==Array.prototype||m==Object.prototype||(m[b]=C.value),m};function s(m){m=[typeof globalThis=="object"&&globalThis,m,typeof window=="object"&&window,typeof self=="object"&&self,typeof Hp=="object"&&Hp];for(var b=0;b<m.length;++b){var C=m[b];if(C&&C.Math==Math)return C}throw Error("Cannot find global object")}var r=s(this);function o(m,b){if(b)e:{var C=r;m=m.split(".");for(var I=0;I<m.length-1;I++){var _=m[I];if(!(_ in C))break e;C=C[_]}m=m[m.length-1],I=C[m],b=b(I),b!=I&&b!=null&&t(C,m,{configurable:!0,writable:!0,value:b})}}o("Symbol",function(m){function b(O){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new C(I+(O||"")+"_"+_++,O)}function C(O,D){this.h=O,t(this,"description",{configurable:!0,writable:!0,value:D})}if(m)return m;C.prototype.toString=function(){return this.h};var I="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",_=0;return b}),o("Symbol.iterator",function(m){if(m)return m;m=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),C=0;C<b.length;C++){var I=r[b[C]];typeof I=="function"&&typeof I.prototype[m]!="function"&&t(I.prototype,m,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return m});function i(m){return m={next:m},m[Symbol.iterator]=function(){return this},m}function a(m){var b=typeof Symbol<"u"&&Symbol.iterator&&m[Symbol.iterator];return b?b.call(m):{next:e(m)}}function u(m){if(!(m instanceof Array)){m=a(m);for(var b,C=[];!(b=m.next()).done;)C.push(b.value);m=C}return m}var l=typeof Object.assign=="function"?Object.assign:function(m,b){for(var C=1;C<arguments.length;C++){var I=arguments[C];if(I)for(var _ in I)Object.prototype.hasOwnProperty.call(I,_)&&(m[_]=I[_])}return m};o("Object.assign",function(m){return m||l});var c=typeof Object.create=="function"?Object.create:function(m){function b(){}return b.prototype=m,new b},d;if(typeof Object.setPrototypeOf=="function")d=Object.setPrototypeOf;else{var h;e:{var p={a:!0},f={};try{f.__proto__=p,h=f.a;break e}catch{}h=!1}d=h?function(m,b){if(m.__proto__=b,m.__proto__!==b)throw new TypeError(m+" is not extensible");return m}:null}var g=d;function y(m,b){if(m.prototype=c(b.prototype),m.prototype.constructor=m,g)g(m,b);else for(var C in b)if(C!="prototype")if(Object.defineProperties){var I=Object.getOwnPropertyDescriptor(b,C);I&&Object.defineProperty(m,C,I)}else m[C]=b[C];m.za=b.prototype}function x(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function w(m){if(m.m)throw new TypeError("Generator is already running");m.m=!0}x.prototype.u=function(m){this.i=m};function $(m,b){m.l={ma:b,na:!0},m.h=m.s||m.v}x.prototype.return=function(m){this.l={return:m},this.h=this.v};function S(m,b,C){return m.h=C,{value:b}}function E(m){this.h=new x,this.i=m}function P(m,b){w(m.h);var C=m.h.j;return C?F(m,"return"in C?C.return:function(I){return{value:I,done:!0}},b,m.h.return):(m.h.return(b),L(m))}function F(m,b,C,I){try{var _=b.call(m.h.j,C);if(!(_ instanceof Object))throw new TypeError("Iterator result "+_+" is not an object");if(!_.done)return m.h.m=!1,_;var O=_.value}catch(D){return m.h.j=null,$(m.h,D),L(m)}return m.h.j=null,I.call(m.h,O),L(m)}function L(m){for(;m.h.h;)try{var b=m.i(m.h);if(b)return m.h.m=!1,{value:b.value,done:!1}}catch(C){m.h.i=void 0,$(m.h,C)}if(m.h.m=!1,m.h.l){if(b=m.h.l,m.h.l=null,b.na)throw b.ma;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function R(m){this.next=function(b){return w(m.h),m.h.j?b=F(m,m.h.j.next,b,m.h.u):(m.h.u(b),b=L(m)),b},this.throw=function(b){return w(m.h),m.h.j?b=F(m,m.h.j.throw,b,m.h.u):($(m.h,b),b=L(m)),b},this.return=function(b){return P(m,b)},this[Symbol.iterator]=function(){return this}}function A(m){function b(I){return m.next(I)}function C(I){return m.throw(I)}return new Promise(function(I,_){function O(D){D.done?I(D.value):Promise.resolve(D.value).then(b,C).then(O,_)}O(m.next())})}function k(m){return A(new R(new E(m)))}o("Promise",function(m){function b(D){this.i=0,this.j=void 0,this.h=[],this.u=!1;var V=this.l();try{D(V.resolve,V.reject)}catch(U){V.reject(U)}}function C(){this.h=null}function I(D){return D instanceof b?D:new b(function(V){V(D)})}if(m)return m;C.prototype.i=function(D){if(this.h==null){this.h=[];var V=this;this.j(function(){V.m()})}this.h.push(D)};var _=r.setTimeout;C.prototype.j=function(D){_(D,0)},C.prototype.m=function(){for(;this.h&&this.h.length;){var D=this.h;this.h=[];for(var V=0;V<D.length;++V){var U=D[V];D[V]=null;try{U()}catch(q){this.l(q)}}}this.h=null},C.prototype.l=function(D){this.j(function(){throw D})},b.prototype.l=function(){function D(q){return function(ne){U||(U=!0,q.call(V,ne))}}var V=this,U=!1;return{resolve:D(this.I),reject:D(this.m)}},b.prototype.I=function(D){if(D===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(D instanceof b)this.L(D);else{e:switch(typeof D){case"object":var V=D!=null;break e;case"function":V=!0;break e;default:V=!1}V?this.F(D):this.s(D)}},b.prototype.F=function(D){var V=void 0;try{V=D.then}catch(U){this.m(U);return}typeof V=="function"?this.M(V,D):this.s(D)},b.prototype.m=function(D){this.v(2,D)},b.prototype.s=function(D){this.v(1,D)},b.prototype.v=function(D,V){if(this.i!=0)throw Error("Cannot settle("+D+", "+V+"): Promise already settled in state"+this.i);this.i=D,this.j=V,this.i===2&&this.K(),this.H()},b.prototype.K=function(){var D=this;_(function(){if(D.D()){var V=r.console;typeof V<"u"&&V.error(D.j)}},1)},b.prototype.D=function(){if(this.u)return!1;var D=r.CustomEvent,V=r.Event,U=r.dispatchEvent;return typeof U>"u"?!0:(typeof D=="function"?D=new D("unhandledrejection",{cancelable:!0}):typeof V=="function"?D=new V("unhandledrejection",{cancelable:!0}):(D=r.document.createEvent("CustomEvent"),D.initCustomEvent("unhandledrejection",!1,!0,D)),D.promise=this,D.reason=this.j,U(D))},b.prototype.H=function(){if(this.h!=null){for(var D=0;D<this.h.length;++D)O.i(this.h[D]);this.h=null}};var O=new C;return b.prototype.L=function(D){var V=this.l();D.T(V.resolve,V.reject)},b.prototype.M=function(D,V){var U=this.l();try{D.call(V,U.resolve,U.reject)}catch(q){U.reject(q)}},b.prototype.then=function(D,V){function U(le,oe){return typeof le=="function"?function(ge){try{q(le(ge))}catch($e){ne($e)}}:oe}var q,ne,me=new b(function(le,oe){q=le,ne=oe});return this.T(U(D,q),U(V,ne)),me},b.prototype.catch=function(D){return this.then(void 0,D)},b.prototype.T=function(D,V){function U(){switch(q.i){case 1:D(q.j);break;case 2:V(q.j);break;default:throw Error("Unexpected state: "+q.i)}}var q=this;this.h==null?O.i(U):this.h.push(U),this.u=!0},b.resolve=I,b.reject=function(D){return new b(function(V,U){U(D)})},b.race=function(D){return new b(function(V,U){for(var q=a(D),ne=q.next();!ne.done;ne=q.next())I(ne.value).T(V,U)})},b.all=function(D){var V=a(D),U=V.next();return U.done?I([]):new b(function(q,ne){function me(ge){return function($e){le[ge]=$e,oe--,oe==0&&q(le)}}var le=[],oe=0;do le.push(void 0),oe++,I(U.value).T(me(le.length-1),ne),U=V.next();while(!U.done)})},b});function W(m,b){m instanceof String&&(m+="");var C=0,I=!1,_={next:function(){if(!I&&C<m.length){var O=C++;return{value:b(O,m[O]),done:!1}}return I=!0,{done:!0,value:void 0}}};return _[Symbol.iterator]=function(){return _},_}o("Array.prototype.keys",function(m){return m||function(){return W(this,function(b){return b})}}),o("Array.prototype.fill",function(m){return m||function(b,C,I){var _=this.length||0;for(0>C&&(C=Math.max(0,_+C)),(I==null||I>_)&&(I=_),I=Number(I),0>I&&(I=Math.max(0,_+I)),C=Number(C||0);C<I;C++)this[C]=b;return this}});function G(m){return m||Array.prototype.fill}o("Int8Array.prototype.fill",G),o("Uint8Array.prototype.fill",G),o("Uint8ClampedArray.prototype.fill",G),o("Int16Array.prototype.fill",G),o("Uint16Array.prototype.fill",G),o("Int32Array.prototype.fill",G),o("Uint32Array.prototype.fill",G),o("Float32Array.prototype.fill",G),o("Float64Array.prototype.fill",G),o("Object.is",function(m){return m||function(b,C){return b===C?b!==0||1/b===1/C:b!==b&&C!==C}}),o("Array.prototype.includes",function(m){return m||function(b,C){var I=this;I instanceof String&&(I=String(I));var _=I.length;for(C=C||0,0>C&&(C=Math.max(C+_,0));C<_;C++){var O=I[C];if(O===b||Object.is(O,b))return!0}return!1}}),o("String.prototype.includes",function(m){return m||function(b,C){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(b,C||0)!==-1}});var K=this||self;function X(m,b){m=m.split(".");var C=K;m[0]in C||typeof C.execScript>"u"||C.execScript("var "+m[0]);for(var I;m.length&&(I=m.shift());)m.length||b===void 0?C[I]&&C[I]!==Object.prototype[I]?C=C[I]:C=C[I]={}:C[I]=b}function ee(m){var b;e:{if((b=K.navigator)&&(b=b.userAgent))break e;b=""}return b.indexOf(m)!=-1}var ce=Array.prototype.map?function(m,b){return Array.prototype.map.call(m,b,void 0)}:function(m,b){for(var C=m.length,I=Array(C),_=typeof m=="string"?m.split(""):m,O=0;O<C;O++)O in _&&(I[O]=b.call(void 0,_[O],O,m));return I},de={},he=null;function Ce(m){var b=m.length,C=3*b/4;C%3?C=Math.floor(C):"=.".indexOf(m[b-1])!=-1&&(C="=.".indexOf(m[b-2])!=-1?C-2:C-1);var I=new Uint8Array(C),_=0;return Re(m,function(O){I[_++]=O}),_!==C?I.subarray(0,_):I}function Re(m,b){function C(U){for(;I<m.length;){var q=m.charAt(I++),ne=he[q];if(ne!=null)return ne;if(!/^[\s\xa0]*$/.test(q))throw Error("Unknown base64 encoding at char: "+q)}return U}De();for(var I=0;;){var _=C(-1),O=C(0),D=C(64),V=C(64);if(V===64&&_===-1)break;b(_<<2|O>>4),D!=64&&(b(O<<4&240|D>>2),V!=64&&b(D<<6&192|V))}}function De(){if(!he){he={};for(var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],C=0;5>C;C++){var I=m.concat(b[C].split(""));de[C]=I;for(var _=0;_<I.length;_++){var O=I[_];he[O]===void 0&&(he[O]=_)}}}}var je=typeof Uint8Array<"u",nn=!(ee("Trident")||ee("MSIE"))&&typeof K.btoa=="function";function Xs(m){if(!nn){var b;b===void 0&&(b=0),De(),b=de[b];for(var C=Array(Math.floor(m.length/3)),I=b[64]||"",_=0,O=0;_<m.length-2;_+=3){var D=m[_],V=m[_+1],U=m[_+2],q=b[D>>2];D=b[(D&3)<<4|V>>4],V=b[(V&15)<<2|U>>6],U=b[U&63],C[O++]=q+D+V+U}switch(q=0,U=I,m.length-_){case 2:q=m[_+1],U=b[(q&15)<<2]||I;case 1:m=m[_],C[O]=b[m>>2]+b[(m&3)<<4|q>>4]+U+I}return C.join("")}for(b="";10240<m.length;)b+=String.fromCharCode.apply(null,m.subarray(0,10240)),m=m.subarray(10240);return b+=String.fromCharCode.apply(null,m),btoa(b)}var Pr=RegExp("[-_.]","g");function $b(m){switch(m){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function qh(m){if(!nn)return Ce(m);Pr.test(m)&&(m=m.replace(Pr,$b)),m=atob(m);for(var b=new Uint8Array(m.length),C=0;C<m.length;C++)b[C]=m.charCodeAt(C);return b}var Yh;function ma(){return Yh||(Yh=new Uint8Array(0))}var Dr={},Ib=typeof Uint8Array.prototype.slice=="function",et=0,vt=0;function Qh(m){var b=0>m;m=Math.abs(m);var C=m>>>0;m=Math.floor((m-C)/4294967296),b&&(C=a(Zh(C,m)),b=C.next().value,m=C.next().value,C=b),et=C>>>0,vt=m>>>0}var kb=typeof BigInt=="function";function Zh(m,b){return b=~b,m?m=~m+1:b+=1,[m,b]}function Jh(m,b){this.i=m>>>0,this.h=b>>>0}function ep(m){if(!m)return tp||(tp=new Jh(0,0));if(!/^-?\d+$/.test(m))return null;if(16>m.length)Qh(Number(m));else if(kb)m=BigInt(m),et=Number(m&BigInt(4294967295))>>>0,vt=Number(m>>BigInt(32)&BigInt(4294967295));else{var b=+(m[0]==="-");vt=et=0;for(var C=m.length,I=b,_=(C-b)%6+b;_<=C;I=_,_+=6)I=Number(m.slice(I,_)),vt*=1e6,et=1e6*et+I,4294967296<=et&&(vt+=et/4294967296|0,et%=4294967296);b&&(b=a(Zh(et,vt)),m=b.next().value,b=b.next().value,et=m,vt=b)}return new Jh(et,vt)}var tp;function np(m,b){return Error("Invalid wire type: "+m+" (at position "+b+")")}function ga(){return Error("Failed to read varint, encoding is invalid.")}function sp(m,b){return Error("Tried to read past the end of the data "+b+" > "+m)}function cs(){throw Error("Invalid UTF8")}function rp(m,b){return b=String.fromCharCode.apply(null,b),m==null?b:m+b}var Lo=void 0,ya,Nb=typeof TextDecoder<"u",op,Tb=typeof TextEncoder<"u",ip;function ap(m){if(m!==Dr)throw Error("illegal external caller")}function Or(m,b){if(ap(b),this.V=m,m!=null&&m.length===0)throw Error("ByteString should be constructed with non-empty values")}function xa(){return ip||(ip=new Or(null,Dr))}function up(m){ap(Dr);var b=m.V;return b=b==null||je&&b!=null&&b instanceof Uint8Array?b:typeof b=="string"?qh(b):null,b==null?b:m.V=b}function Eb(m){if(typeof m=="string")return{buffer:qh(m),C:!1};if(Array.isArray(m))return{buffer:new Uint8Array(m),C:!1};if(m.constructor===Uint8Array)return{buffer:m,C:!1};if(m.constructor===ArrayBuffer)return{buffer:new Uint8Array(m),C:!1};if(m.constructor===Or)return{buffer:up(m)||ma(),C:!0};if(m instanceof Uint8Array)return{buffer:new Uint8Array(m.buffer,m.byteOffset,m.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function lp(m,b){this.i=null,this.m=!1,this.h=this.j=this.l=0,ba(this,m,b)}function ba(m,b,C){C=C===void 0?{}:C,m.S=C.S===void 0?!1:C.S,b&&(b=Eb(b),m.i=b.buffer,m.m=b.C,m.l=0,m.j=m.i.length,m.h=m.l)}lp.prototype.reset=function(){this.h=this.l};function ds(m,b){if(m.h=b,b>m.j)throw sp(m.j,b)}function Fr(m){var b=m.i,C=m.h,I=b[C++],_=I&127;if(I&128&&(I=b[C++],_|=(I&127)<<7,I&128&&(I=b[C++],_|=(I&127)<<14,I&128&&(I=b[C++],_|=(I&127)<<21,I&128&&(I=b[C++],_|=I<<28,I&128&&b[C++]&128&&b[C++]&128&&b[C++]&128&&b[C++]&128&&b[C++]&128)))))throw ga();return ds(m,C),_}function cp(m,b){if(0>b)throw Error("Tried to read a negative byte length: "+b);var C=m.h,I=C+b;if(I>m.j)throw sp(b,m.j-C);return m.h=I,C}var dp=[];function wa(){this.h=[]}wa.prototype.length=function(){return this.h.length},wa.prototype.end=function(){var m=this.h;return this.h=[],m};function hp(m,b,C){for(;0<C||127<b;)m.h.push(b&127|128),b=(b>>>7|C<<25)>>>0,C>>>=7;m.h.push(b)}function hs(m,b){for(;127<b;)m.h.push(b&127|128),b>>>=7;m.h.push(b)}function va(m,b){if(dp.length){var C=dp.pop();ba(C,m,b),m=C}else m=new lp(m,b);this.h=m,this.j=this.h.h,this.i=this.l=-1,this.setOptions(b)}va.prototype.setOptions=function(m){m=m===void 0?{}:m,this.ca=m.ca===void 0?!1:m.ca},va.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function pp(m){var b=m.h;if(b.h==b.j)return!1;m.j=m.h.h;var C=Fr(m.h)>>>0;if(b=C>>>3,C&=7,!(0<=C&&5>=C))throw np(C,m.j);if(1>b)throw Error("Invalid field number: "+b+" (at position "+m.j+")");return m.l=b,m.i=C,!0}function Bo(m){switch(m.i){case 0:if(m.i!=0)Bo(m);else e:{m=m.h;for(var b=m.h,C=b+10,I=m.i;b<C;)if((I[b++]&128)===0){ds(m,b);break e}throw ga()}break;case 1:m=m.h,ds(m,m.h+8);break;case 2:m.i!=2?Bo(m):(b=Fr(m.h)>>>0,m=m.h,ds(m,m.h+b));break;case 5:m=m.h,ds(m,m.h+4);break;case 3:b=m.l;do{if(!pp(m))throw Error("Unmatched start-group tag: stream EOF");if(m.i==4){if(m.l!=b)throw Error("Unmatched end-group tag");break}Bo(m)}while(!0);break;default:throw np(m.i,m.j)}}var zo=[];function Rb(){this.j=[],this.i=0,this.h=new wa}function qs(m,b){b.length!==0&&(m.j.push(b),m.i+=b.length)}function _b(m,b){if(b=b.R){qs(m,m.h.end());for(var C=0;C<b.length;C++)qs(m,up(b[C])||ma())}}var kn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function ps(m,b){return kn?m[kn]|=b:m.A!==void 0?m.A|=b:(Object.defineProperties(m,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}}),b)}function fp(m,b){kn?m[kn]&&(m[kn]&=~b):m.A!==void 0&&(m.A&=~b)}function Qe(m){var b;return kn?b=m[kn]:b=m.A,b??0}function pn(m,b){kn?m[kn]=b:m.A!==void 0?m.A=b:Object.defineProperties(m,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}})}function Ca(m){return ps(m,1),m}function Ab(m,b){pn(b,(m|0)&-51)}function Vo(m,b){pn(b,(m|18)&-41)}var Sa={};function Mo(m){return m!==null&&typeof m=="object"&&!Array.isArray(m)&&m.constructor===Object}var Lr,mp=[];pn(mp,23),Lr=Object.freeze(mp);function $a(m){if(Qe(m.o)&2)throw Error("Cannot mutate an immutable Message")}function Ia(m){var b=m.length;(b=b?m[b-1]:void 0)&&Mo(b)?b.g=1:(b={},m.push((b.g=1,b)))}function gp(m){var b=m.i+m.G;return m.B||(m.B=m.o[b]={})}function sn(m,b){return b===-1?null:b>=m.i?m.B?m.B[b]:void 0:m.o[b+m.G]}function fn(m,b,C,I){$a(m),Br(m,b,C,I)}function Br(m,b,C,I){m.j&&(m.j=void 0),b>=m.i||I?gp(m)[b]=C:(m.o[b+m.G]=C,(m=m.B)&&b in m&&delete m[b])}function ka(m,b,C,I){var _=sn(m,b);Array.isArray(_)||(_=Lr);var O=Qe(_);if(O&1||Ca(_),I)O&2||ps(_,2),C&1||Object.freeze(_);else{I=!(C&2);var D=O&2;C&1||!D?I&&O&16&&!D&&fp(_,16):(_=Ca(Array.prototype.slice.call(_)),Br(m,b,_))}return _}function Na(m,b){var C=sn(m,b),I=C==null?C:typeof C=="number"||C==="NaN"||C==="Infinity"||C==="-Infinity"?Number(C):void 0;return I!=null&&I!==C&&Br(m,b,I),I}function yp(m,b,C,I,_){m.h||(m.h={});var O=m.h[C],D=ka(m,C,3,_);if(!O){var V=D;O=[];var U=!!(Qe(m.o)&16);D=!!(Qe(V)&2);var q=V;!_&&D&&(V=Array.prototype.slice.call(V));for(var ne=D,me=0;me<V.length;me++){var le=V[me],oe=b,ge=!1;if(ge=ge===void 0?!1:ge,le=Array.isArray(le)?new oe(le):ge?new oe:void 0,le!==void 0){oe=le.o;var $e=ge=Qe(oe);D&&($e|=2),U&&($e|=16),$e!=ge&&pn(oe,$e),oe=$e,ne=ne||!!(2&oe),O.push(le)}}return m.h[C]=O,U=Qe(V),b=U|33,b=ne?b&-9:b|8,U!=b&&(ne=V,Object.isFrozen(ne)&&(ne=Array.prototype.slice.call(ne)),pn(ne,b),V=ne),q!==V&&Br(m,C,V),(_||I&&D)&&ps(O,2),I&&Object.freeze(O),O}return _||(_=Object.isFrozen(O),I&&!_?Object.freeze(O):!I&&_&&(O=Array.prototype.slice.call(O),m.h[C]=O)),O}function Ta(m,b,C){var I=!!(Qe(m.o)&2);if(b=yp(m,b,C,I,I),m=ka(m,C,3,I),!(I||Qe(m)&8)){for(I=0;I<b.length;I++){if(C=b[I],Qe(C.o)&2){var _=Sp(C,!1);_.j=C}else _=C;C!==_&&(b[I]=_,m[I]=_.o)}ps(m,8)}return b}function mn(m,b,C){if(C!=null&&typeof C!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof C+": "+C);fn(m,b,C)}function xp(m,b,C,I,_){$a(m);var O=yp(m,C,b,!1,!1);return C=I??new C,m=ka(m,b,2,!1),_!=null?(O.splice(_,0,C),m.splice(_,0,C.o)):(O.push(C),m.push(C.o)),C.C()&&fp(m,8),C}function Wo(m,b){return m??b}function gn(m,b,C){return C=C===void 0?0:C,Wo(Na(m,b),C)}var Uo;function Pb(m){switch(typeof m){case"number":return isFinite(m)?m:String(m);case"object":if(m)if(Array.isArray(m)){if((Qe(m)&128)!==0)return m=Array.prototype.slice.call(m),Ia(m),m}else{if(je&&m!=null&&m instanceof Uint8Array)return Xs(m);if(m instanceof Or){var b=m.V;return b==null?"":typeof b=="string"?b:m.V=Xs(b)}}}return m}function bp(m,b,C,I){if(m!=null){if(Array.isArray(m))m=Ea(m,b,C,I!==void 0);else if(Mo(m)){var _={},O;for(O in m)_[O]=bp(m[O],b,C,I);m=_}else m=b(m,I);return m}}function Ea(m,b,C,I){var _=Qe(m);I=I?!!(_&16):void 0,m=Array.prototype.slice.call(m);for(var O=0;O<m.length;O++)m[O]=bp(m[O],b,C,I);return C(_,m),m}function Db(m){return m.ja===Sa?m.toJSON():Pb(m)}function Ob(m,b){m&128&&Ia(b)}function wp(m,b,C){if(C=C===void 0?Vo:C,m!=null){if(je&&m instanceof Uint8Array)return m.length?new Or(new Uint8Array(m),Dr):xa();if(Array.isArray(m)){var I=Qe(m);return I&2?m:b&&!(I&32)&&(I&16||I===0)?(pn(m,I|2),m):(m=Ea(m,wp,I&4?Vo:C,!0),b=Qe(m),b&4&&b&2&&Object.freeze(m),m)}return m.ja===Sa?Cp(m):m}}function vp(m,b,C,I,_,O,D){if(m=m.h&&m.h[C]){if(I=Qe(m),I&2?I=m:(O=ce(m,Cp),Vo(I,O),Object.freeze(O),I=O),$a(b),D=I==null?Lr:Ca([]),I!=null){for(O=!!I.length,m=0;m<I.length;m++){var V=I[m];O=O&&!(Qe(V.o)&2),D[m]=V.o}O=(O?8:0)|1,m=Qe(D),(m&O)!==O&&(Object.isFrozen(D)&&(D=Array.prototype.slice.call(D)),pn(D,m|O)),b.h||(b.h={}),b.h[C]=I}else b.h&&(b.h[C]=void 0);Br(b,C,D,_)}else fn(b,C,wp(I,O,D),_)}function Cp(m){return Qe(m.o)&2||(m=Sp(m,!0),ps(m.o,2)),m}function Sp(m,b){var C=m.o,I=[];ps(I,16);var _=m.constructor.h;if(_&&I.push(_),_=m.B,_){I.length=C.length,I.fill(void 0,I.length,C.length);var O={};I[I.length-1]=O}(Qe(C)&128)!==0&&Ia(I),b=b||m.C()?Vo:Ab,O=m.constructor,Uo=I,I=new O(I),Uo=void 0,m.R&&(I.R=m.R.slice()),O=!!(Qe(C)&16);for(var D=_?C.length-1:C.length,V=0;V<D;V++)vp(m,I,V-m.G,C[V],!1,O,b);if(_)for(var U in _)vp(m,I,+U,_[U],!0,O,b);return I}function Nt(m,b,C){m==null&&(m=Uo),Uo=void 0;var I=this.constructor.i||0,_=0<I,O=this.constructor.h,D=!1;if(m==null){m=O?[O]:[];var V=48,U=!0;_&&(I=0,V|=128),pn(m,V)}else{if(!Array.isArray(m)||O&&O!==m[0])throw Error();var q=V=ps(m,0);if((U=(16&q)!==0)&&((D=(32&q)!==0)||(q|=32)),_){if(128&q)I=0;else if(0<m.length){var ne=m[m.length-1];if(Mo(ne)&&"g"in ne){I=0,q|=128,delete ne.g;var me=!0,le;for(le in ne){me=!1;break}me&&m.pop()}}}else if(128&q)throw Error();V!==q&&pn(m,q)}this.G=(O?0:-1)-I,this.h=void 0,this.o=m;e:{if(O=this.o.length,I=O-1,O&&(O=this.o[I],Mo(O))){this.B=O,this.i=I-this.G;break e}b!==void 0&&-1<b?(this.i=Math.max(b,I+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!_&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(C){b=U&&!D&&!0,_=this.i;var oe;for(U=0;U<C.length;U++)D=C[U],D<_?(D+=this.G,(I=m[D])?$p(I,b):m[D]=Lr):(oe||(oe=gp(this)),(I=oe[D])?$p(I,b):oe[D]=Lr)}}Nt.prototype.toJSON=function(){return Ea(this.o,Db,Ob)},Nt.prototype.C=function(){return!!(Qe(this.o)&2)};function $p(m,b){if(Array.isArray(m)){var C=Qe(m),I=1;!b||C&2||(I|=16),(C&I)!==I&&pn(m,C|I)}}Nt.prototype.ja=Sa,Nt.prototype.toString=function(){return this.o.toString()};function Ip(m,b,C){if(C){var I={},_;for(_ in C){var O=C[_],D=O.ra;D||(I.J=O.xa||O.oa.W,O.ia?(I.aa=Rp(O.ia),D=function(V){return function(U,q,ne){return V.J(U,q,ne,V.aa)}}(I)):O.ka?(I.Z=_p(O.da.P,O.ka),D=function(V){return function(U,q,ne){return V.J(U,q,ne,V.Z)}}(I)):D=I.J,O.ra=D),D(b,m,O.da),I={J:I.J,aa:I.aa,Z:I.Z}}}_b(b,m)}var Go=Symbol();function kp(m,b,C){return m[Go]||(m[Go]=function(I,_){return b(I,_,C)})}function Np(m){var b=m[Go];if(!b){var C=_a(m);b=function(I,_){return Ap(I,_,C)},m[Go]=b}return b}function Fb(m){var b=m.ia;if(b)return Np(b);if(b=m.wa)return kp(m.da.P,b,m.ka)}function Lb(m){var b=Fb(m),C=m.da,I=m.oa.U;return b?function(_,O){return I(_,O,C,b)}:function(_,O){return I(_,O,C)}}function Tp(m,b){var C=m[b];return typeof C=="function"&&C.length===0&&(C=C(),m[b]=C),Array.isArray(C)&&(Vr in C||zr in C||0<C.length&&typeof C[0]=="function")?C:void 0}function Ep(m,b,C,I,_,O){b.P=m[0];var D=1;if(m.length>D&&typeof m[D]!="number"){var V=m[D++];C(b,V)}for(;D<m.length;){C=m[D++];for(var U=D+1;U<m.length&&typeof m[U]!="number";)U++;switch(V=m[D++],U-=D,U){case 0:I(b,C,V);break;case 1:(U=Tp(m,D))?(D++,_(b,C,V,U)):I(b,C,V,m[D++]);break;case 2:U=D++,U=Tp(m,U),_(b,C,V,U,m[D++]);break;case 3:O(b,C,V,m[D++],m[D++],m[D++]);break;case 4:O(b,C,V,m[D++],m[D++],m[D++],m[D++]);break;default:throw Error("unexpected number of binary field arguments: "+U)}}return b}var Ho=Symbol();function Rp(m){var b=m[Ho];if(!b){var C=Ra(m);b=function(I,_){return Pp(I,_,C)},m[Ho]=b}return b}function _p(m,b){var C=m[Ho];return C||(C=function(I,_){return Ip(I,_,b)},m[Ho]=C),C}var zr=Symbol();function Bb(m,b){m.push(b)}function zb(m,b,C){m.push(b,C.W)}function Vb(m,b,C,I){var _=Rp(I),O=Ra(I).P,D=C.W;m.push(b,function(V,U,q){return D(V,U,q,O,_)})}function Mb(m,b,C,I,_,O){var D=_p(I,O),V=C.W;m.push(b,function(U,q,ne){return V(U,q,ne,I,D)})}function Ra(m){var b=m[zr];return b||(b=Ep(m,m[zr]=[],Bb,zb,Vb,Mb),Vr in m&&zr in m&&(m.length=0),b)}var Vr=Symbol();function Wb(m,b){m[0]=b}function Ub(m,b,C,I){var _=C.U;m[b]=I?function(O,D,V){return _(O,D,V,I)}:_}function Gb(m,b,C,I,_){var O=C.U,D=Np(I),V=_a(I).P;m[b]=function(U,q,ne){return O(U,q,ne,V,D,_)}}function Hb(m,b,C,I,_,O,D){var V=C.U,U=kp(I,_,O);m[b]=function(q,ne,me){return V(q,ne,me,I,U,D)}}function _a(m){var b=m[Vr];return b||(b=Ep(m,m[Vr]={},Wb,Ub,Gb,Hb),Vr in m&&zr in m&&(m.length=0),b)}function Ap(m,b,C){for(;pp(b)&&b.i!=4;){var I=b.l,_=C[I];if(!_){var O=C[0];O&&(O=O[I])&&(_=C[I]=Lb(O))}if(!_||!_(b,m,I)){_=b,I=m,O=_.j,Bo(_);var D=_;if(!D.ca){if(_=D.h.h-O,D.h.h=O,D=D.h,_==0)_=xa();else{if(O=cp(D,_),D.S&&D.m)_=D.i.subarray(O,O+_);else{D=D.i;var V=O;_=O+_,_=V===_?ma():Ib?D.slice(V,_):new Uint8Array(D.subarray(V,_))}_=_.length==0?xa():new Or(_,Dr)}(O=I.R)?O.push(_):I.R=[_]}}}return m}function Pp(m,b,C){for(var I=C.length,_=I%2==1,O=_?1:0;O<I;O+=2)(0,C[O+1])(b,m,C[O]);Ip(m,b,_?C[0]:void 0)}function Mr(m,b){return{U:m,W:b}}var rn=Mr(function(m,b,C){if(m.i!==5)return!1;m=m.h;var I=m.i,_=m.h,O=I[_],D=I[_+1],V=I[_+2];return I=I[_+3],ds(m,m.h+4),D=(O<<0|D<<8|V<<16|I<<24)>>>0,m=2*(D>>31)+1,O=D>>>23&255,D&=8388607,fn(b,C,O==255?D?NaN:1/0*m:O==0?m*Math.pow(2,-149)*D:m*Math.pow(2,O-150)*(D+Math.pow(2,23))),!0},function(m,b,C){if(b=Na(b,C),b!=null){hs(m.h,8*C+5),m=m.h;var I=+b;I===0?0<1/I?et=vt=0:(vt=0,et=2147483648):isNaN(I)?(vt=0,et=2147483647):(I=(C=0>I?-2147483648:0)?-I:I,34028234663852886e22<I?(vt=0,et=(C|2139095040)>>>0):11754943508222875e-54>I?(I=Math.round(I/Math.pow(2,-149)),vt=0,et=(C|I)>>>0):(b=Math.floor(Math.log(I)/Math.LN2),I*=Math.pow(2,-b),I=Math.round(8388608*I),16777216<=I&&++b,vt=0,et=(C|b+127<<23|I&8388607)>>>0)),C=et,m.h.push(C>>>0&255),m.h.push(C>>>8&255),m.h.push(C>>>16&255),m.h.push(C>>>24&255)}}),jb=Mr(function(m,b,C){if(m.i!==0)return!1;var I=m.h,_=0,O=m=0,D=I.i,V=I.h;do{var U=D[V++];_|=(U&127)<<O,O+=7}while(32>O&&U&128);for(32<O&&(m|=(U&127)>>4),O=3;32>O&&U&128;O+=7)U=D[V++],m|=(U&127)<<O;if(ds(I,V),128>U)I=_>>>0,U=m>>>0,(m=U&2147483648)&&(I=~I+1>>>0,U=~U>>>0,I==0&&(U=U+1>>>0)),I=4294967296*U+(I>>>0);else throw ga();return fn(b,C,m?-I:I),!0},function(m,b,C){b=sn(b,C),b!=null&&(typeof b=="string"&&ep(b),b!=null&&(hs(m.h,8*C),typeof b=="number"?(m=m.h,Qh(b),hp(m,et,vt)):(C=ep(b),hp(m.h,C.i,C.h))))}),Kb=Mr(function(m,b,C){return m.i!==0?!1:(fn(b,C,Fr(m.h)),!0)},function(m,b,C){if(b=sn(b,C),b!=null&&b!=null)if(hs(m.h,8*C),m=m.h,C=b,0<=C)hs(m,C);else{for(b=0;9>b;b++)m.h.push(C&127|128),C>>=7;m.h.push(1)}}),Dp=Mr(function(m,b,C){if(m.i!==2)return!1;var I=Fr(m.h)>>>0;m=m.h;var _=cp(m,I);if(m=m.i,Nb){var O=m,D;(D=ya)||(D=ya=new TextDecoder("utf-8",{fatal:!0})),m=_+I,O=_===0&&m===O.length?O:O.subarray(_,m);try{var V=D.decode(O)}catch(me){if(Lo===void 0){try{D.decode(new Uint8Array([128]))}catch{}try{D.decode(new Uint8Array([97])),Lo=!0}catch{Lo=!1}}throw!Lo&&(ya=void 0),me}}else{V=_,I=V+I,_=[];for(var U=null,q,ne;V<I;)q=m[V++],128>q?_.push(q):224>q?V>=I?cs():(ne=m[V++],194>q||(ne&192)!==128?(V--,cs()):_.push((q&31)<<6|ne&63)):240>q?V>=I-1?cs():(ne=m[V++],(ne&192)!==128||q===224&&160>ne||q===237&&160<=ne||((O=m[V++])&192)!==128?(V--,cs()):_.push((q&15)<<12|(ne&63)<<6|O&63)):244>=q?V>=I-2?cs():(ne=m[V++],(ne&192)!==128||(q<<28)+(ne-144)>>30!==0||((O=m[V++])&192)!==128||((D=m[V++])&192)!==128?(V--,cs()):(q=(q&7)<<18|(ne&63)<<12|(O&63)<<6|D&63,q-=65536,_.push((q>>10&1023)+55296,(q&1023)+56320))):cs(),8192<=_.length&&(U=rp(U,_),_.length=0);V=rp(U,_)}return fn(b,C,V),!0},function(m,b,C){if(b=sn(b,C),b!=null){var I=!1;if(I=I===void 0?!1:I,Tb){if(I&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b))throw Error("Found an unpaired surrogate");b=(op||(op=new TextEncoder)).encode(b)}else{for(var _=0,O=new Uint8Array(3*b.length),D=0;D<b.length;D++){var V=b.charCodeAt(D);if(128>V)O[_++]=V;else{if(2048>V)O[_++]=V>>6|192;else{if(55296<=V&&57343>=V){if(56319>=V&&D<b.length){var U=b.charCodeAt(++D);if(56320<=U&&57343>=U){V=1024*(V-55296)+U-56320+65536,O[_++]=V>>18|240,O[_++]=V>>12&63|128,O[_++]=V>>6&63|128,O[_++]=V&63|128;continue}else D--}if(I)throw Error("Found an unpaired surrogate");V=65533}O[_++]=V>>12|224,O[_++]=V>>6&63|128}O[_++]=V&63|128}}b=_===O.length?O:O.subarray(0,_)}hs(m.h,8*C+2),hs(m.h,b.length),qs(m,m.h.end()),qs(m,b)}}),Op=Mr(function(m,b,C,I,_){if(m.i!==2)return!1;b=xp(b,C,I),C=m.h.j,I=Fr(m.h)>>>0;var O=m.h.h+I,D=O-C;if(0>=D&&(m.h.j=O,_(b,m,void 0,void 0,void 0),D=O-m.h.h),D)throw Error("Message parsing ended unexpectedly. Expected to read "+(I+" bytes, instead read "+(I-D)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return m.h.h=O,m.h.j=C,!0},function(m,b,C,I,_){if(b=Ta(b,I,C),b!=null)for(I=0;I<b.length;I++){var O=m;hs(O.h,8*C+2);var D=O.h.end();qs(O,D),D.push(O.i),O=D,_(b[I],m),D=m;var V=O.pop();for(V=D.i+D.h.length()-V;127<V;)O.push(V&127|128),V>>>=7,D.i++;O.push(V),D.i++}});function Aa(m){return function(b,C){e:{if(zo.length){var I=zo.pop();I.setOptions(C),ba(I.h,b,C),b=I}else b=new va(b,C);try{var _=_a(m),O=Ap(new _.P,b,_);break e}finally{_=b.h,_.i=null,_.m=!1,_.l=0,_.j=0,_.h=0,_.S=!1,b.l=-1,b.i=-1,100>zo.length&&zo.push(b)}O=void 0}return O}}function Pa(m){return function(){var b=new Rb;Pp(this,b,Ra(m)),qs(b,b.h.end());for(var C=new Uint8Array(b.i),I=b.j,_=I.length,O=0,D=0;D<_;D++){var V=I[D];C.set(V,O),O+=V.length}return b.j=[C],C}}function Ys(m){Nt.call(this,m)}y(Ys,Nt);var Fp=[Ys,1,Kb,2,rn,3,Dp,4,Dp];Ys.prototype.l=Pa(Fp);function Da(m){Nt.call(this,m,-1,Xb)}y(Da,Nt),Da.prototype.addClassification=function(m,b){return xp(this,1,Ys,m,b),this};var Xb=[1],qb=Aa([Da,1,Op,Fp]);function Wr(m){Nt.call(this,m)}y(Wr,Nt);var Lp=[Wr,1,rn,2,rn,3,rn,4,rn,5,rn];Wr.prototype.l=Pa(Lp);function Bp(m){Nt.call(this,m,-1,Yb)}y(Bp,Nt);var Yb=[1],Qb=Aa([Bp,1,Op,Lp]);function jo(m){Nt.call(this,m)}y(jo,Nt);var zp=[jo,1,rn,2,rn,3,rn,4,rn,5,rn,6,jb],Zb=Aa(zp);jo.prototype.l=Pa(zp);function Vp(m,b,C){if(C=m.createShader(C===0?m.VERTEX_SHADER:m.FRAGMENT_SHADER),m.shaderSource(C,b),m.compileShader(C),!m.getShaderParameter(C,m.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+m.getShaderInfoLog(C));return C}function Jb(m){return Ta(m,Ys,1).map(function(b){var C=sn(b,1);return{index:C??0,qa:gn(b,2),label:sn(b,3)!=null?Wo(sn(b,3),""):void 0,displayName:sn(b,4)!=null?Wo(sn(b,4),""):void 0}})}function e1(m){return{x:gn(m,1),y:gn(m,2),z:gn(m,3),visibility:Na(m,4)!=null?gn(m,4):void 0}}function Oa(m){return Ta(Qb(m),Wr,1).map(e1)}function Fa(m,b){this.i=m,this.h=b,this.m=0}function Mp(m,b,C){return t1(m,b),typeof m.h.canvas.transferToImageBitmap=="function"?Promise.resolve(m.h.canvas.transferToImageBitmap()):C?Promise.resolve(m.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(m.h.canvas):(m.j===void 0&&(m.j=document.createElement("canvas")),new Promise(function(I){m.j.height=m.h.canvas.height,m.j.width=m.h.canvas.width,m.j.getContext("2d",{}).drawImage(m.h.canvas,0,0,m.h.canvas.width,m.h.canvas.height),I(m.j)}))}function t1(m,b){var C=m.h;if(m.s===void 0){var I=Vp(C,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),_=Vp(C,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),O=C.createProgram();if(C.attachShader(O,I),C.attachShader(O,_),C.linkProgram(O),!C.getProgramParameter(O,C.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+C.getProgramInfoLog(O));I=m.s=O,C.useProgram(I),_=C.getUniformLocation(I,"sampler0"),m.l={O:C.getAttribLocation(I,"aVertex"),N:C.getAttribLocation(I,"aTex"),ya:_},m.v=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,m.v),C.enableVertexAttribArray(m.l.O),C.vertexAttribPointer(m.l.O,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),m.u=C.createBuffer(),C.bindBuffer(C.ARRAY_BUFFER,m.u),C.enableVertexAttribArray(m.l.N),C.vertexAttribPointer(m.l.N,2,C.FLOAT,!1,0,0),C.bufferData(C.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),C.STATIC_DRAW),C.bindBuffer(C.ARRAY_BUFFER,null),C.uniform1i(_,0)}I=m.l,C.useProgram(m.s),C.canvas.width=b.width,C.canvas.height=b.height,C.viewport(0,0,b.width,b.height),C.activeTexture(C.TEXTURE0),m.i.bindTexture2d(b.glName),C.enableVertexAttribArray(I.O),C.bindBuffer(C.ARRAY_BUFFER,m.v),C.vertexAttribPointer(I.O,2,C.FLOAT,!1,0,0),C.enableVertexAttribArray(I.N),C.bindBuffer(C.ARRAY_BUFFER,m.u),C.vertexAttribPointer(I.N,2,C.FLOAT,!1,0,0),C.bindFramebuffer(C.DRAW_FRAMEBUFFER?C.DRAW_FRAMEBUFFER:C.FRAMEBUFFER,null),C.clearColor(0,0,0,0),C.clear(C.COLOR_BUFFER_BIT),C.colorMask(!0,!0,!0,!0),C.drawArrays(C.TRIANGLE_FAN,0,4),C.disableVertexAttribArray(I.O),C.disableVertexAttribArray(I.N),C.bindBuffer(C.ARRAY_BUFFER,null),m.i.bindTexture2d(0)}function n1(m){this.h=m}var s1=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function r1(m,b){return b+m}function Wp(m,b){window[m]=b}function o1(m){var b=document.createElement("script");return b.setAttribute("src",m),b.setAttribute("crossorigin","anonymous"),new Promise(function(C){b.addEventListener("load",function(){C()},!1),b.addEventListener("error",function(){C()},!1),document.body.appendChild(b)})}function i1(){return k(function(m){switch(m.h){case 1:return m.s=2,S(m,WebAssembly.instantiate(s1),4);case 4:m.h=3,m.s=0;break;case 2:return m.s=0,m.l=null,m.return(!1);case 3:return m.return(!0)}})}function La(m){if(this.h=m,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=m&&m.locateFile||r1,typeof window=="object")var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=b,m.options){b=a(Object.keys(m.options));for(var C=b.next();!C.done;C=b.next()){C=C.value;var I=m.options[C].default;I!==void 0&&(this.l[C]=typeof I=="function"?I():I)}}}n=La.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function a1(m){var b,C,I,_,O,D,V,U,q,ne,me;return k(function(le){switch(le.h){case 1:return m.ga?(b=m.h.files===void 0?[]:typeof m.h.files=="function"?m.h.files(m.l):m.h.files,S(le,i1(),2)):le.return();case 2:if(C=le.i,typeof window=="object")return Wp("createMediapipeSolutionsWasm",{locateFile:m.locateFile}),Wp("createMediapipeSolutionsPackedAssets",{locateFile:m.locateFile}),D=b.filter(function(oe){return oe.data!==void 0}),V=b.filter(function(oe){return oe.data===void 0}),U=Promise.all(D.map(function(oe){var ge=Ko(m,oe.url);if(oe.path!==void 0){var $e=oe.path;ge=ge.then(function(Ge){return m.overrideFile($e,Ge),Promise.resolve(Ge)})}return ge})),q=Promise.all(V.map(function(oe){return oe.simd===void 0||oe.simd&&C||!oe.simd&&!C?o1(m.locateFile(oe.url,m.ha)):Promise.resolve()})).then(function(){var oe,ge,$e;return k(function(Ge){if(Ge.h==1)return oe=window.createMediapipeSolutionsWasm,ge=window.createMediapipeSolutionsPackedAssets,$e=m,S(Ge,oe(ge),2);$e.i=Ge.i,Ge.h=0})}),ne=function(){return k(function(oe){return m.h.graph&&m.h.graph.url?oe=S(oe,Ko(m,m.h.graph.url),0):(oe.h=0,oe=void 0),oe})}(),S(le,Promise.all([q,U,ne]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return I=b.filter(function(oe){return oe.simd===void 0||oe.simd&&C||!oe.simd&&!C}).map(function(oe){return m.locateFile(oe.url,m.ha)}),importScripts.apply(null,u(I)),_=m,S(le,createMediapipeSolutionsWasm(Module),6);case 6:_.i=le.i,m.m=new OffscreenCanvas(1,1),m.i.canvas=m.m,O=m.i.GL.createContext(m.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),m.i.GL.makeContextCurrent(O),le.h=4;break;case 7:if(m.m=document.createElement("canvas"),me=m.m.getContext("webgl2",{}),!me&&(me=m.m.getContext("webgl",{}),!me))return alert("Failed to create WebGL canvas context when passing video frame."),le.return();m.K=me,m.i.canvas=m.m,m.i.createContext(m.m,!0,!0,{});case 4:m.j=new m.i.SolutionWasm,m.ga=!1,le.h=0}})}function u1(m){var b,C,I,_,O,D,V,U;return k(function(q){if(q.h==1){if(m.h.graph&&m.h.graph.url&&m.fa===m.h.graph.url)return q.return();if(m.u=!0,!m.h.graph||!m.h.graph.url){q.h=2;return}return m.fa=m.h.graph.url,S(q,Ko(m,m.h.graph.url),3)}for(q.h!=2&&(b=q.i,m.j.loadGraph(b)),C=a(Object.keys(m.D)),I=C.next();!I.done;I=C.next())_=I.value,m.j.overrideFile(_,m.D[_]);if(m.D={},m.h.listeners)for(O=a(m.h.listeners),D=O.next();!D.done;D=O.next())V=D.value,h1(m,V);U=m.l,m.l={},m.setOptions(U),q.h=0})}n.reset=function(){var m=this;return k(function(b){m.j&&(m.j.reset(),m.s={},m.v={}),b.h=0})},n.setOptions=function(m,b){var C=this;if(b=b||this.h.options){for(var I=[],_=[],O={},D=a(Object.keys(m)),V=D.next();!V.done;O={X:O.X,Y:O.Y},V=D.next())if(V=V.value,!(V in this.l&&this.l[V]===m[V])){this.l[V]=m[V];var U=b[V];U!==void 0&&(U.onChange&&(O.X=U.onChange,O.Y=m[V],I.push(function(q){return function(){var ne;return k(function(me){if(me.h==1)return S(me,q.X(q.Y),2);ne=me.i,ne===!0&&(C.u=!0),me.h=0})}}(O))),U.graphOptionXref&&(V=Object.assign({},{calculatorName:"",calculatorIndex:0},U.graphOptionXref,{valueNumber:U.type===1?m[V]:0,valueBoolean:U.type===0?m[V]:!1,valueString:U.type===2?m[V]:""}),_.push(V)))}(I.length!==0||_.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(_),this.F=(this.F===void 0?[]:this.F).concat(I))}};function l1(m){var b,C,I,_,O,D,V;return k(function(U){switch(U.h){case 1:if(!m.u)return U.return();if(!m.F){U.h=2;break}b=a(m.F),C=b.next();case 3:if(C.done){U.h=5;break}return I=C.value,S(U,I(),4);case 4:C=b.next(),U.h=3;break;case 5:m.F=void 0;case 2:if(m.H){for(_=new m.i.GraphOptionChangeRequestList,O=a(m.H),D=O.next();!D.done;D=O.next())V=D.value,_.push_back(V);m.j.changeOptions(_),_.delete(),m.H=void 0}m.u=!1,U.h=0}})}n.initialize=function(){var m=this;return k(function(b){return b.h==1?S(b,a1(m),2):b.h!=3?S(b,u1(m),3):S(b,l1(m),0)})};function Ko(m,b){var C,I;return k(function(_){return b in m.L?_.return(m.L[b]):(C=m.locateFile(b,""),I=fetch(C).then(function(O){return O.arrayBuffer()}),m.L[b]=I,_.return(I))})}n.overrideFile=function(m,b){this.j?this.j.overrideFile(m,b):this.D[m]=b},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(m,b){var C=this,I,_,O,D,V,U,q,ne,me;return k(function(le){switch(le.h){case 1:return C.h.inputs?(I=1e3*(b??performance.now()),S(le,C.I,2)):le.return();case 2:return S(le,C.initialize(),3);case 3:for(_=new C.i.PacketDataList,O=a(Object.keys(m)),D=O.next();!D.done;D=O.next())if(V=D.value,U=C.h.inputs[V]){e:{var oe=m[V];switch(U.type){case"video":var ge=C.s[U.stream];if(ge||(ge=new Fa(C.i,C.K),C.s[U.stream]=ge),ge.m===0&&(ge.m=ge.i.createTexture()),typeof HTMLVideoElement<"u"&&oe instanceof HTMLVideoElement)var $e=oe.videoWidth,Ge=oe.videoHeight;else typeof HTMLImageElement<"u"&&oe instanceof HTMLImageElement?($e=oe.naturalWidth,Ge=oe.naturalHeight):($e=oe.width,Ge=oe.height);Ge={glName:ge.m,width:$e,height:Ge},$e=ge.h,$e.canvas.width=Ge.width,$e.canvas.height=Ge.height,$e.activeTexture($e.TEXTURE0),ge.i.bindTexture2d(ge.m),$e.texImage2D($e.TEXTURE_2D,0,$e.RGBA,$e.RGBA,$e.UNSIGNED_BYTE,oe),ge.i.bindTexture2d(0),ge=Ge;break e;case"detections":for(ge=C.s[U.stream],ge||(ge=new n1(C.i),C.s[U.stream]=ge),ge.data||(ge.data=new ge.h.DetectionListData),ge.data.reset(oe.length),Ge=0;Ge<oe.length;++Ge){$e=oe[Ge];var Me=ge.data,ut=Me.setBoundingBox,Ht=Ge,Tt=$e.la,Ee=new jo;if(mn(Ee,1,Tt.sa),mn(Ee,2,Tt.ta),mn(Ee,3,Tt.height),mn(Ee,4,Tt.width),mn(Ee,5,Tt.rotation),fn(Ee,6,Tt.pa),Tt=Ee.l(),ut.call(Me,Ht,Tt),$e.ea)for(Me=0;Me<$e.ea.length;++Me){Ee=$e.ea[Me],ut=ge.data,Ht=ut.addNormalizedLandmark,Tt=Ge,Ee=Object.assign({},Ee,{visibility:Ee.visibility?Ee.visibility:0});var lt=new Wr;mn(lt,1,Ee.x),mn(lt,2,Ee.y),mn(lt,3,Ee.z),Ee.visibility&&mn(lt,4,Ee.visibility),Ee=lt.l(),Ht.call(ut,Tt,Ee)}if($e.ba)for(Me=0;Me<$e.ba.length;++Me)ut=ge.data,Ht=ut.addClassification,Tt=Ge,Ee=$e.ba[Me],lt=new Ys,mn(lt,2,Ee.qa),Ee.index&&fn(lt,1,Ee.index),Ee.label&&fn(lt,3,Ee.label),Ee.displayName&&fn(lt,4,Ee.displayName),Ee=lt.l(),Ht.call(ut,Tt,Ee)}ge=ge.data;break e;default:ge={}}}switch(q=ge,ne=U.stream,U.type){case"video":_.pushTexture2d(Object.assign({},q,{stream:ne,timestamp:I}));break;case"detections":me=q,me.stream=ne,me.timestamp=I,_.pushDetectionList(me);break;default:throw Error("Unknown input config type: '"+U.type+"'")}}return C.j.send(_),S(le,C.I,4);case 4:_.delete(),le.h=0}})};function c1(m,b,C){var I,_,O,D,V,U,q,ne,me,le,oe,ge,$e,Ge;return k(function(Me){switch(Me.h){case 1:if(!C)return Me.return(b);for(I={},_=0,O=a(Object.keys(C)),D=O.next();!D.done;D=O.next())V=D.value,U=C[V],typeof U!="string"&&U.type==="texture"&&b[U.stream]!==void 0&&++_;1<_&&(m.M=!1),q=a(Object.keys(C)),D=q.next();case 2:if(D.done){Me.h=4;break}if(ne=D.value,me=C[ne],typeof me=="string")return $e=I,Ge=ne,S(Me,d1(m,ne,b[me]),14);if(le=b[me.stream],me.type==="detection_list"){if(le){for(var ut=le.getRectList(),Ht=le.getLandmarksList(),Tt=le.getClassificationsList(),Ee=[],lt=0;lt<ut.size();++lt){var Hn=Zb(ut.get(lt)),p1=gn(Hn,1),f1=gn(Hn,2),m1=gn(Hn,3),g1=gn(Hn,4),y1=gn(Hn,5,0),Xo=void 0;Xo=Xo===void 0?0:Xo,Hn={la:{sa:p1,ta:f1,height:m1,width:g1,rotation:y1,pa:Wo(sn(Hn,6),Xo)},ea:Oa(Ht.get(lt)),ba:Jb(qb(Tt.get(lt)))},Ee.push(Hn)}ut=Ee}else ut=[];I[ne]=ut,Me.h=7;break}if(me.type==="proto_list"){if(le){for(ut=Array(le.size()),Ht=0;Ht<le.size();Ht++)ut[Ht]=le.get(Ht);le.delete()}else ut=[];I[ne]=ut,Me.h=7;break}if(le===void 0){Me.h=3;break}if(me.type==="float_list"){I[ne]=le,Me.h=7;break}if(me.type==="proto"){I[ne]=le,Me.h=7;break}if(me.type!=="texture")throw Error("Unknown output config type: '"+me.type+"'");return oe=m.v[ne],oe||(oe=new Fa(m.i,m.K),m.v[ne]=oe),S(Me,Mp(oe,le,m.M),13);case 13:ge=Me.i,I[ne]=ge;case 7:me.transform&&I[ne]&&(I[ne]=me.transform(I[ne])),Me.h=3;break;case 14:$e[Ge]=Me.i;case 3:D=q.next(),Me.h=2;break;case 4:return Me.return(I)}})}function d1(m,b,C){var I;return k(function(_){return typeof C=="number"||C instanceof Uint8Array||C instanceof m.i.Uint8BlobList?_.return(C):C instanceof m.i.Texture2dDataOut?(I=m.v[b],I||(I=new Fa(m.i,m.K),m.v[b]=I),_.return(Mp(I,C,m.M))):_.return(void 0)})}function h1(m,b){for(var C=b.name||"$",I=[].concat(u(b.wants)),_=new m.i.StringList,O=a(b.wants),D=O.next();!D.done;D=O.next())_.push_back(D.value);O=m.i.PacketListener.implement({onResults:function(V){for(var U={},q=0;q<b.wants.length;++q)U[I[q]]=V.get(q);var ne=m.listeners[C];ne&&(m.I=c1(m,U,b.outs).then(function(me){me=ne(me);for(var le=0;le<b.wants.length;++le){var oe=U[I[le]];typeof oe=="object"&&oe.hasOwnProperty&&oe.hasOwnProperty("delete")&&oe.delete()}me&&(m.I=me)}))}}),m.j.attachMultiListener(_,O),_.delete()}n.onResults=function(m,b){this.listeners[b||"$"]=m},X("Solution",La),X("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Up(m){switch(m===void 0&&(m=0),m){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Gp(m){var b=this;m=m||{},this.h=new La({locateFile:m.locateFile,files:function(C){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Up(C.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Oa},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Oa},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(C){var I,_,O;return k(function(D){return D.h==1?(I=Up(C),_="third_party/mediapipe/modules/pose_landmark/"+I,S(D,Ko(b.h,I),2)):(O=D.i,b.h.overrideFile(_,O),D.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Gp.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(m){this.h.onResults(m)},n.initialize=function(){var m=this;return k(function(b){return S(b,m.h.initialize(),0)})},n.send=function(m,b){var C=this;return k(function(I){return S(I,C.h.send(m,b),0)})},n.setOptions=function(m){this.h.setOptions(m)},X("Pose",Gp),X("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),X("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),X("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),X("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),X("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),X("VERSION","0.5.1675469404")}).call(Ba)),Ba}var C1=v1();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S1=1e-7,$1=1e-4;class rg{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class rl{refCount(e){return Et("refCount")}incRef(e){return Et("incRef")}timerAvailable(){return!0}time(e){return Et("time")}read(e){return Et("read")}readSync(e){return Et("readSync")}readToGPU(e,t){return Et("readToGPU")}numDataIds(){return Et("numDataIds")}disposeData(e,t){return Et("disposeData")}write(e,t,s){return Et("write")}move(e,t,s,r,o){return Et("move")}createTensorFromGPUData(e,t,s){return Et("createTensorFromGPUData")}memory(){return Et("memory")}floatPrecision(){return Et("floatPrecision")}epsilon(){return this.floatPrecision()===32?S1:$1}dispose(){return Et("dispose")}}function Et(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xi(n,e,t){return Math.max(n,Math.min(e,t))}function ol(n){return n%2===0?n:n+1}function Ur(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function og(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function T(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Ot(n,e,t=""){T(Ae(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function xr(n){T(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function H(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Kp(n){return n.length===0}function I1(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Ae(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function ur(n){return n%1===0}function du(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function rr(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Xp(n,e=r=>0,t,s){return new Promise((r,o)=>{let i=0;const a=()=>{if(n()){r();return}i++;const u=e(i);if(t!=null&&i>=t){o();return}s!=null?s(a,u):setTimeout(a,u)};a()})}function ig(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Ue(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),T(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),T(n.every(s=>ur(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function rs(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:Ue(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Sn(n,e){return Je(n,e)}function Je(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function k1(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function N1(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function ag(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function bi(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function T1(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function So(n){return typeof n=="string"||n instanceof String}function E1(n){return typeof n=="boolean"}function R1(n){return typeof n=="number"}function br(n){return Array.isArray(n)?br(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":R1(n)?"float32":So(n)?"string":E1(n)?"bool":"float32"}function hu(n){return!!(n&&n.constructor&&n.call&&n.apply)}function pu(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Xe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function ug(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let i=0;i<o;i++)r[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(s?2:1);for(let u=0;u<o;u++)r[u]=ug(n+u*a,i,t,s)}return r}function fu(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return ug(0,n,e,t)}function za(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function lg(n,e){const t=An(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function An(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Wt(n){n.forEach(e=>{T(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function mu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function il(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Es(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qp="tfjsflags";class _1{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=A1,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Es(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);qp in e&&e[qp].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=D1(r,o)})}}function A1(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(P1(e,s[0],s[1]),s.join("="))),e}function P1(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function D1(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function M(){return cg}let cg=null;function O1(n){cg=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Va;function dg(){if(Va==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Va=n}return Va}function F1(){const n=dg();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function al(n,e){const t=F1();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const ul="Abs",ll="Acos",cl="Acosh",Wi="Add",dl="AddN",hl="All",pl="Any",fl="ArgMax",ml="ArgMin",gl="Asin",yl="Asinh",xl="Atan",bl="Atanh",wl="Atan2",vl="AvgPool",hg="AvgPoolGrad",Cl="AvgPool3D",pg="AvgPool3DGrad",Sl="BatchMatMul",$l="BatchToSpaceND",Il="Bincount",fg="BitwiseAnd",kl="BroadcastArgs",Ui="Cast",Nl="Ceil",Tl="ClipByValue",El="Complex",Rl="ComplexAbs",_l="Concat",Al="Conv2D",Pl="Conv2DBackpropFilter",Dl="Conv2DBackpropInput",Ol="Conv3D",mg="Conv3DBackpropFilterV2",Fl="Conv3DBackpropInputV2",Ll="Cos",Bl="Cosh",zl="Cumprod",Vl="Cumsum",Ml="CropAndResize",Wl="DenseBincount",Ul="DepthToSpace",Gl="DepthwiseConv2dNative",Hl="DepthwiseConv2dNativeBackpropFilter",jl="DepthwiseConv2dNativeBackpropInput",Kl="Diag",Xl="Dilation2D",L1="Dilation2DBackpropInput",B1="Dilation2DBackpropFilter",gg="Draw",ql="RealDiv",Yl="Einsum",Ql="Elu",yg="EluGrad",Zl="Erf",Jl="Equal",ec="Exp",tc="ExpandDims",nc="Expm1",sc="FFT",rc="Fill",oc="FlipLeftRight",ic="Floor",ac="FloorDiv",uc="FusedBatchNorm",lc="GatherV2",cc="GatherNd",dc="Greater",hc="GreaterEqual",Gi="Identity",pc="IFFT",fc="Imag",mc="IsFinite",gc="IsInf",yc="IsNan",xc="LeakyRelu",bc="Less",wc="LessEqual",vc="LinSpace",Cc="Log",Sc="Log1p",$c="LogicalAnd",Ic="LogicalNot",kc="LogicalOr",Nc="LRN",xg="LRNGrad",Tc="Max",Ec="Maximum",Rc="MaxPool",bg="MaxPoolGrad",_c="MaxPool3D",wg="MaxPool3DGrad",Ac="MaxPoolWithArgmax",Pc="Mean",Dc="Min",Oc="Minimum",Fc="MirrorPad",Lc="Mod",Bc="Multinomial",zc="Multiply",Vc="Neg",Mc="NotEqual",Wc="NonMaxSuppressionV3",vg="NonMaxSuppressionV4",Uc="NonMaxSuppressionV5",Gc="OnesLike",Hc="OneHot",jc="Pack",Kc="PadV2",Xc="Pow",qc="Prelu",Yc="Prod",Cg="RaggedGather",Sg="RaggedRange",$g="RaggedTensorToTensor",Qc="Range",Zc="Real",Jc="Reciprocal",ed="Relu",td="Reshape",nd="ResizeNearestNeighbor",Ig="ResizeNearestNeighborGrad",sd="ResizeBilinear",kg="ResizeBilinearGrad",rd="Relu6",od="Reverse",id="Round",ad="Rsqrt",ud="ScatterNd",ld="TensorScatterUpdate",cd="SearchSorted",dd="Select",hd="Selu",pd="Slice",fd="Sin",md="Sinh",gd="Sign",yd="Sigmoid",xd="Softplus",bd="Sqrt",wd="Sum",vd="SpaceToBatchND",Cd="SplitV",Sd="Softmax",Ng="SparseFillEmptyRows",Tg="SparseReshape",$d="SparseSegmentMean",Id="SparseSegmentSum",kd="SparseToDense",Nd="SquaredDifference",Eg="Square",Rg="StaticRegexReplace",Td="StridedSlice",Ed="StringNGrams",_g="StringSplit",Ag="StringToHashBucketFast",Rd="Sub",_d="Tan",Ad="Tanh",Hi="Tile",Pd="TopK",Dd="Transform",eo="Transpose",Pg="Unique",Od="Unpack",Fd="UnsortedSegmentSum",Ld="ZerosLike",Bd="Step",wi="FromPixels",zd="RotateWithOffset",vi="_FusedMatMul",Ci="FusedConv2D",Si="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(...n)}function z1(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $i=al("kernelRegistry",()=>new Map),V1=al("gradRegistry",()=>new Map);function Ii(n,e){const t=Og(n,e);return $i.get(t)}function Yp(n){return V1.get(n)}function Qp(n){const e=$i.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,i]=r,[a]=o.split("_");a===n&&t.push(i)}return t}function Dg(n){const{kernelName:e,backendName:t}=n,s=Og(e,t);$i.has(s)&&ln(`The kernel '${e}' for backend '${t}' is already registered`),$i.set(s,n)}function Og(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ma,Zp;function M1(){if(Zp)return Ma;Zp=1,Ma=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(A,k,W){this.low=A|0,this.high=k|0,this.unsigned=!!W}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(A){return(A&&A.__isLong__)===!0}e.isLong=t;var s={},r={};function o(A,k){var W,G,K;return k?(A>>>=0,(K=0<=A&&A<256)&&(G=r[A],G)?G:(W=a(A,(A|0)<0?-1:0,!0),K&&(r[A]=W),W)):(A|=0,(K=-128<=A&&A<128)&&(G=s[A],G)?G:(W=a(A,A<0?-1:0,!1),K&&(s[A]=W),W))}e.fromInt=o;function i(A,k){if(isNaN(A))return k?w:x;if(k){if(A<0)return w;if(A>=f)return F}else{if(A<=-9223372036854776e3)return L;if(A+1>=g)return P}return A<0?i(-A,k).neg():a(A%p|0,A/p|0,k)}e.fromNumber=i;function a(A,k,W){return new e(A,k,W)}e.fromBits=a;var u=Math.pow;function l(A,k,W){if(A.length===0)throw Error("empty string");if(A==="NaN"||A==="Infinity"||A==="+Infinity"||A==="-Infinity")return x;if(typeof k=="number"?(W=k,k=!1):k=!!k,W=W||10,W<2||36<W)throw RangeError("radix");var G;if((G=A.indexOf("-"))>0)throw Error("interior hyphen");if(G===0)return l(A.substring(1),k,W).neg();for(var K=i(u(W,8)),X=x,ee=0;ee<A.length;ee+=8){var ce=Math.min(8,A.length-ee),de=parseInt(A.substring(ee,ee+ce),W);if(ce<8){var he=i(u(W,ce));X=X.mul(he).add(i(de))}else X=X.mul(K),X=X.add(i(de))}return X.unsigned=k,X}e.fromString=l;function c(A,k){return typeof A=="number"?i(A,k):typeof A=="string"?l(A,k):a(A.low,A.high,typeof k=="boolean"?k:A.unsigned)}e.fromValue=c;var d=65536,h=1<<24,p=d*d,f=p*p,g=f/2,y=o(h),x=o(0);e.ZERO=x;var w=o(0,!0);e.UZERO=w;var $=o(1);e.ONE=$;var S=o(1,!0);e.UONE=S;var E=o(-1);e.NEG_ONE=E;var P=a(-1,2147483647,!1);e.MAX_VALUE=P;var F=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var L=a(0,-2147483648,!1);e.MIN_VALUE=L;var R=e.prototype;return R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},R.toString=function(k){if(k=k||10,k<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var W=i(k),G=this.div(W),K=G.mul(W).sub(this);return G.toString(k)+K.toInt().toString(k)}else return"-"+this.neg().toString(k);for(var X=i(u(k,6),this.unsigned),ee=this,ce="";;){var de=ee.div(X),he=ee.sub(de.mul(X)).toInt()>>>0,Ce=he.toString(k);if(ee=de,ee.isZero())return Ce+ce;for(;Ce.length<6;)Ce="0"+Ce;ce=""+Ce+ce}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var k=this.high!=0?this.high:this.low,W=31;W>0&&(k&1<<W)==0;W--);return this.high!=0?W+33:W+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function(k){return t(k)||(k=c(k)),this.unsigned!==k.unsigned&&this.high>>>31===1&&k.high>>>31===1?!1:this.high===k.high&&this.low===k.low},R.eq=R.equals,R.notEquals=function(k){return!this.eq(k)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function(k){return this.comp(k)<0},R.lt=R.lessThan,R.lessThanOrEqual=function(k){return this.comp(k)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function(k){return this.comp(k)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function(k){return this.comp(k)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function(k){if(t(k)||(k=c(k)),this.eq(k))return 0;var W=this.isNegative(),G=k.isNegative();return W&&!G?-1:!W&&G?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add($)},R.neg=R.negate,R.add=function(k){t(k)||(k=c(k));var W=this.high>>>16,G=this.high&65535,K=this.low>>>16,X=this.low&65535,ee=k.high>>>16,ce=k.high&65535,de=k.low>>>16,he=k.low&65535,Ce=0,Re=0,De=0,je=0;return je+=X+he,De+=je>>>16,je&=65535,De+=K+de,Re+=De>>>16,De&=65535,Re+=G+ce,Ce+=Re>>>16,Re&=65535,Ce+=W+ee,Ce&=65535,a(De<<16|je,Ce<<16|Re,this.unsigned)},R.subtract=function(k){return t(k)||(k=c(k)),this.add(k.neg())},R.sub=R.subtract,R.multiply=function(k){if(this.isZero())return x;if(t(k)||(k=c(k)),n){var W=n.mul(this.low,this.high,k.low,k.high);return a(W,n.get_high(),this.unsigned)}if(k.isZero())return x;if(this.eq(L))return k.isOdd()?L:x;if(k.eq(L))return this.isOdd()?L:x;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt(y)&&k.lt(y))return i(this.toNumber()*k.toNumber(),this.unsigned);var G=this.high>>>16,K=this.high&65535,X=this.low>>>16,ee=this.low&65535,ce=k.high>>>16,de=k.high&65535,he=k.low>>>16,Ce=k.low&65535,Re=0,De=0,je=0,nn=0;return nn+=ee*Ce,je+=nn>>>16,nn&=65535,je+=X*Ce,De+=je>>>16,je&=65535,je+=ee*he,De+=je>>>16,je&=65535,De+=K*Ce,Re+=De>>>16,De&=65535,De+=X*he,Re+=De>>>16,De&=65535,De+=ee*de,Re+=De>>>16,De&=65535,Re+=G*Ce+K*he+X*de+ee*ce,Re&=65535,a(je<<16|nn,Re<<16|De,this.unsigned)},R.mul=R.multiply,R.divide=function(k){if(t(k)||(k=c(k)),k.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&k.low===-1&&k.high===-1)return this;var W=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,k.low,k.high);return a(W,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:x;var G,K,X;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return w;if(k.gt(this.shru(1)))return S;X=w}else{if(this.eq(L)){if(k.eq($)||k.eq(E))return L;if(k.eq(L))return $;var ee=this.shr(1);return G=ee.div(k).shl(1),G.eq(x)?k.isNegative()?$:E:(K=this.sub(k.mul(G)),X=G.add(K.div(k)),X)}else if(k.eq(L))return this.unsigned?w:x;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();X=x}for(K=this;K.gte(k);){G=Math.max(1,Math.floor(K.toNumber()/k.toNumber()));for(var ce=Math.ceil(Math.log(G)/Math.LN2),de=ce<=48?1:u(2,ce-48),he=i(G),Ce=he.mul(k);Ce.isNegative()||Ce.gt(K);)G-=de,he=i(G,this.unsigned),Ce=he.mul(k);he.isZero()&&(he=$),X=X.add(he),K=K.sub(Ce)}return X},R.div=R.divide,R.modulo=function(k){if(t(k)||(k=c(k)),n){var W=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,k.low,k.high);return a(W,n.get_high(),this.unsigned)}return this.sub(this.div(k).mul(k))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return a(~this.low,~this.high,this.unsigned)},R.and=function(k){return t(k)||(k=c(k)),a(this.low&k.low,this.high&k.high,this.unsigned)},R.or=function(k){return t(k)||(k=c(k)),a(this.low|k.low,this.high|k.high,this.unsigned)},R.xor=function(k){return t(k)||(k=c(k)),a(this.low^k.low,this.high^k.high,this.unsigned)},R.shiftLeft=function(k){return t(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?a(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):a(0,this.low<<k-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function(k){return t(k)&&(k=k.toInt()),(k&=63)===0?this:k<32?a(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):a(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function(k){if(t(k)&&(k=k.toInt()),k&=63,k===0)return this;var W=this.high;if(k<32){var G=this.low;return a(G>>>k|W<<32-k,W>>>k,this.unsigned)}else return k===32?a(W,0,this.unsigned):a(W>>>k-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},R.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var k=this.high,W=this.low;return[W&255,W>>>8&255,W>>>16&255,W>>>24,k&255,k>>>8&255,k>>>16&255,k>>>24]},R.toBytesBE=function(){var k=this.high,W=this.low;return[k>>>24,k>>>16&255,k>>>8&255,k&255,W>>>24,W>>>16&255,W>>>8&255,W&255]},e.fromBytes=function(k,W,G){return G?e.fromBytesLE(k,W):e.fromBytesBE(k,W)},e.fromBytesLE=function(k,W){return new e(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,W)},e.fromBytesBE=function(k,W){return new e(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],W)},Ma}var Lg=M1();const Bg=b1(Lg),W1=x1({__proto__:null,default:Bg},[Lg]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xs=Bg||W1;function ji(n){return xs.fromString(n,!0,16)}const zg=ji("c3a5c85c97cb3127"),gs=ji("b492b66fbe98f273"),gt=ji("9ae16a3b2f90404f");function gu(n){return n.xor(n.shru(47))}function Vg(n,e,t){const s=n.slice(e,e+t);return xs.fromBytes(Array.from(s),!0,!0)}function Ve(n,e){return Vg(n,e,8)}function Jp(n,e){return Vg(n,e,4)}function tt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Yn(n,e,t=ji("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function U1(n,e,t,s,r,o){r=r.add(n),o=tt(o.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(t),o=o.add(tt(r,44)),[r.add(s),o.add(i)]}function qo(n,e,t,s){return U1(Ve(n,e),Ve(n,e+8),Ve(n,e+16),Ve(n,e+24),t,s)}function G1(n,e=n.length){if(e>=8){const t=gt.add(e*2),s=Ve(n,0).add(gt),r=Ve(n,e-8),o=tt(r,37).mul(t).add(s),i=tt(s,25).add(r).mul(t);return Yn(o,i,t)}if(e>=4){const t=gt.add(e*2),s=Jp(n,0);return Yn(s.shl(3).add(e),Jp(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),i=e+(r<<2);return gu(gt.mul(o).xor(zg.mul(i))).mul(gt)}return gt}function H1(n,e=n.length){const t=gt.add(e*2),s=Ve(n,0).mul(gs),r=Ve(n,8),o=Ve(n,e-8).mul(t),i=Ve(n,e-16).mul(gt);return Yn(tt(s.add(r),43).add(tt(o,30)).add(i),s.add(tt(r.add(gt),18)).add(o),t)}function j1(n,e=n.length){const t=gt.add(e*2),s=Ve(n,0).mul(gt),r=Ve(n,8),o=Ve(n,e-8).mul(t),i=Ve(n,e-16).mul(gt),a=tt(s.add(r),43).add(tt(o,30)).add(i),u=Yn(a,s.add(tt(r.add(gt),18)).add(o),t),l=Ve(n,16).mul(t),c=Ve(n,24),d=a.add(Ve(n,e-32)).mul(t),h=u.add(Ve(n,e-24)).mul(t);return Yn(tt(l.add(c),43).add(tt(d,30)).add(h),l.add(tt(c.add(s),18)).add(d),t)}function K1(n,e=n.length){const t=xs.fromNumber(81,!0);if(e<=32)return e<=16?G1(n,e):H1(n,e);if(e<=64)return j1(n,e);let s=t,r=t.mul(gs).add(113),o=gu(r.mul(gt).add(113)).mul(gt),i=[xs.UZERO,xs.UZERO],a=[xs.UZERO,xs.UZERO];s=s.mul(gt).add(Ve(n,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do s=tt(s.add(r).add(i[0]).add(Ve(n,u+8)),37).mul(gs),r=tt(r.add(i[1]).add(Ve(n,u+48)),42).mul(gs),s=s.xor(a[1]),r=r.add(i[0]).add(Ve(n,u+40)),o=tt(o.add(a[0]),33).mul(gs),i=qo(n,u,i[1].mul(gs),s.add(a[0])),a=qo(n,u+32,o.add(a[1]),r.add(Ve(n,u+16))),[o,s]=[s,o],u+=64;while(u!==l);const d=gs.add(o.and(255).shl(1));return u=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),s=tt(s.add(r).add(i[0]).add(Ve(n,u+8)),37).mul(d),r=tt(r.add(i[1]).add(Ve(n,u+48)),42).mul(d),s=s.xor(a[1].mul(9)),r=r.add(i[0].mul(9).add(Ve(n,u+40))),o=tt(o.add(a[0]),33).mul(d),i=qo(n,u,i[1].mul(d),s.add(a[0])),a=qo(n,u+32,o.add(a[1]),r.add(Ve(n,u+16))),[o,s]=[s,o],Yn(Yn(i[0],a[0],d).add(gu(r).mul(zg)).add(o),Yn(i[1],a[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(n,e){return e==="string"?Qn(n):Ki([n],e)}function X1(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ki(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Dn(n)),M().getBool("DEBUG")&&k1(n,e),X1(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function on(){return M().platform.now()}function Qn(n,e="utf-8"){return e=e||"utf-8",M().platform.encode(n,e)}function Pn(n,e="utf-8"){return e=e||"utf-8",M().platform.decode(n,e)}function Qt(n){return M().platform.isTypedArray!=null?M().platform.isTypedArray(n):Fg(n)}function Dn(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Es(n)||n==null||Qt(n)&&t)e.push(n);else if(Array.isArray(n)||Qt(n))for(let s=0;s<n.length;++s)Dn(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Dn(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q1{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Q1)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let i;const a=on();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const l of r)l.dataSync();i=Promise.resolve({kernelMs:on()-a})}if(M().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const c=r[l];c.data().then(d=>{Y1(d,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:i}=e;s.forEach(a=>{Promise.all([a.data(),r,i]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],o,u[2])})})}}function Y1(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class Q1{logKernelProfile(e,t,s,r,o,i){const a=typeof r=="number"?rr(`${r}ms`,9):r.error,u=rr(e,25),l=t.rank,c=t.size,d=rr(t.shape.toString(),14);let h="";for(const p in o){const f=o[p];if(f!=null){const g=f.shape||t.shape,y=g.length;h+=`${p}: ${y}D ${y>0?g:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${d}	%c${c}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],c=l.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<e.length;f++)if(s[h.id]){l.outputs.forEach(g=>s[g.id]=!0),p=!0,r[l.id]=!0;break}if(p)break}}const o={};o[t.id]=!0;const i={};for(let u=n.length-1;u>=0;u--){const l=n[u],c=l.inputs;for(let d=0;d<l.outputs.length;d++)if(o[l.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[l.id]=!0;break}}const a=[];for(let u=0;u<n.length;u++){const l=n[u];if(r[l.id]&&i[l.id]){const c={};for(const h in l.inputs){const p=l.inputs[h];s[p.id]&&(c[h]=p)}const d=Object.assign({},l);d.inputs=c,d.outputs=l.outputs,a.push(d)}}return a}function J1(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],i=[];if(o.outputs.forEach(u=>{const l=n[u.id];l!=null?i.push(l):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const u in o.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=o.inputs[u];if(!Ae(l.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=l;else{const d=n[c.id];n[c.id]=s(d,l),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ef=20,Gr=3,Wa=7;function ew(n,e,t,s){const r=Xe(e),o=tw(n,e,t,r),i=e.length,a=ii(n,e,t,r,o),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function tw(n,e,t,s){const r=H(e),o=s[s.length-1],i=new Array(o).fill(0),a=e.length,u=t==="complex64"?qr(n):n;if(a>1)for(let l=0;l<r/o;l++){const c=l*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],Xr(u[c+d],0,t).length)}return i}function Xr(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Wa))} + ${parseFloat(n[1].toFixed(Wa))}j`:So(n)?s=`'${n}'`:t==="bool"?s=Mg(n):s=parseFloat(n.toFixed(Wa)).toString(),rr(s,e)}function Mg(n){return n===0?"false":"true"}function ii(n,e,t,s,r,o=!0){const i=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){const g=qr(n);return[Xr(g[0],0,t)]}return t==="bool"?[Mg(n[0])]:[n[0].toString()]}if(u===1){if(a>ef){const y=Gr*i;let x=Array.from(n.slice(0,y)),w=Array.from(n.slice((a-Gr)*i,a*i));return t==="complex64"&&(x=qr(x),w=qr(w)),["["+x.map(($,S)=>Xr($,r[S],t)).join(", ")+", ..., "+w.map(($,S)=>Xr($,r[a-Gr+S],t)).join(", ")+"]"]}return["["+(t==="complex64"?qr(n):Array.from(n)).map((y,x)=>Xr(y,r[x],t)).join(", ")+"]"]}const l=e.slice(1),c=s.slice(1),d=s[0]*i,h=[];if(a>ef){for(let g=0;g<Gr;g++){const y=g*d,x=y+d;h.push(...ii(n.slice(y,x),l,t,c,r,!1))}h.push("...");for(let g=a-Gr;g<a;g++){const y=g*d,x=y+d;h.push(...ii(n.slice(y,x),l,t,c,r,g===a-1))}}else for(let g=0;g<a;g++){const y=g*d,x=y+d;h.push(...ii(n.slice(y,x),l,t,c,r,g===a-1))}const p=u===2?",":"";h[0]="["+(a>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function qr(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lr{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=H(e),s!=null){const r=s.length;T(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Je(t,this.size),this.strides=Xe(e)}set(e,...t){t.length===0&&(t=[0]),T(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return an().makeTensor(this.values,this.shape,this.dtype)}}let an=null,tr=null;function nw(n){an=n}function sw(n){tr=n}class Ke{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=H(e),this.strides=Xe(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return tr.buffer(this.shape,this.dtype,e)}bufferSync(){return tr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return fu(this.shape,e,this.dtype==="complex64")}arraySync(){return fu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=an().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Pn(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),an().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=an().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Pn(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await an().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),an().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return tr.print(this,e)}clone(){return this.throwIfDisposed(),tr.clone(this)}toString(e=!1){const t=this.dataSync();return ew(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),tr.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),an().makeVariable(this,e,t,s)}}Object.defineProperty(Ke,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Wg(){return al("Tensor",()=>Ke)}Wg();class ki extends Ke{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ae(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);an().disposeTensor(this),this.dataId=e.dataId,an().incRef(this,null)}dispose(){an().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ki,Symbol.hasInstance,{value:n=>n instanceof Ke&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var tf;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(tf||(tf={}));var yu;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(yu||(yu={}));var xu;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(xu||(xu={}));var bu;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(bu||(bu={}));var wu;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(wu||(wu={}));const rw={float32:bu,int32:yu,bool:xu,complex64:wu};function $t(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return rw[n][e]}function Xi(n){return $t(n,"int32")}function Ug(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Gg(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qe(n,e){if(n.dtype===e.dtype)return[n,e];const t=$t(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function ow(n,e){T(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Hg(n){const e=[];return jg(n,e,new Set),e}function jg(n,e,t){if(n==null)return;if(n instanceof Ke){e.push(n);return}if(!iw(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),jg(o,e,t))}}function iw(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(n){return n.kernelName!=null}class nf{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class cr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new nf}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(ln(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new q1(this.backendInstance),!0}setupRegisteredKernels(){Qp(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Qp(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof rl)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ln(`Initialization of backend ${e} failed`),ln(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return ln(`Initialization of backend ${e} failed`),ln(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return cr.nextTensorId++}nextVariableId(){return cr.nextVariableId++}clone(e){const t=z.runKernel(Gi,{x:e}),s={x:e},r=i=>({x:()=>{const a="float32",u={x:i},l={dtype:a};return z.runKernel(Ui,u,l)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Ii(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(u=>{o+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const l=Ua(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ua(e)){const{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const x=Ii(f,this.backendName);T(x!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const w=this.backend.numDataIds();u=x.kernelFunc({inputs:g,attrs:y,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,w,$);const S=$.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(f,g,S);s=this.saveTensorsForBackwardMode(E)}return S}}else{const{forwardFunc:f}=e,g=y=>{r&&(s=y.map(x=>this.keep(this.clone(x))))};a=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,g));const x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,y,x),x}}const{inputs:c,attrs:d}=e,h=Ua(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(l,c,t,h,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Yp(e);if(r!=null){const o=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(T(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=o.map(l=>t[l]);const u=s.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&So(e[0])&&(o=e.map(u=>Qn(u)));const i=r.write(o,t,s),a=new Ke(t,s,i,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const u=this.state.tensorInfo.get(i),l=T1(o);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,i=new Ke(r,o,s,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new ki(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*bi(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof ki||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*bi(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},u=Yp(e);u!=null&&(r=u.gradFunc),r!=null&&(a.gradient=l=>(l=l.map((c,d)=>{if(c==null){const h=s[d],p=An(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),r(l.length>1?l:l[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Hg(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(T(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));T(o instanceof Ke,()=>"The result y returned by f() must be a tensor.");const i=Z1(this.state.activeTape,t,o);if(!r&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=s??aw(o.shape),J1(a,i,l=>this.tidy(l),uw);const u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return T(hu(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{T(t.every(a=>a instanceof Ke),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,u)=>{r[u]=a});const o=(a,u)=>(s=e(...t,u),T(s.value instanceof Ke,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),T(hu(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(a,u)=>{const l=s.gradFunc(a,u),c=Array.isArray(l)?l:[l];T(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),T(c.every(h=>h instanceof Ke),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=on(),s=await this.backend.time(e);return s.wallMs=on()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new nf;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}cr.nextTensorId=0;cr.nextVariableId=0;function aw(n){const e=lg(H(n),"float32");return z.makeTensor(e,n,"float32")}function Kg(){const n=dg();if(n._tfengine==null){const e=new _1(n);n._tfengine=new cr(e)}return O1(n._tfengine.ENV),nw(()=>n._tfengine),n._tfengine}const z=Kg();function uw(n,e){const t={a:n,b:e};return z.runKernel(Wi,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lw(){return typeof navigator<"u"&&navigator!=null}function Xg(n){if(n||lw()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function qg(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const It=M();It.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});It.registerFlag("IS_BROWSER",()=>qg());It.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");It.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));It.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));It.registerFlag("PROD",()=>!1);It.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>It.getBool("DEBUG"));It.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);It.registerFlag("IS_TEST",()=>!1);It.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>It.getBool("DEBUG"));It.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);It.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);It.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(n,e){let t=n;if(Qt(n))return e==="string"?[]:[n.length];if(Ug(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(Gg(n))return[n.buffer.size/(e==null?4:bi(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Qt(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&M().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Yg(n,s,[]),s}function Yg(n,e,t){if(t=t||[],!Array.isArray(n)&&!Qt(n)){T(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}T(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),T(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)Yg(n[r],s,t.concat(r))}function sf(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function N(n,e,t,s="numeric"){if(n instanceof Wg())return sf(s,n.dtype,e,t),n;let r=br(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),sf(s,r,e,t),n==null||!Qt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=os(n,r);!Qt(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?Ki(n,r):Dn(n,[],!0);return z.makeTensor(a,o,r)}function Ni(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>N(o,`${e}[${i}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qg="__op";function B(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Qg;const r=(...o)=>{z.startScope(t);try{const i=s(...o);return Es(i)&&console.error("Cannot return a Promise inside of tidy."),z.endScope(i),i}catch(i){throw z.endScope(null),i}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n,e){const t=N(n,"real","complex"),s=N(e,"imag","complex");Ot(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return z.runKernel(El,r)}const es=B({complex_:cw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function is(n,e,t,s){if(s==null)s=br(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Gg(n)||Ug(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return z.backend.createTensorFromGPUData(n,e||t,s)}if(!Qt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Wt(e);const r=H(e),o=H(t);T(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],u=i===t.length-1?a!==H(e.slice(i)):!0;T(t[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Qt(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Ki(n,s):Dn(n,[],!0),z.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(n,e,t){const s=os(n,t);return is(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class dn{static join(e){return new dn(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Qt(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),i=new Uint8Array(o);let a=0;for(let u=s;u<this.shards.length;u++){const l=this.shards[u],d=e+a-l.start,h=a,f=Math.min(t,l.end)-l.start,g=new Uint8Array(l.buffer,d,f-d);if(i.set(g,h),a+=g.length,t<l.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=dw(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function dw(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(){return z}function fe(n,e){return z.tidy(n,e)}function _e(n){Hg(n).forEach(t=>t.dispose())}function xn(n){return z.keep(n)}function ro(){return z.backendName}function Zg(n,e,t=1){return z.registerBackend(n,e,t)}function dr(){return z.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ts=4;async function hw(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<r.length;++i){const a=r[i],u=Array.isArray(n)?n[i].tensor:n[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async d=>{const h=await u.bytes(),p=h.reduce((y,x)=>y+x.length,0)+ts*h.length,f=new Uint8Array(p);let g=0;for(let y=0;y<h.length;y++){const x=h[y],w=new Uint8Array(new Uint32Array([x.length]).buffer);f.set(w,g),g+=ts,f.set(x,g),g+=x.length}d(f)});s.push(c)}else s.push(u.data());e!=null&&(l.group=e),t.push(l)}const o=await Promise.all(s);return{data:mw(o),specs:t}}function Jg(n,e){const t=new dn(n),s={};let r=0;for(const o of e){const i=pw(o,(a,u)=>t.slice(r+a,r+u));s[o.name]=ey(o,t.slice(r,r+i)),r+=i}return s}function pw(n,e){const t=H(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Rs[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=ts+new Uint32Array(e(r,r+ts))[0];return r}else s=Rs[n.dtype];return t*s}async function fw(n,e){const t=H(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Rs[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=ts+new Uint32Array(await e(r,r+ts))[0];return r}else s=Rs[n.dtype];return t*s}function ey(n,e){const t=n.name,s=n.dtype,r=n.shape,o=H(r);let i,a=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=Rs[u.dtype],c=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=h*u.scale+u.min}}else if(u.dtype==="float16")i=Cw()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=Math.round(h*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*l}else if(s==="string"){const u=H(n.shape);i=[];for(let l=0;l<u;l++){const c=new Uint32Array(e.slice(a,a+ts))[0];a+=ts;const d=new Uint8Array(e.slice(a,a+c));i.push(d),a+=c}}else{const u=Rs[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const l=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<l.length;f++)l[f]=i[f*2],c[f]=i[f*2+1];const d=wn(l,r,"float32"),h=wn(c,r,"float32"),p=es(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=o*u}return wn(i,r,s)}async function rf(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:o}=await n.read();if(r&&o==null){const a=t-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(s.length+o.byteLength);i.set(s,0),i.set(new Uint8Array(o),s.length),s=i}return s.buffer}async function ty(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const o of e){const i=await fw(o,async(l,c)=>(r=await rf(s,r,c),r.slice(l,c)));r=await rf(s,r,i);const a=r.slice(0,i);r=r.slice(i);const u=ey(o,a);if(t[o.name]=u,ro()==="webgpu"){const l=dr();"uploadToGPU"in l&&H(u.shape)>=M().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return t}function mw(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Vd=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function of(n){return Vd?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function gw(n){if(Vd)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function yw(n){if(Vd){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function xw(n){return dn.join(n)}function af(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function ny(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function sy(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function Md(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),sy(n,t,s)}function $o(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:of(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:of(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new dn(n.weightData).byteLength}}function vu(n){const e=[];for(const t of n)e.push(...t.weights);return e}function bw(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function ww(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function vw(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Cw(){const n=bw(),e=ww(),t=vw();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let i=0;i<s.length;i++){const a=s[i],u=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class He{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return He.instance==null&&(He.instance=new He),He.instance}static registerSaveRouter(e){He.getInstance().saveRouters.push(e)}static registerLoadRouter(e){He.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return He.getHandlers(e,"save")}static getLoadHandlers(e,t){return He.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?He.getInstance().loadRouters:He.getInstance().saveRouters).forEach(i=>{const a=i(e,s);a!==null&&r.push(a)}),r}}const Sw=n=>He.registerSaveRouter(n),$w=n=>He.registerLoadRouter(n),Iw=n=>He.getSaveHandlers(n),kw=(n,e)=>He.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cu="tensorflowjs",Su=1,Ss="models_store",Kn="model_info_store";function ry(){if(!M().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function $u(n){const e=n.result;e.createObjectStore(Ss,{keyPath:"modelPath"}),e.createObjectStore(Kn,{keyPath:"modelPath"})}class _s{constructor(e){if(this.indexedDB=ry(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(Cu,Su);o.onupgradeneeded=()=>$u(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(Ss,"readonly"),l=a.objectStore(Ss).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=c=>(i.close(),r(l.error)),a.oncomplete=()=>i.close()}else{t.weightData=dn.join(t.weightData);const a=$o(t),u=i.transaction(Kn,"readwrite");let l=u.objectStore(Kn),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(h){return r(h)}let d;c.onsuccess=()=>{d=i.transaction(Ss,"readwrite");const h=d.objectStore(Ss);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{l=u.objectStore(Kn);const g=l.delete(this.modelPath);g.onsuccess=()=>(i.close(),r(p.error)),g.onerror=y=>(i.close(),r(p.error))}},c.onerror=h=>(i.close(),r(c.error)),u.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},o.onerror=i=>r(o.error)})}}_s.URL_SCHEME="indexeddb://";const oy=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(_s.URL_SCHEME)?Nw(n.slice(_s.URL_SCHEME.length)):null;He.registerSaveRouter(oy);He.registerLoadRouter(oy);function Nw(n){return new _s(n)}function Tw(n){return n.startsWith(_s.URL_SCHEME)?n.slice(_s.URL_SCHEME.length):n}class Ew{constructor(){this.indexedDB=ry()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Cu,Su);s.onupgradeneeded=()=>$u(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Kn,"readonly"),a=o.objectStore(Kn).getAll();a.onsuccess=()=>{const u={};for(const l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(r.close(),t(a.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=Tw(e),new Promise((t,s)=>{const r=this.indexedDB.open(Cu,Su);r.onupgradeneeded=()=>$u(r),r.onsuccess=()=>{const o=r.result,i=o.transaction(Kn,"readwrite"),a=i.objectStore(Kn),u=a.get(e);let l;u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),d=()=>{l=o.transaction(Ss,"readwrite");const p=l.objectStore(Ss).delete(e);p.onsuccess=()=>t(u.result.modelArtifactsInfo),p.onerror=f=>s(u.error)};c.onsuccess=d,c.onerror=h=>(d(),o.close(),s(u.error))}},u.onerror=c=>(o.close(),s(u.error)),i.oncomplete=()=>{l==null?o.close():l.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const En="/",nr="tensorflowjs_models",iy="info",Rw="model_topology",_w="weight_specs",Aw="weight_data",Pw="model_metadata";function ay(n){return{info:[nr,n,iy].join(En),topology:[nr,n,Rw].join(En),weightSpecs:[nr,n,_w].join(En),weightData:[nr,n,Aw].join(En),modelMetadata:[nr,n,Pw].join(En)}}function uy(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Dw(n){const e=n.split(En);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(En)}function Ow(n){return n.startsWith(As.URL_SCHEME)?n.slice(As.URL_SCHEME.length):n}class As{constructor(e){if(!M().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ay(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=$o(e),o=dn.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,gw(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw uy(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=yw(i),t}}As.URL_SCHEME="localstorage://";const ly=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(As.URL_SCHEME)?Fw(n.slice(As.URL_SCHEME.length)):null;He.registerSaveRouter(ly);He.registerLoadRouter(ly);function Fw(n){return new As(n)}class Lw{constructor(){T(M().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),T(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=nr+En,s=En+iy;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const i=Dw(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=Ow(e);const t=ay(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return uy(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const or="://";class mt{constructor(){this.managers={}}static getInstance(){return mt.instance==null&&(mt.instance=new mt),mt.instance}static registerManager(e,t){T(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(or)&&(e=e.slice(0,e.indexOf(or))),T(e.length>0,()=>"scheme must not be an empty string.");const s=mt.getInstance();T(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=mt.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(mt.getInstance().managers)}}function ai(n){if(n.indexOf(or)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${mt.getSchemes().join(",")}`);return{scheme:n.split(or)[0],path:n.split(or)[1]}}async function cy(n,e,t=!1){T(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=He.getLoadHandlers(n);T(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),T(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=He.getSaveHandlers(e);T(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),T(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=o[0],a=ai(n).scheme,u=ai(n).path,l=a===ai(n).scheme,c=await r.load();t&&l&&await mt.getManager(a).removeModel(u);const d=await i.save(c);return t&&!l&&await mt.getManager(a).removeModel(u),d.modelArtifactsInfo}async function Bw(){const n=mt.getSchemes(),e={};for(const t of n){const s=await mt.getManager(t).listModels();for(const r in s){const o=t+or+r;e[o]=s[r]}}return e}async function zw(n){const e=ai(n);return mt.getManager(e.scheme).removeModel(e.path)}async function Vw(n,e){return cy(n,e,!1)}async function Mw(n,e){return cy(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ww{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!M().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Fg(e)}}if(M().get("IS_BROWSER")){M().setPlatform("browser",new Ww);try{mt.registerManager(As.URL_SCHEME,new Lw)}catch{}try{mt.registerManager(_s.URL_SCHEME,new Ew)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uw={importFetch:()=>require("node-fetch")};let Ga;class Gw{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return M().global.fetch!=null?M().global.fetch(e,t):(Ga==null&&(Ga=Uw.importFetch()),Ga(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}M().get("IS_NODE")&&!M().get("IS_BROWSER")&&M().setPlatform("node",new Gw);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(n,e="float32",t){return e=e||"float32",Wt(n),new lr(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e){const t=N(n,"x","cast");if(!N1(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return z.runKernel(Ui,s,r)}const ze=B({cast_:Hw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){const t={x:N(n,"x","clone","string_or_numeric")};return z.runKernel(Gi,t)}const Zn=B({clone_:jw});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dy(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Kg();const Kw={buffer:Pe,cast:ze,clone:Zn,print:dy};sw(Kw);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n,e){let t=N(n,"a","add"),s=N(e,"b","add");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(Wi,r)}const ue=B({add_:Xw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n,e){let t=N(n,"a","floorDiv"),s=N(e,"b","floorDiv");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(ac,r)}const hy=B({floorDiv_:qw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yw(n,e){let t=N(n,"a","div"),s=N(e,"b","div");if([t,s]=qe(t,s),t.dtype==="int32"&&s.dtype==="int32")return hy(t,s);const r={a:t,b:s},o={};return z.runKernel(ql,r,o)}const Se=B({div_:Yw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n,e){let t=N(n,"a","mul"),s=N(e,"b","mul");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(zc,r)}const Y=B({mul_:Qw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw(n){const e=N(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return z.runKernel(Rl,t)}else{const t={x:e};return z.runKernel(ul,t)}}const Bt=B({abs_:Zw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n){const t={x:N(n,"x","acos")};return z.runKernel(ll,t)}const ev=B({acos_:Jw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tv(n){const t={x:N(n,"x","acosh")};return z.runKernel(cl,t)}const nv=B({acosh_:tv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(n){T(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),T(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>N(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Ae(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return z.runKernel(dl,s)}const rv=B({addN_:sv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ov(n,e=null,t=!1){const r={x:N(n,"x","all","bool")},o={axis:e,keepDims:t};return z.runKernel(hl,r,o)}const iv=B({all_:ov});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n,e=null,t=!1){const r={x:N(n,"x","any","bool")},o={axis:e,keepDims:t};return z.runKernel(pl,r,o)}const uv=B({any_:av});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lv(n,e=0){const s={x:N(n,"x","argMax")},r={axis:e};return z.runKernel(fl,s,r)}const py=B({argMax_:lv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cv(n,e=0){const s={x:N(n,"x","argMin")},r={axis:e};return z.runKernel(ml,s,r)}const dv=B({argMin_:cv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(n){const t={x:N(n,"x","asin")};return z.runKernel(gl,t)}const pv=B({asin_:hv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n){const t={x:N(n,"x","asinh")};return z.runKernel(yl,t)}const mv=B({asinh_:fv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n){const t={x:N(n,"x","atan")};return z.runKernel(xl,t)}const yv=B({atan_:gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n,e){let t=N(n,"a","atan2"),s=N(e,"b","atan2");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(wl,r)}const bv=B({atan2_:xv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wv(n){const t={x:N(n,"x","atanh")};return z.runKernel(bl,t)}const vv=B({atanh_:wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(n,e,t,s,r="NHWC",o){const i=n[3],a=[...e,i],u=hn(r);return Ze(n,a,t,o,s,null,null,u)}function Jt(n,e,t,s,r,o,i="channelsLast"){const[a,u]=oo(e);let l;if(i==="channelsLast")l=[a,u,n[3],n[3]];else if(i==="channelsFirst")l=[a,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Ze(n,l,t,s,r,o,!1,i)}function Vn(n,e,t,s,r,o,i="NDHWC"){const[a,u,l]=Iu(e);let c,d;if(i==="NDHWC")d="channelsLast",c=[a,u,l,n[4],n[4]];else if(i==="NCDHW")d="channelsFirst",c=[a,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return as(n,c,t,s,r,!1,d,o)}function Ze(n,e,t,s,r,o,i=!1,a="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,d]=n;else if(a==="channelsFirst")[u,d,l,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[h,p,,f]=e,[g,y]=oo(t),[x,w]=oo(s),$=ir(h,x),S=ir(p,w),{padInfo:E,outHeight:P,outWidth:F}=$v(r,l,c,g,y,$,S,o,a),L=i?f*d:f;let R;return a==="channelsFirst"?R=[u,L,P,F]:a==="channelsLast"&&(R=[u,P,F,L]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:d,outHeight:P,outWidth:F,outChannels:L,padInfo:E,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:p,effectiveFilterHeight:$,effectiveFilterWidth:S,dilationHeight:x,dilationWidth:w,inShape:n,outShape:R,filterShape:e}}function as(n,e,t,s,r,o=!1,i="channelsLast",a){let[u,l,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,d,h]=n;else if(i==="channelsFirst")[u,h,l,c,d]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,g,,y]=e,[x,w,$]=Iu(t),[S,E,P]=Iu(s),F=ir(p,S),L=ir(f,E),R=ir(g,P),{padInfo:A,outDepth:k,outHeight:W,outWidth:G}=Iv(r,l,c,d,x,w,$,F,L,R,a),K=o?y*h:y;let X;return i==="channelsFirst"?X=[u,K,k,W,G]:i==="channelsLast"&&(X=[u,k,W,G,K]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:d,inChannels:h,outDepth:k,outHeight:W,outWidth:G,outChannels:K,padInfo:A,strideDepth:x,strideHeight:w,strideWidth:$,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:F,effectiveFilterHeight:L,effectiveFilterWidth:R,dilationDepth:S,dilationHeight:E,dilationWidth:P,inShape:n,outShape:X,filterShape:e}}function Cv(n,e,t,s,r){s==null&&(s=Wd(n,e,t));const o=n[0],i=n[1],a=io((o-e+2*s)/t+1,r),u=io((i-e+2*s)/t+1,r);return[a,u]}function Sv(n,e,t,s,r,o){r==null&&(r=Wd(n,e[0],s[0]));const i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(i[a]=io((n[a]-e[a]+2*r)/s[a]+1,o));return i}function Wd(n,e,t,s=1){const r=ir(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function oo(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Iu(n){return typeof n=="number"?[n,n,n]:n}function ir(n,e){return e<=1?n:n+(n-1)*(e-1)}function $v(n,e,t,s,r,o,i,a,u){let l,c,d;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Cv([e,t],o,s,n,a);c=p[0],d=p[1]}else if(n==="same"){c=Math.ceil(e/s),d=Math.ceil(t/r);const h=Math.max(0,(c-1)*s+o-e),p=Math.max(0,(d-1)*r+i-t),f=Math.floor(h/2),g=h-f,y=Math.floor(p/2),x=p-y;l={top:f,bottom:g,left:y,right:x,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),d=Math.ceil((t-i+1)/r);else if(typeof n=="object"){const h=u==="channelsLast"?n[1][0]:n[2][0],p=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],g=u==="channelsLast"?n[2][1]:n[3][1];l={top:h,bottom:p,left:f,right:g,type:h===0&&p===0&&f===0&&g===0?"VALID":"EXPLICIT"},c=io((e-o+h+p)/s+1,a),d=io((t-i+f+g)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:c,outWidth:d}}function Iv(n,e,t,s,r,o,i,a,u,l,c){let d,h,p,f;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=Sv([e,t,s,1],[a,u,l],1,[r,o,i],n,c);h=y[0],p=y[1],f=y[2]}else if(n==="same"){h=Math.ceil(e/r),p=Math.ceil(t/o),f=Math.ceil(s/i);const g=(h-1)*r+a-e,y=(p-1)*o+u-t,x=(f-1)*i+l-s,w=Math.floor(g/2),$=g-w,S=Math.floor(y/2),E=y-S,P=Math.floor(x/2),F=x-P;d={top:S,bottom:E,left:P,right:F,front:w,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function io(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ao(n){const[e,t,s]=oo(n);return e===1&&t===1&&s===1}function bt(n,e){return ao(n)||ao(e)}function Ps(n){return oo(n).every(e=>e>0)}function hn(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function en(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")T(ur(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{T(ur(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n,e){const s={x:N(n,"x","reshape","string_or_numeric")},r={shape:e};return z.runKernel(td,s,r)}const j=B({reshape_:kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nv(n,e,t,s,r){const o=N(n,"x","avgPool","float32"),i=1;T(bt(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,u=!1;o.rank===3&&(u=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),T(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),en("avgPool",s,r);const l={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let d=z.runKernel(vl,l,c);return d=ze(d,o.dtype),u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const fy=B({avgPool_:Nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tv(n,e,t,s,r,o="NDHWC"){const i=N(n,"x","avgPool3d","float32");let a=i,u=!1;i.rank===4&&(u=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),T(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),T(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),T(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),en("avgPool3d",s,r);const l={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let d=z.runKernel(Cl,l,c);return d=ze(d,a.dtype),u?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Ev=B({avgPool3d_:Tv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n,e=0){T(n.length>=1,()=>"Pass at least one tensor to concat");const t=Ni(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return Zn(t[0]);const s=t,r={axis:e};return z.runKernel(_l,s,r)}const nt=B({concat_:Rv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _v(n,e,t=!1,s=!1){let r=N(n,"a","matMul"),o=N(e,"b","matMul");[r,o]=qe(r,o);const i={a:r,b:o},a={transposeA:t,transposeB:s};return z.runKernel(Sl,i,a)}const Fe=B({matMul_:_v});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n){const t={x:N(n,"x","sigmoid","float32")};return z.runKernel(yd,t)}const Rn=B({sigmoid_:Av});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n,e,t){const s=N(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return z.runKernel(pd,r,o)}const we=B({slice_:Pv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(n){const t={x:N(n,"x","tanh","float32")};return z.runKernel(Ad,t)}const ku=B({tanh_:Dv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e,t,s,r,o){const i=N(n,"forgetBias","basicLSTMCell"),a=N(e,"lstmKernel","basicLSTMCell"),u=N(t,"lstmBias","basicLSTMCell"),l=N(s,"data","basicLSTMCell"),c=N(r,"c","basicLSTMCell"),d=N(o,"h","basicLSTMCell"),h=nt([l,d],1),p=Fe(h,a),f=ue(p,u),g=f.shape[0],y=f.shape[1]/4,x=[g,y],w=we(f,[0,0],x),$=we(f,[0,y],x),S=we(f,[0,y*2],x),E=we(f,[0,y*3],x),P=ue(Y(Rn(w),ku($)),Y(c,Rn(ue(i,S)))),F=Y(ku(P),Rn(E));return[P,F]}const Fv=B({basicLSTMCell_:Ov});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(n,e,t){const s=N(n,"x","batchToSpaceND"),r=e.reduce((a,u)=>a*u);T(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),T(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),T(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},i={blockShape:e,crops:t};return z.runKernel($l,o,i)}const my=B({batchToSpaceND_:Lv});function Bv(n){let e;return n.rank===0||n.rank===1?e=j(n,[1,1,1,n.size]):n.rank===2?e=j(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n,e,t,s,r,o){o==null&&(o=.001);const i=N(n,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let c;s!=null&&(c=N(s,"offset","batchNorm")),T(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),T(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),T(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:Bv(i),scale:l,offset:c,mean:a,variance:u},p={varianceEpsilon:o},f=z.runKernel(uc,h,p);return j(f,i.shape)}const qi=B({batchNorm_:zv});function Vv(n,e,t,s,r,o){const i=N(n,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let c;return s!=null&&(c=N(s,"offset","batchNorm")),T(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),T(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),T(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&T(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&T(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),qi(i,a,u,c,l,o)}const Mv=B({batchNorm2d_:Vv});function Wv(n,e,t,s,r,o){const i=N(n,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let c;return s!=null&&(c=N(s,"offset","batchNorm")),T(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),T(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),T(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&T(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&T(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),qi(i,a,u,c,l,o)}const Uv=B({batchNorm3d_:Wv});function Gv(n,e,t,s,r,o){const i=N(n,"x","batchNorm"),a=N(e,"mean","batchNorm"),u=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let c;return s!=null&&(c=N(s,"offset","batchNorm")),T(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),T(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),T(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&T(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&T(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),qi(i,a,u,c,l,o)}const Hv=B({batchNorm4d_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e,t){const s=N(n,"x","bincount"),r=N(e,"weights","bincount");T(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),T(t>=0,()=>`size must be non-negative, but got ${t}.`),T(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},i={size:t};return z.runKernel(Il,o,i)}const gy=B({bincount_:jv});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,e){const t=N(n,"x","bitwiseAnd"),s=N(e,"y","bitwiseAnd");if(!Ae(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return z.runKernel(fg,r)}const Xv=B({bitwiseAnd_:Kv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n,e){const t=N(n,"s0","broadcastArgs","int32"),s=N(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return z.runKernel(kl,r)}const Yv=B({broadcastArgs_:qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n,e){let t=N(n,"broadcastTo","x");const s=t.shape;if(Wt(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=j(t,l)}const r=t.shape,o=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])o[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Zn(t);const a={x:t},u={reps:o};return z.runKernel(Hi,a,u)}const to=B({broadcastTo_:Qv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zv(n){const t={x:N(n,"x","ceil","float32")};return z.runKernel(Nl,t)}const Jv=B({ceil_:Zv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ko(n,e,t){Wt(n),t=t||br(e);const s={shape:n,value:e,dtype:t};return z.runKernel(rc,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n,e,t){const s=N(n,"x","clipByValue");if(T(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return ko(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return z.runKernel(Tl,r,o)}const yy=B({clipByValue_:e2});function t2(n){return nt(n,0)}const n2=B({concat1d_:t2});function s2(n,e){return nt(n,e)}const r2=B({concat2d_:s2});function o2(n,e){return nt(n,e)}const i2=B({concat3d_:o2});function a2(n,e){return nt(n,e)}const u2=B({concat4d_:a2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n,e,t,s,r="NHWC",o=[1,1],i){const a=N(n,"x","conv2d","float32"),u=N(e,"filter","conv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),T(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),T(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),en("conv2d",s,i);const d=r==="NHWC"?l.shape[3]:l.shape[1];T(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),T(bt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),T(Ps(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),T(Ps(t),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:l,filter:u},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=z.runKernel(Al,h,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Yi=B({conv2d_:l2});function c2(n,e,t,s,r="NWC",o=1,i){const a=N(n,"x","conv1d"),u=N(e,"filter","conv1d");let l=a,c=!1;a.rank===2&&(c=!0,l=j(a,[1,a.shape[0],a.shape[1]])),T(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),T(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),en("conv1d",s,i),T(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),T(bt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),T(Ps(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),T(Ps(t),()=>"Error in conv1D: Stride should be larger than 0."),T(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=j(u,[1,u.shape[0],u.shape[1],u.shape[2]]),h=j(l,[l.shape[0],1,l.shape[1],l.shape[2]]),y=Yi(h,d,[1,t],s,"NHWC",[1,o],i);return c?j(y,[y.shape[2],y.shape[3]]):j(y,[y.shape[0],y.shape[2],y.shape[3]])}const d2=B({conv1d_:c2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n,e,t,s,r,o="NHWC",i){T(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,u=e,l=!1;e.rank===3&&(l=!0,u=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),T(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),T(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),T(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?a[3]:a[1],d=o==="NHWC"?u.shape[3]:u.shape[1];T(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),T(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),en("conv2dDerInput",r,i);const h={dy:u,filter:t},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,inputShape:a},f=z.runKernel(Dl,h,p);return l?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const xy=B({conv2DBackpropInput_:h2});function p2(n,e,t,s,r,o){const i=N(n,"x","conv2dTranspose"),a=N(e,"filter","conv2dTranspose");return xy(t,i,a,s,r,"NHWC",o)}const f2=B({conv2dTranspose_:p2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(n,e,t,s,r="NDHWC",o=[1,1,1]){const i=N(n,"x","conv3d"),a=N(e,"filter","conv3d");let u=i,l=!1;i.rank===4&&(l=!0,u=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),T(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),T(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),T(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),T(bt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),T(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),T(Ps(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),T(Ps(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:u,filter:a},d={strides:t,pad:s,dataFormat:r,dilations:o},h=z.runKernel(Ol,c,d);return l?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const g2=B({conv3d_:m2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2(n,e,t,s,r){T(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,i=e,a=!1;e.rank===4&&(a=!0,i=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const u=o[4],l=i.shape[4];T(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),T(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),T(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),T(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),T(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const c={dy:i,filter:t},d={pad:r,strides:s,inputShape:o},h=z.runKernel(Fl,c,d);return a?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const x2=B({conv3DBackpropInput_:y2});function b2(n,e,t,s,r){const o=N(n,"x","conv3dTranspose"),i=N(e,"filter","conv3dTranspose");return x2(t,o,i,s,r)}const w2=B({conv3dTranspose_:b2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n){const t={x:N(n,"x","cos","float32")};return z.runKernel(Ll,t)}const C2=B({cos_:v2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(n){const t={x:N(n,"x","cosh","float32")};return z.runKernel(Bl,t)}const $2=B({cosh_:S2});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2(n,e=0,t=!1,s=!1){const o={x:N(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:s};return z.runKernel(zl,o,i)}const k2=B({cumprod_:I2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2(n,e=0,t=!1,s=!1){const o={x:N(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:s};return z.runKernel(Vl,o,i)}const T2=B({cumsum_:N2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2(n,e,t,s=!1){const r=N(n,"x","denseBincount"),o=N(e,"weights","denseBincount");T(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),T(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),T(t>=0,()=>`size must be non-negative, but got ${t}.`),T(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const i={x:r,weights:o},a={size:t,binaryOutput:s};return z.runKernel(Wl,i,a)}const R2=B({denseBincount_:E2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2(n,e,t="NHWC"){const s=N(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],i=t==="NHWC"?s.shape[3]:s.shape[1];T(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),T(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),T(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),T(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const a={x:s},u={blockSize:e,dataFormat:t};return z.runKernel(Ul,a,u)}const A2=B({depthToSpace_:_2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,e,t,s,r="NHWC",o=[1,1],i){const a=N(n,"x","depthwiseConv2d","float32"),u=N(e,"filter","depthwiseConv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),T(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),T(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const d=r==="NHWC"?l.shape[3]:l.shape[1];T(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),en("depthwiseConv2d",s,i);const h={x:l,filter:u},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},f=z.runKernel(Gl,h,p);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ud=B({depthwiseConv2d_:P2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D2(n){const t={x:N(n,"x","diag")};return z.runKernel(Kl,t)}const O2=B({diag_:D2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n,e,t,s,r=[1,1],o="NHWC"){const i=N(n,"x","dilation2d"),a=N(e,"filter","dilation2d");T(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),T(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),T(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;i.rank===3&&(u=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),T(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const c={x:u,filter:a},d={strides:t,pad:s,dilations:r},h=z.runKernel(Xl,c,d);return l?j(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const L2=B({dilation2d_:F2});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,i=n[o]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(o)}return s}function by(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,i=e[o];(r==null||r===1&&i>1)&&t.unshift(o)}return t}function be(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let i=e[e.length-r-1];if(i==null&&(i=1),o===1)s[t-r-1]=i;else if(i===1)s[t-r-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2(n,e){let t=N(n,"a","equal","string_or_numeric"),s=N(e,"b","equal","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Jl,r)}const wy=B({equal_:B2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n,e,t){const s=N(e,"a","where"),r=N(t,"b","where"),o=N(n,"condition","where","bool"),i=be(be(o.shape,s.shape),r.shape),a=to(o,i),u=to(s,i),l=to(r,i),c={condition:a,t:u,e:l};return z.runKernel(dd,c)}const Jn=B({where_:z2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2(n){const t={x:N(n,"x","zerosLike")};return z.runKernel(Ld,t)}const Mt=B({zerosLike_:V2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2(n,e){let t=N(n,"a","div"),s=N(e,"b","div");[t,s]=qe(t,s);const r=Se(t,s),o=Mt(r),i=wy(s,o);return Jn(i,o,r)}const W2=B({divNoNan_:M2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2(n,e){const t=N(n,"t1","dot"),s=N(e,"t2","dot");T((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(T(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const i=j(t,[1,-1]),a=j(s,[-1,1]),u=Fe(i,a);return j(u,[])}else if(t.rank===1&&s.rank===2){const i=j(t,[1,-1]),a=j(s,[s.shape[0],s.shape[1]]),u=Fe(i,a);return j(u,[u.size])}else if(t.rank===2&&s.rank===1){const i=j(s,[-1,1]),a=Fe(t,i);return j(a,[a.size])}else{const i=j(s,[s.shape[0],s.shape[1]]);return Fe(t,i)}}const G2=B({dot_:U2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n,...e){const t=e.map((r,o)=>N(r,`tensors${o}`,"einsum")),s={equation:n};return z.runKernel(Yl,t,s)}const sr=B({einsum_:H2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j2(n){const t={x:N(n,"x","elu","float32")};return z.runKernel(Ql,t)}const vy=B({elu_:j2});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2(n,e){const t=N(n,"x","ensureShape","string_or_numeric");if(!I1(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const X2=B({ensureShape_:K2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n){let e=N(n,"x","erf");T(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ze(e,"float32"));const t={x:e};return z.runKernel(Zl,t)}const Y2=B({erf_:q2});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gd(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Cy(n,e,t){const s=n.length+e.length,r=[];let o=0,i=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[o++]):r.push(e[i++]);return r}function Ut(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function Ft(n,e){const t=e.map(s=>1);return Cy(n,t,e)}function Lt(n,e,t){T(Gd(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function dt(n,e){if(Gd(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function No(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ht(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2(n,e=null,t=!1){const r={x:N(n,"x","max")},o={reductionIndices:e,keepDims:t};return z.runKernel(Tc,r,o)}const ar=B({max_:Q2});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2(n,e=null,t=!1){const r={x:N(n,"x","min")},o={axis:e,keepDims:t};return z.runKernel(Dc,r,o)}const Nu=B({min_:Z2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2(n,e){let t=N(n,"base","pow"),s=N(e,"exp","pow");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(Xc,r)}const uo=B({pow_:J2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ve(n,e){if((Qt(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Qt(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return is(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eC(n){const t={x:N(n,"x","sqrt","float32")};return z.runKernel(bd,t)}const On=B({sqrt_:eC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(n){const e=N(n,"x","square"),t={};return z.runKernel("Square",{x:e},t)}const qt=B({square_:tC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nC(n,e=null,t=!1){let s=N(n,"x","sum");s.dtype==="bool"&&(s=ze(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return z.runKernel(wd,r,o)}const We=B({sum_:nC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sC(n,e="euclidean",t=null,s=!1){n=N(n,"x","norm");const r=Sy(n,e,t);let o=r.shape;if(s){const i=Ue(t,n.shape);o=Ft(r.shape,i)}return j(r,o)}function Sy(n,e,t=null){if(n.rank===0)return Bt(n);if(n.rank!==1&&t===null)return Sy(j(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return We(Bt(n),t);if(e===1/0)return ar(Bt(n),t);if(e===-1/0)return Nu(Bt(n),t);if(e==="euclidean"||e===2)return On(We(uo(Bt(n),ve(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return ar(We(Bt(n),t[0]),t[1]-1);if(e===1/0)return ar(We(Bt(n),t[1]),t[0]);if(e===-1/0)return Nu(We(Bt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return On(We(qt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Qi=B({norm_:sC});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(n,e=null,t=!1){return Qi(n,"euclidean",e,t)}const oC=B({euclideanNorm_:rC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iC(n){const t={x:N(n,"x","exp")};return z.runKernel(ec,t)}const Fn=B({exp_:iC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(n,e=0){const t=N(n,"x","expandDims","string_or_numeric");T(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return z.runKernel(tc,s,r)}const zt=B({expandDims_:aC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uC(n){const t={x:N(n,"x","expm1")};return z.runKernel(nc,t)}const lC=B({expm1_:uC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(n,e){const t=N(n,"x","tile","string_or_numeric");T(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return z.runKernel(Hi,s,r)}const no=B({tile_:cC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n,e,t,s="float32"){e==null&&(e=n);const r=Pe([n,e],s),o=n<=e?n:e;for(let a=0;a<o;++a)r.set(1,a,a);const i=j(r.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return no(zt(i,0),[t[0],1,1]);if(t.length===2)return no(zt(zt(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return no(zt(zt(zt(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const $y=B({eye_:dC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(n){const t={x:N(n,"x","floor","float32")};return z.runKernel(ic,t)}const Iy=B({floor_:hC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pC(n,e,t=0,s=0){const r=N(n,"x","gather"),o=N(e,"indices","gather","int32"),i={x:r,indices:o},a={axis:t,batchDims:s};return z.runKernel(lc,i,a)}const ky=B({gather_:pC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fC(n,e){let t=N(n,"a","greater","string_or_numeric"),s=N(e,"b","greater","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(dc,r)}const Zi=B({greater_:fC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n,e){let t=N(n,"a","greaterEqual","string_or_numeric"),s=N(e,"b","greaterEqual","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(hc,r)}const Ny=B({greaterEqual_:mC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gC(n){const t={input:N(n,"input","imag")};return z.runKernel(fc,t)}const Ji=B({imag_:gC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yC(n){const t={x:N(n,"x","isFinite")};return z.runKernel(mc,t)}const xC=B({isFinite_:yC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bC(n){const t={x:N(n,"x","isInf")};return z.runKernel(gc,t)}const wC=B({isInf_:bC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vC(n){const t={x:N(n,"x","isNaN")};return z.runKernel(yc,t)}const CC=B({isNaN_:vC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SC(n,e=.2){const s={x:N(n,"x","leakyRelu")},r={alpha:e};return z.runKernel(xc,s,r)}const Ty=B({leakyRelu_:SC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(n,e){let t=N(n,"a","less","string_or_numeric"),s=N(e,"b","less","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(bc,r)}const Tu=B({less_:$C});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IC(n,e){let t=N(n,"a","lessEqual","string_or_numeric"),s=N(e,"b","lessEqual","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(wc,r)}const Hd=B({lessEqual_:IC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kC(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return z.runKernel(vc,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NC(n,e=5,t=1,s=1,r=.5){const o=N(n,"x","localResponseNormalization");T(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),T(ur(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=j(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},l={depthRadius:e,bias:t,alpha:s,beta:r},c=z.runKernel(Nc,u,l);return a?j(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const TC=B({localResponseNormalization_:NC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EC(n){const t={x:N(n,"x","log","float32")};return z.runKernel(Cc,t)}const lo=B({log_:EC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(n){const t={x:N(n,"x","log1p")};return z.runKernel(Sc,t)}const Ey=B({log1p_:RC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _C(n,e){T(hu(n),()=>"The f passed in variableGrads(f) must be a function"),T(e==null||Array.isArray(e)&&e.every(l=>l instanceof ki),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in z.registeredVariables)e.push(z.registeredVariables[l])}const s=t?e.filter(l=>!l.trainable):null,r=e.length;e=e.filter(l=>l.trainable),T(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:i,grads:a}=z.gradients(n,e,null,o);T(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),T(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return e.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),s!=null&&s.forEach(l=>u[l.name]=null),{value:i,grads:u}}function Ln(n){return z.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AC(n){const t={x:N(n,"x","neg")};return z.runKernel(Vc,t)}const vn=B({neg_:AC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PC(n){const t={x:N(n,"x","softplus")};return z.runKernel(xd,t)}const Ry=B({softplus_:PC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DC(n){const e=N(n,"x","logSigmoid");return Ln(s=>({value:vn(Ry(vn(s))),gradFunc:i=>Y(i,Rn(vn(s)))}))(e)}const OC=B({logSigmoid_:DC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(n,e){let t=N(n,"a","sub"),s=N(e,"b","sub");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(Rd,r)}const ye=B({sub_:FC});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LC(n,e=-1){const t=N(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Ln((r,o)=>{const a=ar(r,e,!0),u=ye(r,a),l=ye(ze(u,"float32"),lo(We(Fn(u),e,!0)));return o([l]),{value:l,gradFunc:(d,h)=>{const[p]=h,f=!0,g=Fn(p);return ye(d,Y(We(d,e,f),g))}}})(t)}const BC=B({logSoftmax_:LC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(n,e=null,t=!1){const s=N(n,"x","logSumExp"),r=Ue(e,s.shape),o=ar(s,r,!0),i=ye(s,o),a=Fn(i),u=We(a,r),l=lo(u),c=ue(j(o,l.shape),l);if(t){const d=Ft(c.shape,r);return j(c,d)}return c}const _y=B({logSumExp_:zC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VC(n,e){const t=N(n,"a","logicalAnd","bool"),s=N(e,"b","logicalAnd","bool");be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel($c,r)}const Ti=B({logicalAnd_:VC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MC(n){const t={x:N(n,"x","logicalNot","bool")};return z.runKernel(Ic,t)}const Ay=B({logicalNot_:MC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e){const t=N(n,"a","logicalOr","bool"),s=N(e,"b","logicalOr","bool");be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(kc,r)}const Py=B({logicalOr_:WC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n,e){const t=N(n,"a","logicalXor","bool"),s=N(e,"b","logicalXor","bool");return be(t.shape,s.shape),Ti(Py(n,e),Ay(Ti(n,e)))}const GC=B({logicalXor_:UC});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yo=2147483648;function HC(n,e,t="left"){const s=N(n,"sortedSequence","searchSorted"),r=N(e,"values","searchSorted"),o=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],a=j(s,[-1,o]),u=j(r,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(H(u.shape)>=Yo)throw new Error(`values tensor size must less than ${Yo}`);if(a.shape[1]>=Yo)throw new Error(`trailing dim_size must less than ${Yo} for int32 output type, was ${a.shape[1]}`);const l={sortedSequence:a,values:u},c={side:t};return z.runKernel(cd,l,c)}const jd=B({searchSorted_:HC});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jC(n,e){return jd(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KC(n,e,t,s,r){const o=N(n,"x","maxPool"),i=1;let a=o,u=!1;o.rank===3&&(u=!0,a=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),T(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),T(bt(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),en("maxPool",s,r);const l={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r},d=z.runKernel(Rc,l,c);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Dy=B({maxPool_:KC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC(n,e=[1,1,1],t,s,r,o="NDHWC"){const i=N(n,"x","maxPool3d");let a=i,u=!1;i.rank===4&&(u=!0,a=j(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),T(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),T(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),en("maxPool3d",s,r);const l={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},d=z.runKernel(_c,l,c);return u?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const qC=B({maxPool3d_:XC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YC(n,e,t,s,r=!1){const i={x:N(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=z.runKernel(Ac,i,a);return{result:u[0],indexes:u[1]}}const QC=B({maxPoolWithArgmax_:YC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n,e){let t=N(n,"a","maximum"),s=N(e,"b","maximum");[t,s]=qe(t,s),t.dtype==="bool"&&(t=ze(t,"int32"),s=ze(s,"int32")),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Ec,r)}const Oy=B({maximum_:ZC});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JC(n,e=null,t=!1){const r={x:N(n,"x","mean")},o={axis:e,keepDims:t};return z.runKernel(Pc,r,o)}const Ei=B({mean_:JC});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(n,e="float32"){if(Wt(n),e==="complex64"){const s=Bn(n,"float32"),r=Bn(n,"float32");return es(s,r)}const t=An(H(n),e);return z.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $s(n,e="float32"){if(Wt(n),e==="complex64"){const s=$s(n,"float32"),r=Bn(n,"float32");return es(s,r)}const t=lg(H(n),e);return z.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=N(n,"x","meshgrid",n instanceof Ke?n.dtype:"float32");if(e===void 0)return[s];let r=N(e,"y","meshgrid",e instanceof Ke?e.dtype:"float32");const o=H(s.shape),i=H(r.shape);return t==="xy"?(s=j(s,[1,-1]),r=j(r,[-1,1]),[Fe($s([i,1],s.dtype),s),Fe(r,$s([1,o],r.dtype))]):(s=j(s,[-1,1]),r=j(r,[1,-1]),[Fe(s,$s([1,i],s.dtype)),Fe($s([o,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(n,e){let t=N(n,"a","minimum"),s=N(e,"b","minimum");[t,s]=qe(t,s),t.dtype==="bool"&&(t=ze(t,"int32"),s=ze(s,"int32")),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Oc,r)}const co=B({minimum_:tS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(n,e,t){T(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=N(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");T(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)T(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),T(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},i={x:s};return z.runKernel(Fc,i,o)}const Fy=B({mirrorPad_:nS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(n,e){let t=N(n,"a","mod"),s=N(e,"b","mod");[t,s]=qe(t,s);const r={a:t,b:s};return z.runKernel(Lc,r)}const rS=B({mod_:sS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(n,e=null,t=!1){n=N(n,"x","moments");const s=Ue(e,n.shape),r=Ei(n,s,t);let o=r.shape;t||(o=Ft(r.shape,s));const i=qt(ye(ze(n,"float32"),j(r,o))),a=Ei(i,s,t);return{mean:r,variance:a}}const iS=B({moments_:oS});function aS(n,e,t,s){const r=N(e,"data","multiRNNCell"),o=Ni(t,"c","multiRNNCell"),i=Ni(s,"h","multiRNNCell");let a=r;const u=[];for(let d=0;d<n.length;d++){const h=n[d](a,o[d],i[d]);u.push(h[0]),u.push(h[1]),a=h[1]}const l=[],c=[];for(let d=0;d<u.length;d+=2)l.push(u[d]),c.push(u[d+1]);return[l,c]}const uS=B({multiRNNCell_:aS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lS(n,e,t,s=!1){const r=N(n,"logits","multinomial"),o=r.size,i=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const u={logits:i===1?j(r,[1,-1]):r},l={numSamples:e,seed:t,normalized:s},c=z.runKernel(Bc,u,l);return i===1?j(c,[c.size]):c}const cS=B({multinomial_:lS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n,e){let t=N(n,"a","notEqual","string_or_numeric"),s=N(e,"b","notEqual","string_or_numeric");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s};return z.runKernel(Mc,r)}const Ly=B({notEqual_:dS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hS(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:N(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return z.runKernel(Hc,i,a)}const pS=B({oneHot_:hS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(n){const t={x:N(n,"x","onesLike")};return z.runKernel(Gc,t)}const mS=B({onesLike_:fS});function gS(n,e){const t=N(n,"v1","outerProduct"),s=N(e,"v2","outerProduct");T(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=j(t,[-1,1]),o=j(s,[1,-1]);return Fe(r,o)}const yS=B({outerProduct_:gS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xS(n,e,t=0){const s=N(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return z.runKernel(Kc,o,r)}const ns=B({pad_:xS});function bS(n,e,t=0){return T(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),ns(n,[e],t)}const wS=B({pad1d_:bS});function vS(n,e,t=0){return T(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ns(n,e,t)}const CS=B({pad2d_:vS});function SS(n,e,t=0){return T(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ns(n,e,t)}const $S=B({pad3d_:SS});function IS(n,e,t=0){return T(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ns(n,e,t)}const kS=B({pad4d_:IS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n,e,t){const s=N(n,"x","spaceToBatchND");T(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),T(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),T(s.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+t[u-1][0]+t[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return z.runKernel(vd,r,o)}const By=B({spaceToBatchND_:NS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TS(n,e,t,s,r,o,i){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const a=N(n,"x","maxPool");let u=a,l=!1;a.rank===3&&(l=!0,u=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),T(bt(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=Jt(u.shape,e,o,r,s),d=[c.dilationHeight,c.dilationWidth];let h;s==="same"?h=RS([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[f,g]=ES([c.inHeight,c.inWidth],d,h),y=p?s:"valid",x=p?u:By(u,d,f),$=(t==="avg"?()=>fy(x,e,o,y,i):()=>Dy(x,e,o,y,i))(),S=p?$:my($,d,g);return l?j(S,[S.shape[1],S.shape[2],S.shape[3]]):S}function ES(n,e,t){const s=t.map(c=>c[0]),r=t.map(c=>c[1]),o=n.concat(s,r),i=e.map((c,d)=>(c-o[d]%c)%c),a=r.map((c,d)=>c+i[d]),u=e.map((c,d)=>[s[d],a[d]]),l=e.map((c,d)=>[0,i[d]]);return[u,l]}function RS(n,e){const s=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),o=s.map((i,a)=>i-r[a]);return s.map((i,a)=>[r[a],o[a]])}const _S=B({pool_:TS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n,e){const t=N(n,"x","prelu"),s=N(e,"alpha","prelu"),r={x:t,alpha:s};return z.runKernel(qc,r)}const zy=B({prelu_:AS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(n,e=null,t=!1){let s=N(n,"x","prod");s.dtype==="bool"&&(s=ze(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return z.runKernel(Yc,r,o)}const DS=B({prod_:PS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n,e,t,s){const r=n.map((c,d)=>N(c,`tensors${d}`,"raggedGather","int32")),o=N(e,"paramsDenseValues","raggedGather"),i=N(t,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:o,indices:i},u={outputRaggedRank:s},l=z.runKernel(Cg,a,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const FS=B({raggedGather_:OS});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n,e,t){const s=N(n,"starts","raggedRange"),r=N(e,"limits","raggedRange",s.dtype),o=N(t,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:o},a=z.runKernel(Sg,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const BS=B({raggedRange_:LS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n,e,t,s,r){const o=N(n,"shape","raggedTensorToTensor","int32"),i=N(e,"values","raggedTensorToTensor"),a=N(t,"defaultValue","raggedTensorToTensor",i.dtype),u=s.map((d,h)=>N(d,`tensors${h}`,"raggedTensorToTensor","int32")),l={shape:o,values:i,defaultValue:a,rowPartitionTensors:u},c={rowPartitionTypes:r};return z.runKernel($g,l,c)}const VS=B({raggedTensorToTensor_:zS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n,e,t){Wt(n);const s=H(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return z.makeTensor(r,n,t)}const WS=B({rand_:MS});var ui={exports:{}},US=ui.exports,uf;function GS(){return uf||(uf=1,function(n){(function(e,t,s){function r(u){var l=this,c=a();l.next=function(){var d=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=d|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function o(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function i(u,l){var c=new r(u),d=l&&l.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&o(d,c),h.state=function(){return o(c,{})}),h}function a(){var u=4022871197,l=function(c){c=String(c);for(var d=0;d<c.length;d++){u+=c.charCodeAt(d);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=i:this.alea=i})(US,n)}(ui)),ui.exports}var li={exports:{}},HS=li.exports,lf;function jS(){return lf||(lf=1,function(n){(function(e,t,s){function r(a){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function i(a,u){var l=new r(a),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&o(c,l),d.state=function(){return o(l,{})}),d}t&&t.exports?t.exports=i:this.xor128=i})(HS,n)}(li)),li.exports}var ci={exports:{}},KS=ci.exports,cf;function XS(){return cf||(cf=1,function(n){(function(e,t,s){function r(a){var u=this,l="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function i(a,u){var l=new r(a),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&o(c,l),d.state=function(){return o(l,{})}),d}t&&t.exports?t.exports=i:this.xorwow=i})(KS,n)}(ci)),ci.exports}var di={exports:{}},qS=di.exports,df;function YS(){return df||(df=1,function(n){(function(e,t,s){function r(a){var u=this;u.next=function(){var c=u.x,d=u.i,h,p;return h=c[d],h^=h>>>7,p=h^h<<24,h=c[d+1&7],p^=h^h>>>10,h=c[d+3&7],p^=h^h>>>3,h=c[d+4&7],p^=h^h<<7,h=c[d+7&7],h=h^h<<13,p^=h^h<<9,c[d]=p,u.i=d+1&7,p};function l(c,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],c.x=p,c.i=0,h=256;h>0;--h)c.next()}l(u,a)}function o(a,u){return u.x=a.x.slice(),u.i=a.i,u}function i(a,u){a==null&&(a=+new Date);var l=new r(a),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(c.x&&o(c,l),d.state=function(){return o(l,{})}),d}t&&t.exports?t.exports=i:this.xorshift7=i})(qS,n)}(di)),di.exports}var hi={exports:{}},QS=hi.exports,hf;function ZS(){return hf||(hf=1,function(n){(function(e,t,s){function r(a){var u=this;u.next=function(){var c=u.w,d=u.X,h=u.i,p,f;return u.w=c=c+1640531527|0,f=d[h+34&127],p=d[h=h+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=d[h]=f^p,u.i=h,f+(c^c>>>16)|0};function l(c,d){var h,p,f,g,y,x=[],w=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,w=Math.max(w,d.length)),f=0,g=-32;g<w;++g)d&&(p^=d.charCodeAt((g+32)%d.length)),g===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,g>=0&&(y=y+1640531527|0,h=x[g&127]^=p+y,f=h==0?f+1:0);for(f>=128&&(x[(d&&d.length||0)&127]=-1),f=127,g=4*128;g>0;--g)p=x[f+34&127],h=x[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,x[f]=p^h;c.w=y,c.X=x,c.i=f}l(u,a)}function o(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function i(a,u){a==null&&(a=+new Date);var l=new r(a),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(c.X&&o(c,l),d.state=function(){return o(l,{})}),d}t&&t.exports?t.exports=i:this.xor4096=i})(QS,n)}(hi)),hi.exports}var pi={exports:{}},JS=pi.exports,pf;function e$(){return pf||(pf=1,function(n){(function(e,t,s){function r(a){var u=this,l="";u.next=function(){var d=u.b,h=u.c,p=u.d,f=u.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^f,f=f-d|0,u.b=d=d<<20^d>>>12^h,u.c=h=h-p|0,u.d=p<<16^h>>>16^f,u.a=f-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):l+=a;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function i(a,u){var l=new r(a),c=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var h=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,c&&(typeof c=="object"&&o(c,l),d.state=function(){return o(l,{})}),d}t&&t.exports?t.exports=i:this.tychei=i})(JS,n)}(pi)),pi.exports}var fi={exports:{}};const t$={},n$=Object.freeze(Object.defineProperty({__proto__:null,default:t$},Symbol.toStringTag,{value:"Module"})),s$=w1(n$);var r$=fi.exports,ff;function o$(){return ff||(ff=1,function(n){(function(e,t,s){var r=256,o=6,i=52,a="random",u=s.pow(r,o),l=s.pow(2,i),c=l*2,d=r-1,h;function p(S,E,P){var F=[];E=E==!0?{entropy:!0}:E||{};var L=x(y(E.entropy?[S,$(t)]:S??w(),3),F),R=new f(F),A=function(){for(var k=R.g(o),W=u,G=0;k<l;)k=(k+G)*r,W*=r,G=R.g(1);for(;k>=c;)k/=2,W/=2,G>>>=1;return(k+G)/W};return A.int32=function(){return R.g(4)|0},A.quick=function(){return R.g(4)/4294967296},A.double=A,x($(R.S),t),(E.pass||P||function(k,W,G,K){return K&&(K.S&&g(K,R),k.state=function(){return g(R,{})}),G?(s[a]=k,W):k})(A,L,"global"in E?E.global:this==s,E.state)}function f(S){var E,P=S.length,F=this,L=0,R=F.i=F.j=0,A=F.S=[];for(P||(S=[P++]);L<r;)A[L]=L++;for(L=0;L<r;L++)A[L]=A[R=d&R+S[L%P]+(E=A[L])],A[R]=E;(F.g=function(k){for(var W,G=0,K=F.i,X=F.j,ee=F.S;k--;)W=ee[K=d&K+1],G=G*r+ee[d&(ee[K]=ee[X=d&X+W])+(ee[X]=W)];return F.i=K,F.j=X,G})(r)}function g(S,E){return E.i=S.i,E.j=S.j,E.S=S.S.slice(),E}function y(S,E){var P=[],F=typeof S,L;if(E&&F=="object")for(L in S)try{P.push(y(S[L],E-1))}catch{}return P.length?P:F=="string"?S:S+"\0"}function x(S,E){for(var P=S+"",F,L=0;L<P.length;)E[d&L]=d&(F^=E[d&L]*19)+P.charCodeAt(L++);return $(E)}function w(){try{var S;return h&&(S=h.randomBytes)?S=S(r):(S=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(S)),$(S)}catch{var E=e.navigator,P=E&&E.plugins;return[+new Date,e,P,e.screen,$(t)]}}function $(S){return String.fromCharCode.apply(0,S)}if(x(s.random(),t),n.exports){n.exports=p;try{h=s$}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:r$,[],Math)}(fi)),fi.exports}var Ha,mf;function i$(){if(mf)return Ha;mf=1;var n=GS(),e=jS(),t=XS(),s=YS(),r=ZS(),o=e$(),i=o$();return i.alea=n,i.xor128=e,i.xorwow=t,i.xorshift7=s,i.xor4096=r,i.tychei=o,Ha=i,Ha}var Kd=i$();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xd{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=Kd.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,i;do r=2*this.random()-1,o=2*this.random()-1,i=r*r+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class a${constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=Kd.alea(o.toString()),this.randn=new Xd(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class u${constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Kd.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n,e,t=1,s="float32",r){if(Wt(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new a$(e,t,s,r),i=Pe(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const c$=B({randomGamma_:l$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n,e=0,t=1,s,r){if(Wt(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new Xd(e,t,s,!1,r),i=Pe(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Vy=B({randomNormal_:d$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Vy(n,0,1,e,t)}const p$=B({randomStandardNormal_:h$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n,e=0,t=1,s="float32",r){Wt(n);const o=Pe(n,s),i=new u$(e,t,null,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const qd=B({randomUniform_:f$});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n,e,t,s){return qd(n,e,t,"int32",s)}const g$=B({randomUniformInt_:m$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ho(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return z.runKernel(Qc,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(n){const t={input:N(n,"input","real")};return z.runKernel(Zc,t)}const po=B({real_:y$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(n){const t={x:N(n,"x","reciprocal")};return z.runKernel(Jc,t)}const b$=B({reciprocal_:x$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$(n){const t={x:N(n,"x","relu")};return z.runKernel(ed,t)}const ea=B({relu_:w$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(n){const t={x:N(n,"x","relu6")};return z.runKernel(rd,t)}const My=B({relu6_:v$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$(n,e){const s={x:N(n,"x","reverse")},r={dims:e};return z.runKernel(od,s,r)}const Ds=B({reverse_:C$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(n){const e=N(n,"x","reverse");return T(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ds(e,0)}const $$=B({reverse1d_:S$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n,e){const t=N(n,"x","reverse");return T(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Ds(t,e)}const k$=B({reverse2d_:I$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(n,e){const t=N(n,"x","reverse");return T(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Ds(t,e)}const T$=B({reverse3d_:N$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(n,e){const t=N(n,"x","reverse");return T(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Ds(t,e)}const R$=B({reverse4d_:E$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n){const t={x:N(n,"x","round")};return z.runKernel(id,t)}const Wy=B({round_:_$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(n){const t={x:N(n,"x","rsqrt","float32")};return z.runKernel(ad,t)}const P$=B({rsqrt_:A$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n){const t={x:N(n,"x","selu")};return z.runKernel(hd,t)}const O$=B({selu_:D$});function F$(n,e,t,s,r,o=[1,1],i="NHWC"){const a=N(n,"x","separableConv2d"),u=N(e,"depthwiseFilter","separableConv2d"),l=N(t,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(a.rank===3&&(d=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");T(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),T(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),T(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),T(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),T(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const h=u.shape[2],p=u.shape[3];T(l.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${l.shape[2]}.`);const f=Ud(c,u,s,r,i,o),y=Yi(f,l,1,"valid",i);return d?j(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const L$=B({separableConv2d_:F$});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function B$(n,e){const t=N(n,"x","setdiff1d"),s=N(e,"y","setdiff1d");T(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),T(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),T(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),i=new Set(o);let a=0;for(let c=0;c<r.length;c++)i.has(r[c])||a++;const u=new lr([a],t.dtype),l=new lr([a],"int32");for(let c=0,d=0;c<r.length;c++)i.has(r[c])||(u.values[d]=r[c],l.values[d]=c,d++);return[u.toTensor(),l.toTensor()]}const z$=B$;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n){const t={x:N(n,"x","sign")};return z.runKernel(gd,t)}const M$=B({sign_:V$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n){const t={x:N(n,"x","sin","float32")};return z.runKernel(fd,t)}const U$=B({sin_:W$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n){const t={x:N(n,"x","sinh")};return z.runKernel(md,t)}const H$=B({sinh_:G$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e,t){const s=N(n,"x","slice1d");return T(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),we(s,[e],[t])}const K$=B({slice1d_:j$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n,e,t){const s=N(n,"x","slice2d");return T(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),we(s,e,t)}const q$=B({slice2d_:X$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e,t){const s=N(n,"x","slice3d");return T(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),we(s,e,t)}const Q$=B({slice3d_:Y$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n,e,t){const s=N(n,"x","slice4d");return T(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),we(s,e,t)}const J$=B({slice4d_:Z$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(n,e=-1){const t=N(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return z.runKernel(Sd,s,r)}const tI=B({softmax_:eI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nI(n){T(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return z.runKernel(sc,e)}const Yd=B({fft_:nI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(n){T(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return z.runKernel(pc,e)}const Ri=B({ifft_:sI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=j(n,[t,e]);s=Ri(r)}else{const r=[t,2*(e-1)],o=j(po(n),[t,e]),i=j(Ji(n),[t,e]),a=Ds(we(o,[0,1],[t,e-2]),1),u=Y(Ds(we(i,[0,1],[t,e-2]),1),ve(-1)),l=nt([o,a],1),c=nt([i,u],1),d=j(es(l,c),[r[0],r[1]]);s=Ri(d)}if(s=po(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=j(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const Uy=B({irfft_:rI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n,e,t=0){const r={x:N(n,"x","split")},o={numOrSizeSplits:e,axis:t};return z.runKernel(Cd,r,o)}const fo=B({split_:oI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n,e){T(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,r=we(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,r=nt([n,Bn(f)],n.shape.length-1),t=e}else r=n;const o=Mt(r),i=j(es(r,o),[s,t]),a=Yd(i),u=Math.floor(t/2)+1,l=po(a),c=Ji(a),d=fo(l,[u,t-u],l.shape.length-1),h=fo(c,[u,t-u],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,j(es(d[0],h[0]),p)}const Qd=B({rfft_:iI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n,e){let t=N(n,"a","squaredDifference"),s=N(e,"b","squaredDifference");[t,s]=qe(t,s),be(t.shape,s.shape);const r={a:t,b:s},o={};return z.runKernel(Nd,r,o)}const Gy=B({squaredDifference_:aI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n,e){const t=N(n,"x","squeeze","string_or_numeric");return j(t,rs(t.shape,e).newShape)}const Oe=B({squeeze_:uI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(n,e=0){const t=Ni(n,"tensors","stack","string_or_numeric");T(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&T(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return z.runKernel(jc,s,r)}const zn=B({stack_:lI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cI(n,e=0){const s={x:N(n,"x","step")},r={alpha:e};return z.runKernel(Bd,s,r)}const Hy=B({step_:cI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(n,e,t,s,r=0,o=0,i=0,a=0,u=0){const c={x:N(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return z.runKernel(Td,c,d)}const hI=B({stridedSlice_:dI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(n){const t={x:N(n,"x","tan","float32")};return z.runKernel(_d,t)}const fI=B({tan_:pI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ct(n,e){xr(n);const t=os(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return is(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(n,e,t){if(xr(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=os(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return is(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jy(n,e,t){if(xr(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=os(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return is(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(n,e,t){if(xr(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=os(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return is(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n,e,t){if(xr(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=os(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return is(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(n,e,t){if(xr(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=os(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,is(n,e,s,t)}function Ky(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let i=0;i<r;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-r;++i)if(t.shape[i+r]!==n[i+s])throw new Error(o+` updates.shape[${i+r}] (${t.shape[i+r]}) != shape[${i+r}] (${n[i+r]})`)}function Zd(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Ky(t,e,n)}function Bs(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let i=1;for(let d=r;d<o;++d)i*=t[d];const a=r<1?1:r,u=H(e.shape)/a,l=[...Xe(t.slice(0,r)),1],c=H(t);return{sliceRank:r,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(n,e,t){const s=N(n,"tensor","tensorScatterupdate"),r=N(e,"indices","tensorScatterupdate","int32"),o=N(t,"updates","tensorScatterupdate");if(Zd(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const i={tensor:s,indices:r,updates:o},a={};return z.runKernel(ld,i,a)}const bI=B({tensorScatterUpdate_:xI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(n,e=1,t=!0){const s=N(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},i={k:e,sorted:t},[a,u]=z.runKernel(Pd,o,i);return{values:a,indices:u}}const vI=B({topk_:wI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(n,e=0,t=1,s,r){if(Wt(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Xd(e,t,s,!0,r),i=Pe(n,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const SI=B({truncatedNormal_:CI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $I(n,e=0){const t=N(n,"x","unique","string_or_numeric");T(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,i]=z.runKernel(Pg,s,r);return{values:o,indices:i}}const II=B({unique_:$I});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t){const s=N(n,"x","unsortedSegmentSum"),r=N(e,"segmentIds","unsortedSegmentSum","int32");T(ur(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},i={numSegments:t};return z.runKernel(Fd,o,i)}const NI=B({unsortedSegmentSum_:kI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n,e=0){const t=N(n,"x","unstack","string_or_numeric");T(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return z.runKernel(Od,s,r)}const zs=B({unstack_:TI});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e){return jd(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n,e=!0,t,s){return z.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xy(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=Pe(n,"int32"),r=Pe([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=s.indexToLoc(t[o]),a=o*n.length;r.values.set(i,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _I(n){const e=N(n,"condition","whereAsync","bool"),t=await e.data(),s=Xy(e.shape,t);return n!==e&&e.dispose(),s}const qy=_I;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function AI(n,e,t){const s=N(n,"tensor","boolMask"),r=N(e,"mask","boolMask","bool"),o=t??0,i=r.rank,a=s.shape;T(i>0,()=>"mask cannot be scalar"),Ot(a.slice(o,o+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let g=o;g<o+i;g++)u*=a[g];const l=a.slice(0,o).concat([u],a.slice(o+i)),c=j(s,l),d=j(r,[-1]),h=await qy(d),p=Oe(h,[1]),f=ky(c,p,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}const PI=AI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e,t){const s=N(n,"x","transpose");if(e==null&&(e=s.shape.map((i,a)=>a).reverse()),T(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{T(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?fe(()=>{let i=po(s),a=Ji(s);return i=z.runKernel(eo,{x:i},o),a=z.runKernel(eo,{x:a},o),t&&(a=vn(a)),es(i,a)}):z.runKernel(eo,r,o)}const Eu=B({transpose_:DI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n,e,t,s,r=!0){const o=N(n,"v","movingAverage"),i=N(e,"x","movingAverage"),a=N(t,"decay","movingAverage");ow(o,i),T(Ae(o.shape,i.shape),()=>"Shape mismatch in v and x");const u=ve(1),l=ye(u,a);let c=Y(ye(i,o),l);if(r){T(s!=null,()=>"When using zeroDebias: true, step is required.");const d=N(s,"step","movingAverage");c=Se(c,ye(u,uo(a,d)))}return ue(o,c)}const FI=B({movingAverage_:OI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n,e,t){Wt(t);const s=N(n,"indices","scatterND","int32"),r=N(e,"updates","scatterND");Zd(r,s,t);const o={indices:s,updates:r},i={shape:t};return z.runKernel(ud,o,i)}const BI=B({scatterND_:LI});function zI(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n,e,t,s=0){Wt(t);const r=N(n,"sparseIndices","sparseToDense","int32"),o=N(e,"sparseValues","sparseToDense","string_or_numeric"),i=N(s,"defaultValue","sparseToDense",o.dtype);zI(r,o,t,i);const a={sparseIndices:r,sparseValues:o,defaultValue:i},u={outputShape:t};return z.runKernel(kd,a,u)}const MI=B({sparseToDense_:VI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n,e){const t=N(e,"indices","gatherND","int32"),r={params:N(n,"x","gatherND","string_or_numeric"),indices:t};return z.runKernel(cc,r)}const UI=B({gatherND_:WI});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GI(n,e){if(e==null)return n.shape.slice();if(Ae(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(n,e,t,s){const r=N(n,"x","dropout");if(T(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),T(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Ke?r.clone():r;const o=GI(r,t),i=1-e,a=Se(Iy(ue(qd(o,0,1,"float32",s),i)),i);return Y(r,a)}const jI=B({dropout_:HI});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yy(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Jd(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(i)}return ct(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function KI(n,e,t=1){const s=N(n,"predictions","inTopK"),r=N(e,"targets","inTopK");T(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),T(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ot(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];T(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=await s.data(),a=await r.data(),[u,l]=[i.length/o,o],c=Sn("bool",u);for(let d=0;d<u;d++){const h=d*l,p=i.subarray(h,h+l),f=[];for(let g=0;g<p.length;g++)f.push({value:p[g],index:g});f.sort((g,y)=>y.value-g.value),c[d]=0;for(let g=0;g<t;g++)if(f[g].index===a[d]){c[d]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),wn(c,r.shape,"bool")}const XI=KI;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qI(n,e,t,s,r,o="NHWC",i){let a=n;n.rank===3&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=j(e,[1,e.shape[0],e.shape[1],e.shape[2]])),T(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),T(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),T(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=o==="NHWC"?a.shape[3]:a.shape[1],c=o==="NHWC"?u.shape[3]:u.shape[1];T(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),T(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),en("conv2dDerFilter",r,i);const d={x:a,dy:u},h={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,filterShape:t};return z.runKernel(Pl,d,h)}const YI=B({conv2DBackpropFilter_:qI});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Y(n,Hy(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function na(n,e){let t=e;const s=by(n.shape,e.shape);return s.length>0&&(t=We(t,s)),j(t,n.shape)}function sa(n,e,t,s){if(e==="linear")return n;if(e==="relu")return ea(n);if(e==="elu")return vy(n);if(e==="relu6")return My(n);if(e==="prelu")return zy(n,t);if(e==="leakyrelu")return Ty(n,s);if(e==="sigmoid")return Rn(n);throw new Error(`Unknown fused activation ${e}.`)}const ra=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",ra(z.state.gradientDepth,u)===!1){T(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let P=Yi(n,e,t,s,r,o,i);return a!=null&&(P=ue(P,a)),sa(P,u,l,c)}const d=N(n,"x","conv2d","float32"),h=N(e,"filter","conv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=j(d,[1,d.shape[0],d.shape[1],d.shape[2]])),T(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),T(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),en("fused conv2d",s,i);const g=r==="NHWC"?p.shape[3]:p.shape[1];T(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),T(bt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const y=Ze(p.shape,h.shape,t,o,s,i);let x;a!=null&&(x=N(a,"bias","fused conv2d"),[x]=qe(x,d),r==="NHWC"?be(y.outShape,x.shape):(T(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),T(x.shape.length===0||x.shape[0]===y.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let w;if(l!=null){const P=l.shape;if(T(P.length<=1||P.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${P.length}.`),P.length===1)T(P[0]===1||P[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${P}) is not compatible with the number of output channels (${y.outChannels}).`);else if(P.length===3)try{be(P,y.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${P}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(L)}w=N(l,"prelu weights","fused conv2d")}const $=(P,F)=>{T(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[L,R,A,k]=F,W=ta(P,A,u);T(ao(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const G=xy(R.shape,W,L,t,s),K=YI(R,W,L.shape,t,s),X=[G,K];if(k!=null){const ee=na(k,W);X.push(ee)}return X},S={x:p,filter:h,bias:x,preluActivationWeights:w},E={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?Ln((F,L,R)=>{let A=z.runKernel(Ci,S,E);return R([L,F,A]),f&&(A=j(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:$}})(p,h):Ln((F,L,R,A)=>{let k=z.runKernel(Ci,S,E);return A([L,F,k,R]),f&&(k=j(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:$}})(p,h,x)}const ZI=B({fusedConv2d_:QI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JI(n,e,t,s,r,o=[1,1],i){let a=n;n.rank===3&&(a=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:a,dy:u},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,filterShape:t};return z.runKernel(Hl,l,c)}const ek=B({depthwiseConv2dNativeBackpropFilter_:JI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(n,e,t,s,r,o=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:a,filter:t},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,inputShape:n},d=z.runKernel(jl,l,c);return u?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const nk=B({depthwiseConv2dNativeBackpropInput_:tk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sk({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(ra(z.state.gradientDepth,u)===!1){let E=Ud(n,e,t,s,r,o,i);return a!=null&&(E=ue(E,a)),sa(E,u,l,c)}const d=N(n,"x","depthwiseConv2d","float32"),h=N(e,"filter","depthwiseConv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=j(d,[1,d.shape[0],d.shape[1],d.shape[2]])),T(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),T(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),T(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),o==null&&(o=[1,1]),T(bt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),en("fused depthwiseConv2d",s,i);const g=Ze(p.shape,h.shape,t,o,s,i,!0);let y;a!=null&&(y=N(a,"bias","fused conv2d"),[y]=qe(y,d),be(g.outShape,y.shape));let x;l!=null&&(x=N(l,"prelu weights","fused depthwiseConv2d"));const w=(E,P)=>{T(ao(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[F,L,R,A]=P,k=ta(E,R,u),W=nk(L.shape,k,F,t,s,o,i),G=ek(L,k,F.shape,t,s,o,i);if(A!=null){const K=na(y,k);return[W,G,K]}return[W,G]},$={x:p,filter:h,bias:y,preluActivationWeights:x},S={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?Ln((P,F,L)=>{let R=z.runKernel(Si,$,S);return L([F,P,R]),f&&(R=j(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:w}})(p,h):Ln((P,F,L,R)=>{let A=z.runKernel(Si,$,S);return R([F,P,A,L]),f&&(A=j(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:w}})(p,h,y)}const rk=B({fusedDepthwiseConv2d_:sk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(ra(z.state.gradientDepth,o)===!1){let k=Fe(n,e,t,s);return r!=null&&(k=ue(k,r)),sa(k,o,i,a)}let u=N(n,"a","fused matMul"),l=N(e,"b","fused matMul");[u,l]=qe(u,l);const c=t?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?l.shape[l.rank-1]:l.shape[l.rank-2],h=t?u.shape[u.rank-1]:u.shape[u.rank-2],p=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),g=l.shape.slice(0,-2),y=H(f),x=H(g);T(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${s} must match.`);const $=be(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([h,p]),S=t?j(u,[y,c,h]):j(u,[y,h,c]),E=s?j(l,[x,p,d]):j(l,[x,d,p]);let P;r!=null&&(P=N(r,"bias","fused matMul"),[P]=qe(P,u),be($,P.shape));let F;i!=null&&(F=N(i,"prelu weights","fused matMul"));const L=(k,W)=>{const[G,K,X,ee]=W,ce=ta(j(k,X.shape),X,o);let de,he;if(!t&&!s?(de=Fe(ce,K,!1,!0),he=Fe(G,ce,!0,!1)):!t&&s?(de=Fe(ce,K,!1,!1),he=Fe(ce,G,!0,!1)):t&&!s?(de=Fe(K,ce,!1,!0),he=Fe(G,ce,!1,!1)):(de=Fe(K,ce,!0,!0),he=Fe(ce,G,!0,!0)),r!=null){const Ce=na(ee,ce);return[de,he,Ce]}else return[de,he]},R={a:S,b:E,bias:P,preluActivationWeights:F},A={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:a};return r==null?Ln((W,G,K)=>{const X=z.runKernel(vi,R,A);return K([W,G,X]),{value:j(X,$),gradFunc:L}})(S,E):Ln((W,G,K,X)=>{const ee=z.runKernel(vi,R,A);return X([W,G,ee,K]),{value:j(ee,$),gradFunc:L}})(S,E,P)}const ik=B({fusedMatMul_:ok});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ak=Object.freeze(Object.defineProperty({__proto__:null,conv2d:ZI,depthwiseConv2d:rk,matMul:ik},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uk(n){return Jd(n,.54,.46)}const lk=B({hammingWindow_:uk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ck(n){return Jd(n,.5,.5)}const Qy=B({hannWindow_:ck});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(n,e,t,s=!1,r=0){let o=0;const i=[];for(;o+e<=n.size;)i.push(we(n,o,e)),o+=t;if(s)for(;o<n.size;){const a=o+e-n.size,u=nt([we(n,o,e-a),ko([a],r)]);i.push(u),o+=t}return i.length===0?Yt([],[0,e]):j(nt(i),[i.length,e])}const Zy=B({frame_:dk});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hk(n,e,t,s,r=Qy){s==null&&(s=Yy(e));const o=Zy(n,e,t),i=Y(o,r(e));return Qd(i,s)}const pk=B({stft_:hk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fk(n,e,t,s,r="bilinear",o=0){const i=N(n,"image","cropAndResize"),a=N(e,"boxes","cropAndResize","float32"),u=N(t,"boxInd","cropAndResize","int32"),l=a.shape[0];T(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),T(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),T(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),T(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),T(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),T(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:a,boxInd:u},d={method:r,extrapolationValue:o,cropSize:s};return z.runKernel(Ml,c,d)}const mk=B({cropAndResize_:fk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const e=N(n,"image","flipLeftRight","float32");T(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return z.runKernel(oc,t,{})}const yk=B({flipLeftRight_:gk});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xk(n){const e=N(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];T(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),T(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,no(e,r)}const bk=B({grayscaleToRGB_:xk});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wk(n){const e=N(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];T(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),T(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=ze(e,"float32"),i=ct([.2989,.587,.114]);let a;switch(e.rank){case 2:a=sr("ij,j->i",o,i);break;case 3:a=sr("ijk,k->ij",o,i);break;case 4:a=sr("ijkl,l->ijk",o,i);break;case 5:a=sr("ijklm,m->ijkl",o,i);break;case 6:a=sr("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=zt(a,-1),ze(a,r)}const vk=B({rgbToGrayscale_:wk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(n,e,t=0,s=.5){const r=N(n,"image","rotateWithOffset","float32");T(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},i={radians:e,fillValue:t,center:s};return z.runKernel(zd,o,i)}const Sk=B({rotateWithOffset_:Ck});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vr(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),T(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),T(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),T(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),T(e.rank===1,()=>"scores must be a 1D tensor"),T(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),T(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=N(n,"boxes","nonMaxSuppression","float32"),i=N(e,"scores","nonMaxSuppression","float32"),a=vr(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return z.runKernel(Wc,{boxes:o,scores:i},u)}const Ik=B({nonMaxSuppression_:$k});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kk(n,e,t){const s=Nk(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function Nk(n,e,t){return Ek(n,e,t||Tk)}function Tk(n,e){return n>e?1:n<e?-1:0}function Ek(n,e,t){let s=0,r=n.length,o=0,i=!1;for(;s<r;){o=s+(r-s>>>1);const a=t(e,n[o]);a>0?s=o+1:(r=o,i=!a)}return i?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eh(n,e,t,s,r){return nh(n,e,t,s,r,0)}function Jy(n,e,t,s,r,o){return nh(n,e,t,s,r,0,!1,o,!0)}function th(n,e,t,s,r,o){return nh(n,e,t,s,r,o,!0)}function nh(n,e,t,s,r,o,i=!1,a=!1,u=!1){const l=[];for(let y=0;y<e.length;y++)e[y]>r&&l.push({score:e[y],boxIndex:y,suppressBeginIndex:0});l.sort(gf);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<t&&l.length>0;){const y=l.pop(),{score:x,boxIndex:w,suppressBeginIndex:$}=y;if(x<r)break;let S=!1;for(let E=d.length-1;E>=$;--E){const P=Rk(n,w,d[E]);if(P>=s){S=!0;break}if(y.score=y.score*_k(s,c,P),y.score<=r)break}y.suppressBeginIndex=d.length,S||(y.score===x?(d.push(w),h.push(y.score)):y.score>r&&kk(l,y,gf))}const p=d.length,f=t-p;a&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=h),u&&(g.validOutputs=p),g}function Rk(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(a-o)*(u-i),f=(d-l)*(h-c);if(p<=0||f<=0)return 0;const g=Math.max(o,l),y=Math.max(i,c),x=Math.min(a,d),w=Math.min(u,h),$=Math.max(x-g,0)*Math.max(w-y,0);return $/(p+f-$)}function _k(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function gf(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ak(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=N(n,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),a=vr(o,i,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:d}=eh(l,c,t,s,r);return o!==n&&o.dispose(),i!==e&&i.dispose(),ct(d,"int32")}const Pk=Ak;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dk(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=N(n,"boxes","nonMaxSuppression"),a=N(e,"scores","nonMaxSuppression"),u=vr(i,a,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const l={boxes:i,scores:a},c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},d=z.runKernel(Uc,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}const Ok=B({nonMaxSuppressionWithScore_:Dk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Fk(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=N(n,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),u=vr(i,a,t,s,r,o);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const l=await Promise.all([i.data(),a.data()]),c=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=th(c,d,t,s,r,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ct(h,"int32"),selectedScores:ct(p)}}const Lk=Fk;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=N(n,"boxes","nonMaxSuppression"),a=N(e,"scores","nonMaxSuppression"),u=vr(i,a,t,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,h={boxes:i,scores:a},p={maxOutputSize:l,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:o},f=z.runKernel(vg,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}const zk=B({nonMaxSuppressionPadded_:Bk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Vk(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=N(n,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),u=vr(i,a,t,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,d=u.scoreThreshold,[h,p]=await Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:g}=Jy(h,p,l,c,d,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ct(f,"int32"),validOutputs:ve(g,"int32")}}const Mk=Vk;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n,e,t=!1,s=!1){const r=N(n,"images","resizeBilinear");T(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),T(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),T(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=j(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},l=z.runKernel(sd,a,u);return i?j(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Uk=B({resizeBilinear_:Wk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gk(n,e,t=!1,s=!1){const r=N(n,"images","resizeNearestNeighbor");T(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),T(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),T(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),T(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=j(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:s,size:e},l=z.runKernel(nd,a,u);return i?j(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Hk=B({resizeNearestNeighbor_:Gk});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jk(n,e="binary",t=!1,s=.5){const r=N(n,"image","threshold"),o=.2989,i=.587,a=.114,u=r.shape[0]*r.shape[1];let l=Y(ct([s]),255),c,d,h,p;if(T(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),T(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),T(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),T(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,d,h]=fo(r,[1,1,1],-1);const y=Y(c,o),x=Y(d,i),w=Y(h,a);p=ue(ue(y,x),w)}else p=n;if(e==="otsu"){const y=gy(ze(Wy(p),"int32"),wn([]),256);l=Kk(y,u)}const f=t?Hd(p,l):Zi(p,l);return ze(Y(f,255),"int32")}function Kk(n,e){let t=ct([-1]),s=ct([0]),r=ct([0]),o,i,a,u,l,c;for(let d=0;d<n.size-1;d++){o=we(n,0,d+1),i=we(n,d+1),l=Se(We(o),e),c=Se(We(i),e);const h=We(Y(o,ho(0,o.size)));a=Se(h,We(o));const p=ko(i.shape,o.size),f=ue(ho(0,i.size),p),g=Y(i,f);u=Se(We(g),We(i));const y=ye(a,u),x=ye(a,u),w=Y(l,c);r=Y(Y(w,y),x);const $=Zi(r,s);s=Jn($,r,s),t=Jn($,ct([d]),t)}return t}const Xk=B({threshold_:jk});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n,e,t="nearest",s="constant",r=0,o){const i=N(n,"image","transform","float32"),a=N(e,"transforms","transform","float32");T(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),T(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),T(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:i,transforms:a},l={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return z.runKernel(Dd,u,l)}const Yk=B({transform_:qk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qk(n,e,t){const s=N(n,"a","bandPart");T(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,i]=s.shape.slice(-2);let a,u;typeof e=="number"?(T(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),T(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=N(e<0?o:e,"numLower","bandPart")):(T(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Jn(Tu(e,0),o,co(e,o))),typeof t=="number"?(T(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),T(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),u=N(t<0?i:t,"numUpper","bandPart")):(T(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Jn(Tu(t,0),i,co(t,i)));const l=j(ho(0,o,1,"int32"),[-1,1]),c=ho(0,i,1,"int32"),d=ye(l,c),h=Ti(Hd(d,a),Ny(d,vn(u))),p=Bn([o,i],s.dtype);return j(zn(zs(j(s,[-1,o,i])).map(f=>Jn(h,f,p))),r)}const Zk=B({bandPart_:Qk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jk(n){let e;if(Array.isArray(n)){e=!1,T(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)T(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=fo(n,n.shape[0],0).map(r=>Oe(r,[0]));T(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(z.tidy(()=>{let o=s[r];if(r>0)for(let i=0;i<r;++i){const a=Y(We(Y(t[i],o)),t[i]);o=ye(o,a)}return Se(o,Qi(o,"euclidean"))}));return e?zn(t,0):t}const eN=B({gramSchmidt_:Jk});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(n,e=!1){if(T(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return yf(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),s=zs(j(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(u=>{const[l,c]=yf(u,e);r.push(l),o.push(c)});const i=j(zn(r,0),n.shape),a=j(zn(o,0),n.shape);return[i,a]}}function yf(n,e=!1){return z.tidy(()=>{T(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=$y(t),o=Zn(n);const i=Yt([[1]],[1,1]);let a=Zn(i);const u=t>=s?s:t;for(let l=0;l<u;++l){const c=o,d=a,h=r;[a,o,r]=z.tidy(()=>{const p=we(o,[l,l],[t-l,1]),f=Qi(p),g=we(o,[l,l],[1,1]),y=Jn(Zi(g,0),Yt([[-1]]),Yt([[1]])),x=ye(g,Y(y,f)),w=Se(p,x);w.shape[0]===1?a=Zn(i):a=nt([i,we(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const $=vn(Se(Fe(y,x),f)),S=we(o,[l,0],[t-l,s]),E=Y($,a),P=Eu(a);if(l===0)o=ye(S,Fe(E,Fe(P,S)));else{const R=ye(S,Fe(E,Fe(P,S)));o=nt([we(o,[0,0],[l,s]),R],0)}const F=Eu(E),L=we(r,[0,l],[t,r.shape[1]-l]);if(l===0)r=ye(L,Fe(Fe(L,a),F));else{const R=ye(L,Fe(Fe(L,a),F));r=nt([we(r,[0,0],[t,l]),R],1)}return[a,o,r]}),_e([c,d,h])}return!e&&t>s&&(r=we(r,[0,0],[t,s]),o=we(o,[0,0],[s,s])),[r,o]})}const nN=B({qr_:tN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ct;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ct||(Ct={}));function sN(n,e,t=Ct.SUM_BY_NONZERO_WEIGHTS){const s=N(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=N(e,"weights","computeWeightedLoss"));const o=r==null?s:Y(s,r);if(t===Ct.NONE)return o;if(t===Ct.SUM)return We(o);if(t===Ct.MEAN){if(r==null)return Ei(o);{const i=s.size/r.size,a=Se(We(o),We(r));return i>1?Se(a,ve(i)):a}}if(t===Ct.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Se(We(o),ve(s.size));{const i=Y(r,$s(s.shape)),a=ze(We(Ly(i,ve(0))),"float32");return Se(We(o),a)}}throw Error(`Unknown reduction: ${t}`)}const Mn=B({computeWeightedLoss_:sN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n,e,t,s=Ct.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","absoluteDifference"),o=N(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=N(t,"weights","absoluteDifference")),Ot(r.shape,o.shape,"Error in absoluteDifference: ");const a=Bt(ye(r,o));return Mn(a,i,s)}const oN=B({absoluteDifference_:rN});function iN(n,e,t,s,r=Ct.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","cosineDistance"),i=N(e,"predictions","cosineDistance");let a=null;s!=null&&(a=N(s,"weights","cosineDistance")),Ot(o.shape,i.shape,"Error in cosineDistance: ");const u=ve(1),l=ye(u,We(Y(o,i),t,!0));return Mn(l,a,r)}const aN=B({cosineDistance_:iN});function uN(n,e,t,s=Ct.SUM_BY_NONZERO_WEIGHTS){let r=N(n,"labels","hingeLoss");const o=N(e,"predictions","hingeLoss");let i=null;t!=null&&(i=N(t,"weights","hingeLoss")),Ot(r.shape,o.shape,"Error in hingeLoss: ");const a=ve(1);r=ye(Y(ve(2),r),a);const u=ea(ye(a,Y(r,o)));return Mn(u,i,s)}const lN=B({hingeLoss_:uN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(n,e,t,s=1,r=Ct.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","huberLoss"),i=N(e,"predictions","huberLoss");let a=null;t!=null&&(a=N(t,"weights","huberLoss")),Ot(o.shape,i.shape,"Error in huberLoss: ");const u=ve(s),l=Bt(ye(i,o)),c=co(l,u),d=ye(l,c),h=ue(Y(ve(.5),qt(c)),Y(u,d));return Mn(h,a,r)}const dN=B({huberLoss_:cN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n,e,t,s=1e-7,r=Ct.SUM_BY_NONZERO_WEIGHTS){const o=N(n,"labels","logLoss"),i=N(e,"predictions","logLoss");let a=null;t!=null&&(a=N(t,"weights","logLoss")),Ot(o.shape,i.shape,"Error in logLoss: ");const u=ve(1),l=ve(s),c=vn(Y(o,lo(ue(i,l)))),d=Y(ye(u,o),lo(ue(ye(u,i),l))),h=ye(c,d);return Mn(h,a,r)}const pN=B({logLoss_:hN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n,e,t,s=Ct.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","meanSquaredError"),o=N(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=N(t,"weights","meanSquaredError")),Ot(r.shape,o.shape,"Error in meanSquaredError: ");const a=Gy(r,o);return Mn(a,i,s)}const mN=B({meanSquaredError_:fN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(n,e){const t=N(n,"labels","sigmoidCrossEntropyWithLogits"),s=N(e,"logits","sigmoidCrossEntropyWithLogits");Ot(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=ea(s),o=Y(s,t),i=Ey(Fn(vn(Bt(s))));return ue(ye(r,o),i)}function yN(n,e,t,s=0,r=Ct.SUM_BY_NONZERO_WEIGHTS){let o=N(n,"multiClassLabels","sigmoidCrossEntropy");const i=N(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=N(t,"weights","sigmoidCrossEntropy")),Ot(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const l=ve(s),c=ve(1),d=ve(.5);o=ue(Y(o,ye(c,l)),Y(d,l))}const u=gN(o,i);return Mn(u,a,r)}const xN=B({sigmoidCrossEntropy_:yN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Ln((r,o,i)=>{const u=_y(o,[t],!0),l=ye(ze(o,"float32"),u);i([r,l]);const c=vn(Y(l,r));return{value:We(c,[t]),gradFunc:(p,f)=>{const[g,y]=f,x=Ft(p.shape,[t]);return[Y(j(p,x),ye(ze(g,"float32"),Fn(y))),Y(j(p,x),ye(Fn(y),ze(g,"float32")))]}}})(n,e)}function wN(n,e,t,s=0,r=Ct.SUM_BY_NONZERO_WEIGHTS){let o=N(n,"onehotLabels","softmaxCrossEntropy");const i=N(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=N(t,"weights","softmaxCrossEntropy")),Ot(o.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const l=ve(s),c=ve(1),d=ve(o.shape[1]);o=ue(Y(o,ye(c,l)),Se(l,d))}const u=bN(o,i);return Mn(u,a,r)}const vN=B({softmaxCrossEntropy_:wN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(n,e,t,s){const r=N(n,"indices","sparseFillEmptyRows","int32"),o=N(e,"values","sparseFillEmptyRows"),i=N(t,"denseShape","sparseFillEmptyRows","int32"),a=N(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u={indices:r,values:o,denseShape:i,defaultValue:a},l=z.runKernel(Ng,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const SN=B({sparseFillEmptyRows_:CN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n,e,t){const s=N(n,"inputIndices","sparseReshape","int32"),r=N(e,"inputShape","sparseReshape","int32"),o=N(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:s,inputShape:r,newShape:o},a=z.runKernel(Tg,i);return{outputIndices:a[0],outputShape:a[1]}}const IN=B({sparseReshape_:$N});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(n,e,t){const s=N(n,"data","sparseSegmentMean"),r=N(e,"indices","sparseSegmentMean","int32"),o=N(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return z.runKernel($d,i)}const NN=B({sparseSegmentMean_:kN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n,e,t){const s=N(n,"data","sparseSegmentSum"),r=N(e,"indices","sparseSegmentSum","int32"),o=N(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return z.runKernel(Id,i)}const EN=B({sparseSegmentSum_:TN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n,e,t,s,r,o,i,a){const u=N(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=N(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:i,preserveShortSequences:a},d={data:u,dataSplits:l},h=z.runKernel(Ed,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}const _N=B({stringNGrams_:RN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n,e,t=!0){const s=N(n,"input","stringSplit","string"),r=N(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},i={input:s,delimiter:r},a=z.runKernel(_g,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const PN=B({stringSplit_:AN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DN(n,e){const t=N(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return z.runKernel(Ag,r,s)}const ON=B({stringToHashBucketFast_:DN});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n,e,t,s=!0){const r=N(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return z.runKernel(Rg,{x:r},o)}const LN=B({staticRegexReplace_:FN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BN={fft:Yd,ifft:Ri,rfft:Qd,irfft:Uy},zN={hammingWindow:lk,hannWindow:Qy,frame:Zy,stft:pk},ks={flipLeftRight:yk,grayscaleToRGB:bk,resizeNearestNeighbor:Hk,resizeBilinear:Uk,rgbToGrayscale:vk,rotateWithOffset:Sk,cropAndResize:mk,nonMaxSuppression:Ik,nonMaxSuppressionAsync:Pk,nonMaxSuppressionWithScore:Ok,nonMaxSuppressionWithScoreAsync:Lk,nonMaxSuppressionPadded:zk,nonMaxSuppressionPaddedAsync:Mk,threshold:Xk,transform:Yk},VN={bandPart:Zk,gramSchmidt:eN,qr:nN},MN={absoluteDifference:oN,computeWeightedLoss:Mn,cosineDistance:aN,hingeLoss:lN,huberLoss:dN,logLoss:pN,meanSquaredError:mN,sigmoidCrossEntropy:xN,softmaxCrossEntropy:vN},WN={sparseFillEmptyRows:SN,sparseReshape:IN,sparseSegmentMean:NN,sparseSegmentSum:EN},UN={stringNGrams:_N,stringSplit:PN,stringToHashBucketFast:ON,staticRegexReplace:LN};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GN=new Map,HN=new Map;class jN{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class bs{constructor(){this.classNameMap={}}static getMap(){return bs.instance==null&&(bs.instance=new bs),bs.instance}static register(e){bs.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function KN(n,e,t){T(n.className!=null,()=>"Class being registered does not have the static className property defined."),T(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),T(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return bs.register(n),GN.set(r,n),HN.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vs extends jN{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const i=s.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return _e(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return _C(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Vs,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XN extends Vs{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:fe(()=>Mt(o).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:fe(()=>Mt(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;fe(()=>{const c=ue(Y(u,this.rho),Y(qt(a),1-this.rho)),d=Y(Se(On(ue(l,this.epsilon)),On(ue(u,this.epsilon))),a),h=ue(Y(l,this.rho),Y(qt(d),1-this.rho));u.assign(c),l.assign(h);const p=ue(Y(d,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(e=>e.variable)),_e(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qN extends Vs{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:fe(()=>ko(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=this.accumulatedGrads[r].variable;fe(()=>{const u=ue(a,qt(i));a.assign(u);const l=ue(Y(Se(i,On(ue(u,z.backend.epsilon()))),-this.learningRate),o);o.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YN extends Vs{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],fe(()=>{this.accBeta1=ve(t).variable(),this.accBeta2=ve(s).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);fe(()=>{const s=ye(1,this.accBeta1),r=ye(1,this.accBeta2);t.forEach((o,i)=>{const a=z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:fe(()=>Mt(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:fe(()=>Mt(a).variable(u))});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=ue(Y(c,this.beta1),Y(l,1-this.beta1)),p=ue(Y(d,this.beta2),Y(qt(l),1-this.beta2)),f=Se(h,s),g=Se(p,r);c.assign(h),d.assign(p);const y=ue(Y(Se(f,ue(On(g),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),fe(()=>{this.accBeta1.assign(uo(this.beta1,this.iterations_+1)),this.accBeta2.assign(uo(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QN extends Vs{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],fe(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(t).variable()}),r==null&&(this.epsilon=z.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);fe(()=>{const s=ye(1,this.accBeta1),r=Se(-this.learningRate,ue(Y(this.iteration,this.decay),1));t.forEach((o,i)=>{const a=z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Mt(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Mt(a).variable(u)});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=ue(Y(c,this.beta1),Y(l,1-this.beta1)),p=Y(d,this.beta2),f=Bt(l),g=Oy(p,f);c.assign(h),d.assign(g);const y=ue(Y(Se(r,s),Se(h,ue(g,this.epsilon))),a);a.assign(y)}),this.iteration.assign(ue(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ex extends Vs{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const i=z.registeredVariables[s];fe(()=>{const a=ue(Y(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=xn(ve(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZN extends ex{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=ve(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:fe(()=>Mt(o).variable(!1))});const i=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&fe(()=>{let u;const l=ue(Y(this.m,i),a);this.useNesterov?u=ue(Y(this.c,ue(a,Y(l,this.m))),o):u=ue(Y(this.c,l),o),i.assign(l),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JN extends Vs{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=z.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=z.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:fe(()=>Mt(o).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:fe(()=>Mt(o).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:fe(()=>Mt(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;fe(()=>{const c=ue(Y(u,this.decay),Y(qt(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,h=ue(Y(d,this.decay),Y(a,1-this.decay)),p=Se(Y(a,this.learningRate),On(ye(c,ue(qt(h),this.epsilon)))),f=ue(Y(l,this.momentum),p);u.assign(c),d.assign(h),l.assign(f);const g=ye(o,f);o.assign(g)}else{const d=ue(Y(u,this.decay),Y(qt(a),1-this.decay)),h=ue(Y(l,this.momentum),Se(Y(a,this.learningRate),On(ue(d,this.epsilon))));u.assign(d),l.assign(h);const p=ye(o,h);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=[XN,qN,YN,QN,ZN,JN,ex];function tT(){for(const n of eT)KN(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT="model",sT=".json",rT=".weights.bin";function xf(n){return new Promise(e=>setTimeout(e)).then(n)}class Os{constructor(e){if(!M().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Os.URL_SCHEME)&&(e=e.slice(Os.URL_SCHEME.length)),(e==null||e.length===0)&&(e=nT),this.modelJsonFileName=e+sT,this.weightDataFileName=e+rT}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=dn.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=ny(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await xf(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await xf(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:$o(e)}}}}Os.URL_SCHEME="downloads://";class oT{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),i=o.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const u=Md(o,l=>this.loadWeights(l));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const i of e)t.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(o).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;s(a)},o.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>af(o.name)),r={};for(const o of e)o.paths.forEach(i=>{const a=af(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const iT=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Os.URL_SCHEME)?aT(n.slice(Os.URL_SCHEME.length)):null;He.registerSaveRouter(iT);function aT(n="model"){return new Os(n)}function uT(n){return new oT(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(n,e,t,s){i(n),t=t??0,s=s??1,a(t,s);let r=0;const o=u=>(u.then(l=>{const c=t+ ++r/n.length*(s-t);return e(c),l}),u);function i(u){T(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){T(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),T(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),T(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function tx(n,e){e==null&&(e={});const t=e.fetchFunc==null?M().platform.fetch:e.fetchFunc,s=n.map(d=>t(d,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(s):await bf(s,e.onProgress,0,.5)).map(d=>d.arrayBuffer());return e.onProgress==null?await Promise.all(a):await bf(a,e.onProgress,.5,1)}function lT(n,e){var t;const s=e.fetchFunc==null?M().platform.fetch:e.fetchFunc;let r=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;r<n.length;){o||(o=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await o.read();if(u){r++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,r/n.length);continue}i.enqueue(l);return}i.close()}})}async function cT(n,e="",t,s){return nx(i=>tx(i,{requestInit:s}))(n,e,t)}function nx(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},i=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((p,f)=>{let g=0;p.weights.forEach(y=>{const x="quantization"in y?y.quantization.dtype:y.dtype,w=Rs[x]*H(y.shape),$=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:y,groupOffset:g,sizeBytes:w})};s!=null?s.forEach((S,E)=>{S===y.name&&($(),i[E]=!0)}):$(),a.push(y.name),g+=w})}),!i.every(p=>p)){const p=s.filter((f,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const u=r.reduce((p,f,g)=>(f&&p.push(g),p),[]),l=[];u.forEach(p=>{e[p].paths.forEach(f=>{const g=t+(t.endsWith("/")?"":"/")+f;l.push(g)})});const c=await n(l),d={};let h=0;return u.forEach(p=>{const f=e[p].paths.length,g=new dn(c.slice(h,h+f));o[p].forEach(x=>{const w=g.slice(x.groupOffset,x.groupOffset+x.sizeBytes),$=Jg(w,[x.manifestEntry]);for(const S in $)d[S]=$[S]}),h+=f}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT="application/octet-stream",hT="application/json";class sh{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(T(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=M().platform.fetch,T(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&T(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=ny(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:hT}),"model.json"),e.weightData!=null){const i=dn.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:dT}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:$o(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Md(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=vu(e.weightsManifest),r=()=>lT(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=pT(t),o=this.weightPathPrefix||s,i=[],a=[];for(const u of e)for(const l of u.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(l)):i.push(o+l+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const t=await this.getWeightUrls(e),s=vu(e),r=await tx(t,this.loadOptions);return[s,r]}}sh.URL_SCHEME_REGEX=/^https?:\/\//;function pT(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function Ru(n){return n.match(sh.URL_SCHEME_REGEX)!=null}const sx=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>Ru(s)):t=Ru(n),t)return rh(n,e)}return null};He.registerSaveRouter(sx);He.registerLoadRouter(sx);function rh(n,e){return new sh(n,e)}function fT(n,e){return rh(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ja{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class rx{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class mT{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function gT(n,e,t,s){const r=arguments;return new mT(ox(...r))}function ox(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new ja(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ja({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ja({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function yT(n){return new rx(n)}function xT(n){return new rx(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ix=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:dn,browserFiles:uT,browserHTTPRequest:fT,concatenateArrayBuffers:xw,copyModel:Vw,decodeWeights:Jg,decodeWeightsStream:ty,encodeWeights:hw,fromMemory:gT,fromMemorySync:ox,getLoadHandlers:kw,getModelArtifactsForJSON:Md,getModelArtifactsForJSONSync:sy,getModelArtifactsInfoForJSON:$o,getSaveHandlers:Iw,getWeightSpecs:vu,http:rh,isHTTPScheme:Ru,listModels:Bw,loadWeights:cT,moveModel:Mw,registerLoadRouter:$w,registerSaveRouter:Sw,removeModel:zw,weightsLoaderFactory:nx,withSaveHandler:yT,withSaveHandlerSync:xT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fs,wf=!1;function bT(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Ii(wi,z.backendName)!=null){const f={pixels:n},g={numChannels:e};return z.runKernel(wi,f,g)}const[l,c]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d;if(i)d=n.getContext("2d").getImageData(0,0,l,c).data;else if(s||t)d=n.data;else if(o||r||a){if(fs==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")fs=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else fs=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});fs.canvas.width=l,fs.canvas.height=c,fs.drawImage(n,0,0,l,c),d=fs.getImageData(0,0,l,c).data}let h;if(e===4)h=new Int32Array(d);else{const f=l*c;h=new Int32Array(f*e);for(let g=0;g<f;g++)for(let y=0;y<e;++y)h[g*e+y]=d[g*4+y]}return jy(h,[c,l,e],"int32")}function wT(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}async function oh(n,e){let t=N(n,"img","toPixels");if(!(n instanceof Ke)){const l=t;t=ze(l,"int32"),l.dispose()}wT(t);const[s,r]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let l=0;l<s*r;++l){const c=[0,0,0,255];for(let h=0;h<o;h++){const p=i[l*o+h];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);o===1?(c[0]=p*a,c[1]=p*a,c[2]=p*a):c[h]=p*a}const d=l*4;u[d+0]=Math.round(c[0]),u[d+1]=Math.round(c[1]),u[d+2]=Math.round(c[2]),u[d+3]=Math.round(c[3])}if(e!=null){wf||Ii(gg,z.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wf=!0),e.width=r,e.height=s;const l=e.getContext("2d"),c=new ImageData(u,r,s);l.putImageData(c,0,0)}return t!==n&&t.dispose(),u}const ax=B({fromPixels_:bT});function ih(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(H(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let i=1;for(let d=0;d<r.length-1;++d)i*=r[d];const a=n.shape,u=r.slice();u.pop();let l=1;for(let d=o;d<t;++d)l*=a[d],u.push(a[d]);const c=[...Xe(n.shape).map(d=>d/l),1].slice(0,o);return[u,i,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u=-2,vT=-1;function ah(n,e,t){const s=n.shape.length;T(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),T(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)T(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function CT(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function uh(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function ux(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function lx(n,e,t){return t<=n?t:t-(e-1)}function cx(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function ST(n,e,t,s,r,o,i,a,u){const l=n.length;let c=new Array(l),d=new Array(l),h=new Array(l);if(e.length&&t>0){const p=e[0],f=t+1;c=dx(i,p,f,s,n),d=hx(a,p,f,r,n),h=ux(o,p,f,n)}else for(let p=0;p<l;p++)c[p]=fx(i,s,o,n,p,u),d[p]=mx(a,r,o,n,p,u),h[p]=px(o,p,u);return{begin:c,end:d,strides:h}}function dx(n,e,t,s,r){const o=[...r],i=cx(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const u=lx(e,t,a);let l=s[u];n&1<<u&&(l=0),o[a]=l}return o}function hx(n,e,t,s,r){const o=[...r],i=cx(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const u=lx(e,t,a);let l=s[u];n&1<<u&&(l=Number.MAX_SAFE_INTEGER),o[a]=l}for(let a=0;a<o.length;a++){const u=r[a];o[a]<0&&(o[a]+=u),o[a]=xi(0,o[a],r[a])}return o}function px(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function fx(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),i=xi(0,i,u-1),i}function mx(n,e,t,s,r,o){let i=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),a>0?i=xi(0,i,u):i=xi(-1,i,u-1),i}function lh(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function ch(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function dh(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{T(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(T(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,o]}function hh(n,e,t,s,r,o,i,a,u){let l;if(s==null?(l=new Array(e.length),l.fill(1)):l=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let $=0;$<d.dims;$++)c&&(1<<$&a)!==0&&d.numAddAxisAfterEllipsis++,1<<$&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};$T(d,h);let p=!0,f=!0,g=!0;const y=[],x=[];for(let $=0;$<n.length;++$){if(h.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const S=!!(h.shrinkAxisMask&1<<$),E=n[$];if(E===-1){y.push(S?1:-1);continue}const P=[h.beginMask&1<<$,h.endMask&1<<$],F=[h.strides[$]>0?0:-1,h.strides[$]>0?E:E-1];if(S&&h.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&h.strides[$]===1;const L=!!(h.beginMask&1<<$&&h.endMask&1<<$);if(h.beginValid&&h.endValid){if(S){const W=h.begin[$]<0?E+h.begin[$]:h.begin[$];if(h.begin[$]=W,h.end[$]=h.begin[$]+1,W<0||W>=E)throw Error(`slice index ${h.begin[$]} of dimension ${$} out of bounds.`)}else h.begin[$]=vf(h.begin[$],0,h.strides[$],E,P,F),h.end[$]=vf(h.end[$],1,h.strides[$],E,P,F);const k=h.strides[$]===1&&h.begin[$]===0&&h.end[$]===E;p=p&&k,f=f&&($===0&&h.strides[$]===1||k)}else p=p&&h.strides[$]===1&&L,f=f&&($===0&&h.strides[$]===1||L);let R,A=!1;if(h.beginValid&&h.endValid?(R=h.end[$]-h.begin[$],A=!0):S?(R=1,A=!0):L&&E>=0&&(h.strides[$]<0?R=-E:R=E,A=!0),A){let k;R===0||R<0!=h.strides[$]<0?k=0:k=Math.trunc(R/h.strides[$])+(R%h.strides[$]!==0?1:0),y.push(k)}else y.push(-1)}for(let $=0;$<h.finalShapeGatherIndices.length;++$){const S=h.finalShapeGatherIndices[$];S>=0?x.push(y[S]):S===_u&&x.push(1)}return{finalShapeSparse:x.filter(($,S)=>h.finalShapeGatherIndices[S]!==_u),finalShape:x,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function $T(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(_u),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(vT),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function vf(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const i=n<0?s+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const IT=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ah,computeFlatOffset:ch,computeOutShape:uh,getNormalizedAxes:ST,isSliceContinous:lh,maskToAxes:CT,parseSliceParams:dh,sliceInfo:hh,startForAxis:fx,startIndicesWithElidedDims:dx,stopForAxis:mx,stopIndicesWithElidedDims:hx,stridesForAxis:px,stridesWithElidedDims:ux},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kT=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function NT(){return new Promise(n=>kT(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ph(n,e){const t=n[0].length;n.forEach((r,o)=>{T(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),T(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let i=0;i<t;i++)T(i===e||r[i]===s[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Zt(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var un;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(un||(un={}));function gx(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],i=s[s.length-t.length+r],a=s[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${a}`)}else s[i]=o}return s}function yx(n){const e={FIRST_DIM_SIZE:un.FIRST_DIM_SIZE,VALUE_ROWIDS:un.VALUE_ROWIDS,ROW_LENGTHS:un.ROW_LENGTHS,ROW_SPLITS:un.ROW_SPLITS,ROW_LIMITS:un.ROW_LIMITS,ROW_STARTS:un.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function xx(n){return n.length===0?0:n[0]===un.FIRST_DIM_SIZE?n.length-1:n.length}function bx(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],i=e[r+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fh=30;function oa(n){return n<=fh?n:pu(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function To(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)r=r.concat([n[i+1]/e[i],e[i]]);r=r.concat(n.slice(o+1))}return r}function Eo(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):r.push(i);s.push(...r),s.push(0),s.push(...o)}return s}function Ro(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function gh(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function yh(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xh=1.7580993408473768,bh=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wh=.3275911,vh=.254829592,Ch=-.284496736,Sh=1.421413741,$h=-1.453152027,Ih=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mo(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function TT(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function ET(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function RT(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function _T(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function AT(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function PT(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function DT(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ka="->",OT=/->/g,Cf=",",Sf="...";function kh(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(OT,"").length)/Ka.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ka}").`);const[s,r]=n.split(Ka);T(s.indexOf(Sf)===-1,()=>`The ellipsis notation ("${Sf}") is not supported yet.`);const o=s.split(Cf),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<r.length;++h){const p=r[h];if(!o.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let h=0;h<s.length;++h){const p=s[h];a.indexOf(p)===-1&&p!==Cf&&a.push(p)}const u=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let p=0;p<o[h].length;++p)u[h].push(a.indexOf(o[h][p]))}const l=a.length,c=r.length,d=[];for(let h=c;h<l;++h)d.push(h);return{allDims:a,summedDims:d,idDims:u}}function Nh(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Th(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=o[i]:T(s[e[r][i]]===o[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function Eh(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let i=0;i<r;++i)s.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],u=FT(e,a);for(const l of u)o.indexOf(l)===-1&&(s[i].push(l),o.push(l))}return{path:t,steps:s}}function Rh(n){return n.every((e,t)=>e===t)}function FT(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function _h(n,e,t=0){let s=[];if(typeof e=="number")T(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);T(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,u)=>u>0?a+u:a);e[o]=n.shape[t]-i}T(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function vx(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Cx(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function $x(n,e){return`size ${n} must be non-negative, not ${e}`}function Ix(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function kx(n,e){const t=H(n),s=H(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Nx(n,e){const t=H(n),s=H(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(){return"segment ids must be >= 0"}function Tx(){return"segment ids are not increasing"}function Ex(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Rx(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n,e){let t=!1,s;for(n<=fh?(s=n,t=!0):s=pu(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=pu(n,s+1);return s}function Ah(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function Ph(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const i=n.shape[t],a=[];let u=1,l=1,c=1;for(let d=0;d<s;++d)a.push(n.shape[d]),u*=n.shape[d];for(let d=s;d<t;d++)a.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<r;d++)a.push(e.shape[d]);for(let d=t+1;d<o;d++)a.push(n.shape[d]),c*=n.shape[d];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}const LT=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Ph,computeOutShape:Ah,segOpComputeOptimalWindowSize:_x},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(n){try{return n.map(e=>Pn(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Ax(n){return n.map(e=>Qn(e))}const BT=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:vh,ERF_A2:Ch,ERF_A3:Sh,ERF_A4:$h,ERF_A5:Ih,ERF_P:wh,PARALLELIZE_THRESHOLD:fh,get RowPartitionType(){return un},SELU_SCALE:bh,SELU_SCALEALPHA:xh,applyActivation:sa,assertAndGetBroadcastShape:be,assertAxesAreInnerMostDims:Lt,assertParamsConsistent:ph,assignToTypedArray:AT,axesAreInnerMostDims:Gd,calculateShapes:Bs,checkEinsumDimSizes:Th,checkPadOnDimRoundingMode:en,combineLocations:Cy,combineRaggedTensorToTensorShapes:gx,complexWithEvenIndex:ET,complexWithOddIndex:RT,computeConv2DInfo:Ze,computeConv3DInfo:as,computeDefaultPad:Wd,computeDilation2DInfo:Io,computeOptimalWindowSize:oa,computeOutAndReduceShapes:Ut,computeOutShape:Zt,computePool2DInfo:Jt,computePool3DInfo:Vn,convertConv2DDataFormat:hn,decodeEinsumEquation:kh,eitherStridesOrDilationsAreOne:bt,expandShapeToKeepDim:Ft,exponent:DT,exponents:PT,fromStringArrayToUint8:Ax,fromUint8ToStringArray:ss,getAxesPermutation:dt,getBroadcastDims:hr,getComplexWithIndex:_T,getEinsumComputePath:Eh,getEinsumPermutation:Nh,getFusedBiasGradient:na,getFusedDyActivation:ta,getImageCenter:mh,getInnerMostAxes:ht,getPermuted:Eo,getRaggedRank:xx,getReductionAxes:by,getReshaped:To,getReshapedPermuted:Ro,getRowPartitionTypesHelper:yx,getSliceBeginCoords:gh,getSliceSize:yh,getSparseFillEmptyRowsIndicesDenseShapeMismatch:wx,getSparseFillEmptyRowsNegativeIndexErrorMessage:vx,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Cx,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ix,getSparseReshapeInputOutputMismatchErrorMessage:Nx,getSparseReshapeInputOutputMultipleErrorMessage:kx,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Sx,getSparseReshapeNegativeOutputDimErrorMessage:$x,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Rx,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Au,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Tx,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Ex,getUndoAxesPermutation:No,isIdentityPermutation:Rh,log:z1,mergeRealAndImagArrays:mo,prepareAndValidate:ih,prepareSplitSize:_h,segment_util:LT,shouldFuse:ra,slice_util:IT,splitRealAndImagArrays:TT,stridesOrDilationsArePositive:Ps,tupleValuesAreOne:ao,upcastType:$t,validateDefaultValueShape:bx,validateInput:Zd,validateUpdateShape:Ky,warn:ln},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tT();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zT=M();zT.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Rt;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Rt||(Rt={}));var $f;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})($f||($f={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VT={};function Px(n){return VT[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,l=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return rt(e.inputNames[l],t,s,r);if(o.type==="tensors"){const h=e.inputs.slice(a,u);return e.inputNames.slice(a,u).filter((f,g)=>{var y;return((y=h[g])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(f=>rt(f,t,s,r))}const c=rt(e.inputNames[l],t,s,r),d=c.dataSync();return o.type==="number"?d[0]:fu(c.shape,d)}const i=e.attrParams[n];return i&&i.value}function rt(n,e,t,s){const[r,o]=_t(n,t);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[_i(r,a)]);return i!==void 0?e[_i(r,i)][o]:void 0}function If(n,e,t){return e[_i(n,t.currentContextId)]}function Nn(n,e){const[t,s,r]=_t(n,e);return[_i(t,e&&e.currentContextId),s,r]}function _i(n,e){return e?`${n}-${e}`:n}function _t(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],i=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);r=[o,a,i]}return t&&e.parseNodeNameCache.set(n,r),r}function mi(n,e,t){let s=v("pad",n,e,t);if(s==="explicit"){s=v("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function Tn(n){return n.kept?n:Zn(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MT=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],WT=Object.freeze(Object.defineProperty({__proto__:null,json:MT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UT=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],GT=Object.freeze(Object.defineProperty({__proto__:null,json:UT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HT=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],jT=Object.freeze(Object.defineProperty({__proto__:null,json:HT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],XT=Object.freeze(Object.defineProperty({__proto__:null,json:KT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qT=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],YT=Object.freeze(Object.defineProperty({__proto__:null,json:qT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZT=Object.freeze(Object.defineProperty({__proto__:null,json:QT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],eE=Object.freeze(Object.defineProperty({__proto__:null,json:JT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tE=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],nE=Object.freeze(Object.defineProperty({__proto__:null,json:tE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sE=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],rE=Object.freeze(Object.defineProperty({__proto__:null,json:sE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oE=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],iE=Object.freeze(Object.defineProperty({__proto__:null,json:oE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aE=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],uE=Object.freeze(Object.defineProperty({__proto__:null,json:aE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lE=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],cE=Object.freeze(Object.defineProperty({__proto__:null,json:lE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],hE=Object.freeze(Object.defineProperty({__proto__:null,json:dE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],fE=Object.freeze(Object.defineProperty({__proto__:null,json:pE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gE=Object.freeze(Object.defineProperty({__proto__:null,json:mE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],xE=Object.freeze(Object.defineProperty({__proto__:null,json:yE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bE=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],wE=Object.freeze(Object.defineProperty({__proto__:null,json:bE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vE=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],CE=Object.freeze(Object.defineProperty({__proto__:null,json:vE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SE=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],$E=Object.freeze(Object.defineProperty({__proto__:null,json:SE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kf{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[WT,GT,jT,XT,YT,ZT,eE,nE,rE,iE,uE,cE,hE,fE,gE,xE,wE,CE,$E],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],i=[],a=s.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?r.push(g[y.name]):y.op==="Const"?o.push(g[y.name]):(y.input==null||y.input.length===0)&&i.push(g[y.name]),g),{});let u=[];const l=[];let c={},d={};t!=null&&(c=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const h=Object.keys(a);h.forEach(g=>{const y=a[g];y.inputNames.forEach((x,w)=>{const[$,,S]=Nn(x),E=a[$];if(E.outputs!=null){const P=E.outputs.indexOf(S);if(P!==-1){const F=`${$}:${P}`;y.inputNames[w]=F}}y.inputs.push(E),E.children.push(y)})}),Object.keys(d).length===0?h.forEach(g=>{const y=a[g];y.children.length===0&&l.push(y)}):Object.keys(d).forEach(g=>{const[y]=Nn(g),x=a[y];x!=null&&(x.signatureKey=d[g],l.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[y]=Nn(g),x=a[y];x&&(x.signatureKey=c[g],u.push(x))}):u=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:a,inputs:u,outputs:l,weights:o,placeholders:r,signature:t,functions:p};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Px(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const i=o.type;let a;switch(o.type){case"string":a=Pu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Pu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Vu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Vu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Ou(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Ou(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=zu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=zu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=Du(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Du(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Wu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Wu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Bu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Bu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Mu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Mu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Fu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Fu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Lu(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Lu(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=Nf(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Nf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:a,type:i},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((d,h)=>(d[h.name]=this.mapNode(h),h.op==="Const"&&r.push(d[h.name]),d),{}));const i=[],a=[];e.signature.inputArg.forEach(d=>{const[h]=Nn(d.name),p={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Dh(d.type),type:"dtype"}},children:[]};p.signatureKey=d.name,i.push(p),o[h]=p}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach((p,f)=>{const[g,,y]=Nn(p),x=o[g];if(x.outputs!=null){const w=x.outputs.indexOf(y);if(w!==-1){const $=`${g}:${w}`;h.inputNames[f]=$}}h.inputs.push(x),x.children.push(h)})});const l=e.ret;e.signature.outputArg.forEach(d=>{const[h,p]=Nn(l[d.name]),f=o[h];f!=null&&(f.defaultOutput=p,a.push(f))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function IE(n){const e=M().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Dx(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):IE(n);return e?t:t.toLowerCase()}function Pu(n,e,t,s=!1){const r=n[e];return r!=null?Dx(r.s,s):t}function Du(n,e,t){const s=n[e];return s?s.b:t}function Ou(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function Dh(n){switch(typeof n=="string"&&(n=Rt[n]),n){case Rt.DT_FLOAT:case Rt.DT_HALF:return"float32";case Rt.DT_INT32:case Rt.DT_INT64:case Rt.DT_INT8:case Rt.DT_UINT8:return"int32";case Rt.DT_BOOL:return"bool";case Rt.DT_DOUBLE:return"float32";case Rt.DT_STRING:return"string";case Rt.DT_COMPLEX64:case Rt.DT_COMPLEX128:return"complex64";default:return null}}function Nf(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function Fu(n,e,t){const s=n[e];return s&&s.type?Dh(s.type):t}function Lu(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>Dh(r)):t}function Ox(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Bu(n,e,t){const s=n[e];return s&&s.shape?Ox(s.shape):t}function zu(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Vu(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>Dx(o,s)):t}function Mu(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>Ox(r)):t}function Wu(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kE{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return rt(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return rt(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Ou(this.node.rawAttrs,e,t);if(s.s!=null)return Pu(this.node.rawAttrs,e,t);if(s.b!=null)return Du(this.node.rawAttrs,e,t);if(s.shape!=null)return Bu(this.node.rawAttrs,e,t);if(s.type!=null)return Fu(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return zu(this.node.rawAttrs,e,t);if(s.list.s!=null)return Vu(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Mu(this.node.rawAttrs,e,t);if(s.list.b!=null)return Wu(this.node.rawAttrs,e,t);if(s.list.type!=null)return Lu(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const it=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Qg,abs:Bt,acos:ev,acosh:nv,add:ue,addN:rv,all:iv,any:uv,argMax:py,argMin:dv,asin:pv,asinh:mv,atan:yv,atan2:bv,atanh:vv,avgPool:fy,avgPool3d:Ev,basicLSTMCell:Fv,batchNorm:qi,batchNorm2d:Mv,batchNorm3d:Uv,batchNorm4d:Hv,batchToSpaceND:my,bincount:gy,bitwiseAnd:Xv,booleanMaskAsync:PI,broadcastArgs:Yv,broadcastTo:to,buffer:Pe,cast:ze,ceil:Jv,clipByValue:yy,clone:Zn,complex:es,concat:nt,concat1d:n2,concat2d:r2,concat3d:i2,concat4d:u2,conv1d:d2,conv2d:Yi,conv2dTranspose:f2,conv3d:g2,conv3dTranspose:w2,cos:C2,cosh:$2,cosineWindow:Jd,cumprod:k2,cumsum:T2,denseBincount:R2,depthToSpace:A2,depthwiseConv2d:Ud,diag:O2,dilation2d:L2,div:Se,divNoNan:W2,dot:G2,dropout:jI,einsum:sr,elu:vy,enclosingPowerOfTwo:Yy,ensureShape:X2,equal:wy,erf:Y2,euclideanNorm:oC,exp:Fn,expandDims:zt,expm1:lC,eye:$y,fft:Yd,fill:ko,floor:Iy,floorDiv:hy,fused:ak,gather:ky,gatherND:UI,greater:Zi,greaterEqual:Ny,ifft:Ri,imag:Ji,image:ks,inTopKAsync:XI,irfft:Uy,isFinite:xC,isInf:wC,isNaN:CC,leakyRelu:Ty,less:Tu,lessEqual:Hd,linalg:VN,linspace:kC,localResponseNormalization:TC,log:lo,log1p:Ey,logSigmoid:OC,logSoftmax:BC,logSumExp:_y,logicalAnd:Ti,logicalNot:Ay,logicalOr:Py,logicalXor:GC,losses:MN,lowerBound:jC,matMul:Fe,max:ar,maxPool:Dy,maxPool3d:qC,maxPoolWithArgmax:QC,maximum:Oy,mean:Ei,meshgrid:eS,min:Nu,minimum:co,mirrorPad:Fy,mod:rS,moments:iS,movingAverage:FI,mul:Y,multiRNNCell:uS,multinomial:cS,neg:vn,norm:Qi,notEqual:Ly,oneHot:pS,ones:$s,onesLike:mS,op:B,outerProduct:yS,pad:ns,pad1d:wS,pad2d:CS,pad3d:$S,pad4d:kS,pool:_S,pow:uo,prelu:zy,print:dy,prod:DS,raggedGather:FS,raggedRange:BS,raggedTensorToTensor:VS,rand:WS,randomGamma:c$,randomNormal:Vy,randomStandardNormal:p$,randomUniform:qd,randomUniformInt:g$,range:ho,real:po,reciprocal:b$,relu:ea,relu6:My,reshape:j,reverse:Ds,reverse1d:$$,reverse2d:k$,reverse3d:T$,reverse4d:R$,rfft:Qd,round:Wy,rsqrt:P$,scalar:ve,scatterND:BI,searchSorted:jd,selu:O$,separableConv2d:L$,setdiff1dAsync:z$,sigmoid:Rn,sign:M$,signal:zN,sin:U$,sinh:H$,slice:we,slice1d:K$,slice2d:q$,slice3d:Q$,slice4d:J$,softmax:tI,softplus:Ry,spaceToBatchND:By,sparse:WN,sparseToDense:MI,spectral:BN,split:fo,sqrt:On,square:qt,squaredDifference:Gy,squeeze:Oe,stack:zn,step:Hy,stridedSlice:hI,string:UN,sub:ye,sum:We,tan:fI,tanh:ku,tensor:wn,tensor1d:ct,tensor2d:Yt,tensor3d:jy,tensor4d:mI,tensor5d:gI,tensor6d:yI,tensorScatterUpdate:bI,tile:no,topk:vI,transpose:Eu,truncatedNormal:SI,unique:II,unsortedSegmentSum:NI,unstack:zs,upperBound:EI,variable:RI,where:Jn,whereAsync:qy,zeros:Bn,zerosLike:Mt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NE=(n,e,t,s=it)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(v("a",n,e,t),v("b",n,e,t))];case"AddN":return[s.addN(v("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(v("a",n,e,t),v("b",n,e,t))];case"Mul":return[s.mul(v("a",n,e,t),v("b",n,e,t))];case"RealDiv":case"Div":return[s.div(v("a",n,e,t),v("b",n,e,t))];case"DivNoNan":return[s.divNoNan(v("a",n,e,t),v("b",n,e,t))];case"FloorDiv":return[s.floorDiv(v("a",n,e,t),v("b",n,e,t))];case"Sub":return[s.sub(v("a",n,e,t),v("b",n,e,t))];case"Minimum":return[s.minimum(v("a",n,e,t),v("b",n,e,t))];case"Maximum":return[s.maximum(v("a",n,e,t),v("b",n,e,t))];case"Pow":return[s.pow(v("a",n,e,t),v("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(v("a",n,e,t),v("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TE=(n,e,t,s=it)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(v("x",n,e,t))];case"Acos":return[s.acos(v("x",n,e,t))];case"Acosh":return[s.acosh(v("x",n,e,t))];case"Asin":return[s.asin(v("x",n,e,t))];case"Asinh":return[s.asinh(v("x",n,e,t))];case"Atan":return[s.atan(v("x",n,e,t))];case"Atan2":return[s.atan2(v("x",n,e,t),v("y",n,e,t))];case"Atanh":return[s.atanh(v("x",n,e,t))];case"Ceil":return[s.ceil(v("x",n,e,t))];case"Complex":return[s.complex(v("real",n,e,t),v("imag",n,e,t))];case"Cos":return[s.cos(v("x",n,e,t))];case"Cosh":return[s.cosh(v("x",n,e,t))];case"Elu":return[s.elu(v("x",n,e,t))];case"Erf":return[s.erf(v("x",n,e,t))];case"Exp":return[s.exp(v("x",n,e,t))];case"Expm1":return[s.expm1(v("x",n,e,t))];case"Floor":return[s.floor(v("x",n,e,t))];case"Log":return[s.log(v("x",n,e,t))];case"Log1p":return[s.log1p(v("x",n,e,t))];case"Imag":return[s.imag(v("x",n,e,t))];case"Neg":return[s.neg(v("x",n,e,t))];case"Reciprocal":return[s.reciprocal(v("x",n,e,t))];case"Real":return[s.real(v("x",n,e,t))];case"Relu":return[s.relu(v("x",n,e,t))];case"Round":return[s.round(v("x",n,e,t))];case"Selu":return[s.selu(v("x",n,e,t))];case"Sigmoid":return[s.sigmoid(v("x",n,e,t))];case"Sin":return[s.sin(v("x",n,e,t))];case"Sign":return[s.sign(v("x",n,e,t))];case"Sinh":return[s.sinh(v("x",n,e,t))];case"Softplus":return[s.softplus(v("x",n,e,t))];case"Sqrt":return[s.sqrt(v("x",n,e,t))];case"Square":return[s.square(v("x",n,e,t))];case"Tanh":return[s.tanh(v("x",n,e,t))];case"Tan":return[s.tan(v("x",n,e,t))];case"ClipByValue":return[s.clipByValue(v("x",n,e,t),v("clipValueMin",n,e,t),v("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(v("x",n,e,t))];case"Rsqrt":return[s.rsqrt(rt(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(v("x",n,e,t),v("alpha",n,e,t))];case"Prelu":return[s.prelu(v("x",n,e,t),v("alpha",n,e,t))];case"IsNan":return[s.isNaN(rt(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(rt(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(rt(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){T(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];T(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Tf(n){return!(typeof n=="number"||n.some(e=>e<0))}function Hr(n,e,t){let s=Uu(n,t);const r=!Tf(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=Uu(o.shape,s)}),!Tf(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Uu(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EE{constructor(e,t,s,r,o,i,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=ve(0),xn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Kt(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,xn(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return wn([],[0].concat(this.elementShape));const s=this.readMany(e);return Kt(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),zn(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return wn([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Kt(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),nt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,zs(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,i=[];fe(()=>{t=j(t,[1,s,o]);for(let u=0;u<e.length;++u){const c=[0,u===0?0:r[u-1],0],d=[1,e[u],o];i[u]=j(we(t,c,d),this.elementShape)}return i});const a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);Kt(t,o.shape,"TensorList shape mismatch: "),xn(o)}),this.idTensor=ve(0),this.maxNumElements=r,xn(this.idTensor)}copy(){return new Fs([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Kt(e,this.elementShape,"TensorList shape mismatch: ");const r=Hr(this.elementShape,this.tensors,e);return fe(()=>{const o=this.tensors.map(i=>j(i,r));return zn(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Hr(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Kt(r.shape,e,"TensorList shape mismatch: "),j(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Kt(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");xn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Fs([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Kt(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Hr(this.elementShape,this.tensors,t);return j(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Kt(this.elementShape,t.shape,"TensorList shape mismatch: "),xn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Kt(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Hr(this.elementShape,this.tensors,s);return e.length===0?wn([],[0].concat(r)):fe(()=>{const o=e.map(i=>j(this.tensors[i],r));return zn(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Kt(this.elementShape,t,"TensorList shape mismatch: ");const s=Hr(this.elementShape,this.tensors,t);return this.size()===0?wn([],[0].concat(s)):fe(()=>{const r=this.tensors.map(o=>j(o,s));return nt(r,0)})}}function RE(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Kt(r,e,"TensorList shape mismatch: ");const o=zs(n);return new Fs(o,e,s)}function _E(n,e,t,s){return new Fs([],n,e,s)}function AE(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new Fs([],t,n.dtype,s),i=zs(n,0);return e.forEach((a,u)=>{o.setItem(a,i[u])}),o}function PE(n,e,t){let s=0;const r=e.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=Uu(o,t),a=s===0?0:n.size/s,u=fe(()=>{const c=[];n=j(n,[1,s,a]);for(let d=0;d<e.length;++d){const p=[0,d===0?0:r[d-1],0],f=[1,e[d],a];c[d]=j(we(n,p,f),i)}return n.dispose(),c}),l=new Fs([],t,n.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=v("thenBranch",n,e,t),r=v("elseBranch",n,e,t),o=v("cond",n,e,t),i=v("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=v("body",n,e,t),r=v("cond",n,e,t),o=v("args",n,e,t),i=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(c=>c.id);let u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=o;for(;u[0];){const c=l;l=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const d=l.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});const h=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await h[0].data(),h.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return l}case"LoopCond":{const s=v("pred",n,e,t);return[Tn(s)]}case"Switch":{const s=v("pred",n,e,t);let r=v("data",n,e,t);return r.kept||(r=Tn(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>rt(r,e,t)!==void 0);if(s){const r=rt(s,e,t);return[Tn(r)]}return}case"Enter":{const s=v("frameName",n,e,t),r=v("tensor",n,e,t);return t.enterFrame(s),[Tn(r)]}case"Exit":{const s=v("tensor",n,e,t);return t.exitFrame(),[Tn(s)]}case"NextIteration":{const s=v("tensor",n,e,t);return t.nextIteration(),[Tn(s)]}case"TensorArrayV3":{const s=v("size",n,e,t),r=v("dtype",n,e,t),o=v("elementShape",n,e,t),i=v("dynamicSize",n,e,t),a=v("clearAfterRead",n,e,t),u=v("identicalElementShapes",n,e,t),l=v("name",n,e,t),c=new EE(l,r,s,o,u,i,a);return t.addTensorArray(c),[c.idTensor,ve(1)]}case"TensorArrayWriteV3":{const s=v("tensorArrayId",n,e,t),r=v("index",n,e,t),o=v("tensor",n,e,t),i=t.getTensorArray(s.id);return i.write(r,o),[i.idTensor]}case"TensorArrayReadV3":{const s=v("tensorArrayId",n,e,t),r=v("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=v("tensorArrayId",n,e,t),r=v("indices",n,e,t),o=v("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=v("tensorArrayId",n,e,t),r=v("indices",n,e,t),o=v("tensor",n,e,t),i=t.getTensorArray(s.id);return i.scatter(r,o),[i.idTensor]}case"TensorArrayConcatV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=v("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=v("tensorArrayId",n,e,t),r=v("tensor",n,e,t),o=v("lengths",n,e,t),i=t.getTensorArray(s.id);return i.split(o,r),[i.idTensor]}case"TensorArraySizeV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[ve(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=v("tensorListId",n,e,t),r=v("index",n,e,t),o=v("tensor",n,e,t),i=t.getTensorList(s.id);return i.setItem(r,o),[i.idTensor]}case"TensorListGetItem":{const s=v("tensorListId",n,e,t),r=v("index",n,e,t),o=v("elementShape",n,e,t),i=v("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=v("indices",n,e,t),r=v("tensor",n,e,t),o=v("elementShape",n,e,t),i=v("numElements",n,e,t),a=AE(r,s,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=v("elementShape",n,e,t),r=v("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=v(o,n,e,t),a=n.op==="TensorListReserve"?-1:i,u=_E(s,r,i,a);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=v("tensorListId",n,e,t),r=v("indices",n,e,t),o=v("elementShape",n,e,t),i=v("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,i,o)]}case"TensorListStack":{const s=v("tensorListId",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t),i=v("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,i)]}case"TensorListFromTensor":{const s=v("tensor",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t),i=RE(s,r,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=v("tensorListId",n,e,t),r=t.getTensorList(s.id),o=v("dtype",n,e,t),i=v("elementShape",n,e,t);return[r.concat(o,i)]}case"TensorListPushBack":{const s=v("tensorListId",n,e,t),r=v("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=v("tensorListId",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=v("tensor",n,e,t),r=v("elementShape",n,e,t),o=v("lengths",n,e,t),i=PE(s,o,r);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=v("tensorListId",n,e,t),r=t.getTensorList(s.id);return[ve(r.size(),"int32")]}case"TensorListResize":{const s=v("tensorListId",n,e,t),r=v("size",n,e,t),i=t.getTensorList(s.id).resize(r);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ef(n,e,t){const[s,r]=v("fusedOps",n,e,t),o=s==="biasadd",i=!o,a=r==="prelu",u=s==="fusedbatchnorm",l=v("numArgs",n,e,t);if(o){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=v("strides",n,e,t),d=mi(n,e,t),h=v("dataFormat",n,e,t).toUpperCase(),p=v("dilations",n,e,t);let[f,g]=v("args",n,e,t);i&&(g=f,f=void 0);const y=v("leakyreluAlpha",n,e,t);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:g,activationFunc:r,leakyreluAlpha:y}}const OE=(n,e,t,s=it)=>{switch(n.op){case"Conv1D":{const r=v("stride",n,e,t),o=v("pad",n,e,t),i=v("dataFormat",n,e,t).toUpperCase(),a=v("dilation",n,e,t);return[s.conv1d(v("x",n,e,t),v("filter",n,e,t),r,o,i,a)]}case"Conv2D":{const r=v("strides",n,e,t),o=mi(n,e,t),i=v("dataFormat",n,e,t).toUpperCase(),a=v("dilations",n,e,t);return[s.conv2d(v("x",n,e,t),v("filter",n,e,t),[r[1],r[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=Ef(n,e,t);return[s.fused.conv2d({x:v("x",n,e,t),filter:v("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:d}=Ef(n,e,t);return[s.fused.depthwiseConv2d({x:v("x",n,e,t),filter:v("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=v("outputShape",n,e,t),o=v("strides",n,e,t),i=mi(n,e,t);return[s.conv2dTranspose(v("x",n,e,t),v("filter",n,e,t),r,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=v("strides",n,e,t),o=mi(n,e,t),i=v("dilations",n,e,t),a=v("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(v("input",n,e,t),v("filter",n,e,t),[r[1],r[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("dataFormat",n,e,t).toUpperCase(),a=v("dilations",n,e,t);return[s.conv3d(v("x",n,e,t),v("filter",n,e,t),[r[1],r[2],r[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("kernelSize",n,e,t);return[s.avgPool(v("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("kernelSize",n,e,t);return[s.maxPool(v("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("kernelSize",n,e,t),a=v("includeBatchInIndex",n,e,t),{result:u,indexes:l}=s.maxPoolWithArgmax(v("x",n,e,t),[i[1],i[2]],[r[1],r[2]],o,a);return[u,l]}case"AvgPool3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("kernelSize",n,e,t);return[s.avgPool3d(v("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("kernelSize",n,e,t);return[s.maxPool3d(v("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),i=v("dilations",n,e,t),a=r[1],u=r[2],l=i[1],c=i[2];return[s.dilation2d(v("x",n,e,t),v("filter",n,e,t),[a,u],o,[l,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FE=(n,e,t,s=it)=>{switch(n.op){case"Fill":{const r=v("shape",n,e,t),o=v("dtype",n,e,t),i=v("value",n,e,t);return[s.fill(r,i,o)]}case"LinSpace":{const r=v("start",n,e,t),o=v("stop",n,e,t),i=v("num",n,e,t);return[s.linspace(r,o,i)]}case"Multinomial":{const r=v("logits",n,e,t),o=v("numSamples",n,e,t),i=v("seed",n,e,t);return[s.multinomial(r,o,i)]}case"OneHot":{const r=v("indices",n,e,t),o=v("depth",n,e,t),i=v("onValue",n,e,t),a=v("offValue",n,e,t),u=v("dtype",n,e,t);return[s.oneHot(r,o,i,a,u)]}case"Ones":return[s.ones(v("shape",n,e,t),v("dtype",n,e,t))];case"OnesLike":return[s.onesLike(v("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(v("shape",n,e,t),v("dtype",n,e,t),v("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(v("shape",n,e,t),v("minval",n,e,t),v("maxval",n,e,t),v("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(v("shape",n,e,t),v("minval",n,e,t),v("maxval",n,e,t),v("seed",n,e,t))];case"Range":{const r=v("start",n,e,t),o=v("stop",n,e,t),i=v("step",n,e,t);return[s.range(r,o,i,v("dtype",n,e,t))]}case"TruncatedNormal":{const r=v("shape",n,e,t),o=v("mean",n,e,t),i=v("stdDev",n,e,t),a=v("seed",n,e,t);return[s.truncatedNormal(r,o,i,v("dtype",n,e,t),a)]}case"Zeros":return[s.zeros(v("shape",n,e,t),v("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n,e,t){const s=v("boxes",n,e,t),r=v("scores",n,e,t),o=v("maxOutputSize",n,e,t),i=v("iouThreshold",n,e,t),a=v("scoreThreshold",n,e,t),u=v("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}const LE=async(n,e,t,s,r=it)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=Xa(n,e,t),d=await r.image.nonMaxSuppressionWithScoreAsync(o,i,a,u,l,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=Xa(n,e,t),c=v("padToMaxOutputSize",n,e,t),d=await r.image.nonMaxSuppressionPaddedAsync(o,i,a,u,l,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=Xa(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,i,a,u,l)]}case"Where":{const o=r.cast(v("condition",n,e,t),"bool"),i=[await r.whereAsync(o)];return o.dispose(),i}case"ListDiff":return r.setdiff1dAsync(v("x",n,e,t),v("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BE=(n,e,t,s=it)=>{switch(n.op){case"LowerBound":{const r=v("sortedSequence",n,e,t),o=v("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=v("x",n,e,t),o=v("k",n,e,t),i=v("sorted",n,e,t),a=s.topk(r,o,i);return[a.values,a.indices]}case"UpperBound":{const r=v("sortedSequence",n,e,t),o=v("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=v("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=v("x",n,e,t),o=v("axis",n,e,t),i=s.unique(r,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE=(n,e,t,s=it)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=v("default",n,e,t);return[rt(n.name,e,t)||r];case"Placeholder":return[rt(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=v("x",n,e,t);return[Tn(c)]}case"IdentityN":return v("x",n,e,t).map(c=>Tn(c));case"Snapshot":const o=v("x",n,e,t);return[Tn(o)];case"Shape":return[s.tensor1d(v("x",n,e,t).shape,"int32")];case"ShapeN":return v("x",n,e,t).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(v("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(v("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=v("x",n,e,t),a=v("data",n,e,t),u=v("message",n,e,t),l=v("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VE{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ve(0),this.tensorMap=new Map,xn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),fe(()=>{const r=zs(t),o=s.length,i=r.length;T(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const u=s[a],l=r[a];xn(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return fe(()=>{const r=[];for(let o=0;o<s.length;o++){const i=s[o],a=this.findWithDefault(i,t);r.push(a)}return zn(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ME=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=v("keyDType",n,e,t),i=v("valueDType",n,e,t),a=new VE(o,i);return s.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=v("tableHandle",n,e,t,s),o=v("keys",n,e,t),i=v("values",n,e,t);return[await s.getHashTableById(r.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=v("tableHandle",n,e,t,s),o=v("keys",n,e,t),i=v("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=v("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WE=(n,e,t,s=it)=>{switch(n.op){case"ResizeBilinear":{const r=v("images",n,e,t),o=v("size",n,e,t),i=v("alignCorners",n,e,t),a=v("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const r=v("images",n,e,t),o=v("size",n,e,t),i=v("alignCorners",n,e,t),a=v("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],i,a)]}case"CropAndResize":{const r=v("image",n,e,t),o=v("boxes",n,e,t),i=v("boxInd",n,e,t),a=v("cropSize",n,e,t),u=v("method",n,e,t),l=v("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,i,a,u,l)]}case"ImageProjectiveTransformV3":{const r=v("images",n,e,t),o=v("transforms",n,e,t),i=v("outputShape",n,e,t),a=v("fillValue",n,e,t),u=v("interpolation",n,e,t),l=v("fillMode",n,e,t);return[s.image.transform(r,o,u.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE=(n,e,t,s=it)=>{switch(n.op){case"Equal":return[s.equal(v("a",n,e,t),v("b",n,e,t))];case"NotEqual":return[s.notEqual(v("a",n,e,t),v("b",n,e,t))];case"Greater":return[s.greater(v("a",n,e,t),v("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(v("a",n,e,t),v("b",n,e,t))];case"Less":return[s.less(v("a",n,e,t),v("b",n,e,t))];case"LessEqual":return[s.lessEqual(v("a",n,e,t),v("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(v("a",n,e,t),v("b",n,e,t))];case"LogicalNot":return[s.logicalNot(v("a",n,e,t))];case"LogicalOr":return[s.logicalOr(v("a",n,e,t),v("b",n,e,t))];case"Select":case"SelectV2":return[s.where(v("condition",n,e,t),v("a",n,e,t),v("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(v("a",n,e,t),v("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GE=(n,e,t,s=it)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(v("a",n,e,t),v("b",n,e,t),v("transposeA",n,e,t),v("transposeB",n,e,t))];case"Einsum":return[s.einsum(v("equation",n,e,t),...v("tensors",n,e,t))];case"Transpose":return[s.transpose(v("x",n,e,t),v("perm",n,e,t))];case"_FusedMatMul":const[r,o]=v("fusedOps",n,e,t),i=r==="biasadd",a=o==="prelu",u=v("numArgs",n,e,t),l=v("leakyreluAlpha",n,e,t);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=v("args",n,e,t);return[s.fused.matMul({a:v("a",n,e,t),b:v("b",n,e,t),transposeA:v("transposeA",n,e,t),transposeB:v("transposeB",n,e,t),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[s.linalg.bandPart(v("a",n,e,t),v("numLower",n,e,t),v("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=(n,e,t,s=it)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(v("x",n,e,t),v("axis",n,e,t),v("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(v("x",n,e,t),v("mean",n,e,t),v("variance",n,e,t),v("offset",n,e,t),v("scale",n,e,t),v("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(v("x",n,e,t),v("mean",n,e,t),v("variance",n,e,t),v("offset",n,e,t),v("scale",n,e,t),v("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(v("x",n,e,t),v("radius",n,e,t),v("bias",n,e,t),v("alpha",n,e,t),v("beta",n,e,t))];case"Softmax":return[s.softmax(v("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=(n,e,t,s=it)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(v("paramsNestedSplits",n,e,t),v("paramsDenseValues",n,e,t),v("indices",n,e,t),v("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(v("starts",n,e,t),v("limits",n,e,t),v("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(v("shape",n,e,t),v("values",n,e,t),v("defaultValue",n,e,t),v("rowPartitionTensors",n,e,t),v("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE=(n,e,t,s=it)=>{switch(n.op){case"Max":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.max(v("x",n,e,t),a,u)]}case"Mean":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.mean(v("x",n,e,t),a,u)]}case"Min":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.min(v("x",n,e,t),a,u)]}case"Sum":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.sum(v("x",n,e,t),a,u)]}case"All":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.all(v("x",n,e,t),a,u)]}case"Any":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.any(v("x",n,e,t),a,u)]}case"ArgMax":{const a=v("axis",n,e,t);return[s.argMax(v("x",n,e,t),a)]}case"ArgMin":{const a=v("axis",n,e,t);return[s.argMin(v("x",n,e,t),a)]}case"Prod":{const a=v("axis",n,e,t),u=v("keepDims",n,e,t);return[s.prod(v("x",n,e,t),a,u)]}case"Cumprod":{const a=v("axis",n,e,t),u=v("exclusive",n,e,t),l=v("reverse",n,e,t);return[s.cumprod(v("x",n,e,t),a,u,l)]}case"Cumsum":{const a=v("axis",n,e,t),u=v("exclusive",n,e,t),l=v("reverse",n,e,t);return[s.cumsum(v("x",n,e,t),a,u,l)]}case"Bincount":const r=v("x",n,e,t),o=v("weights",n,e,t),i=v("size",n,e,t);return[s.bincount(r,o,i)];case"DenseBincount":{const a=v("x",n,e,t),u=v("weights",n,e,t),l=v("size",n,e,t),c=v("binaryOutput",n,e,t);return[s.denseBincount(a,u,l,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=(n,e,t,s=it)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=v("n",n,e,t),o=v("axis",n,e,t);let i=v("tensors",n,e,t);return i=i.slice(0,r),[s.concat(i,o)]}case"Gather":{const r=v("x",n,e,t),o=v("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=v("axis",n,e,t),o=v("batchDims",n,e,t),i=v("x",n,e,t),a=v("indices",n,e,t);return[s.gather(i,s.cast(a,"int32"),r,o)]}case"Reverse":{const r=v("dims",n,e,t),o=[];for(let a=0;a<r.length;a++)r[a]&&o.push(a);const i=v("x",n,e,t);return[s.reverse(i,o)]}case"ReverseV2":{const r=v("axis",n,e,t),o=v("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=v("begin",n,e,t),o=v("size",n,e,t);return[s.slice(v("x",n,e,t),r,o)]}case"StridedSlice":{const r=v("begin",n,e,t),o=v("end",n,e,t),i=v("strides",n,e,t),a=v("beginMask",n,e,t),u=v("endMask",n,e,t),l=v("ellipsisMask",n,e,t),c=v("newAxisMask",n,e,t),d=v("shrinkAxisMask",n,e,t),h=v("x",n,e,t);return[s.stridedSlice(h,r,o,i,a,u,l,c,d)]}case"Pack":return fe(()=>{const r=v("axis",n,e,t),o=v("tensors",n,e,t),i=o[0].shape,a=s.squeeze(o[0]).shape,u=o.map(l=>{const c=Ae(l.shape,i);if(!c&&!Ae(s.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return c?l:s.reshape(l,i)});return[s.stack(u,r)]});case"Unpack":{const r=v("axis",n,e,t),o=v("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=v("reps",n,e,t);return[s.tile(v("x",n,e,t),r)]}case"Split":case"SplitV":{const r=v("axis",n,e,t),o=v("numOrSizeSplits",n,e,t),i=v("x",n,e,t);return s.split(i,o,r)}case"ScatterNd":{const r=v("indices",n,e,t),o=v("values",n,e,t),i=v("shape",n,e,t);return[s.scatterND(r,o,i)]}case"GatherNd":{const r=v("x",n,e,t),o=v("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=v("sparseIndices",n,e,t),o=v("outputShape",n,e,t),i=v("sparseValues",n,e,t),a=v("defaultValue",n,e,t);return[s.sparseToDense(r,i,o,i.dtype===a.dtype?a:s.cast(a,i.dtype))]}case"TensorScatterUpdate":{const r=v("indices",n,e,t),o=v("values",n,e,t),i=v("tensor",n,e,t);return[s.tensorScatterUpdate(i,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qE=(n,e,t,s=it)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(v("indices",n,e,t),v("values",n,e,t),v("denseShape",n,e,t),v("defaultValue",n,e,t));return[r,o,i,a]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(v("inputIndices",n,e,t),v("inputShape",n,e,t),v("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(v("data",n,e,t),v("indices",n,e,t),v("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(v("data",n,e,t),v("indices",n,e,t),v("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YE=(n,e,t,s=it)=>{switch(n.op){case"FFT":return[s.fft(v("x",n,e,t))];case"IFFT":return[s.ifft(v("x",n,e,t))];case"RFFT":return[s.rfft(v("x",n,e,t))];case"IRFFT":return[s.irfft(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE=(n,e,t,s=it)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(v("input",n,e,t),v("pattern",n,e,t),v("rewrite",n,e,t),v("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(v("data",n,e,t),v("dataSplits",n,e,t),v("separator",n,e,t),v("nGramWidths",n,e,t),v("leftPad",n,e,t),v("rightPad",n,e,t),v("padWidth",n,e,t),v("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:i}=s.string.stringSplit(v("input",n,e,t),v("delimiter",n,e,t),v("skipEmpty",n,e,t));return[r,o,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(v("input",n,e,t),v("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZE=(n,e,t,s=it)=>{switch(n.op){case"Cast":return[s.cast(v("x",n,e,t),v("dtype",n,e,t))];case"ExpandDims":{const r=v("axis",n,e,t);return[s.expandDims(v("x",n,e,t),r)]}case"Squeeze":{const r=v("axis",n,e,t);return[s.squeeze(v("x",n,e,t),r)]}case"Reshape":return[s.reshape(v("x",n,e,t),v("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(v("x",n,e,t),v("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(v("x",n,e,t),v("padding",n,e,t),v("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(v("x",n,e,t),v("padding",n,e,t),v("constantValue",n,e,t))];case"SpaceToBatchND":{const r=v("blockShape",n,e,t),o=v("paddings",n,e,t);return[s.spaceToBatchND(v("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=v("blockShape",n,e,t),o=v("crops",n,e,t);return[s.batchToSpaceND(v("x",n,e,t),r,o)]}case"DepthToSpace":{const r=v("blockSize",n,e,t),o=v("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(v("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(v("x",n,e,t),v("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(v("s0",n,e,t),v("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(n,e,t,s,r=fe){const o=((i,a,u)=>{switch(i.category){case"arithmetic":return r(()=>NE(i,a,u));case"basic_math":return r(()=>TE(i,a,u));case"control":return DE(i,a,u);case"convolution":return r(()=>OE(i,a,u));case"creation":return r(()=>FE(i,a,u));case"dynamic":return LE(i,a,u);case"evaluation":return r(()=>BE(i,a,u));case"image":return r(()=>WE(i,a,u));case"graph":return r(()=>zE(i,a,u));case"logical":return r(()=>UE(i,a,u));case"matrices":return r(()=>GE(i,a,u));case"normalization":return r(()=>HE(i,a,u));case"ragged":return r(()=>jE(i,a,u));case"reduction":return r(()=>KE(i,a,u));case"slice_join":return r(()=>XE(i,a,u));case"sparse":return r(()=>qE(i,a,u));case"spectral":return r(()=>YE(i,a,u));case"string":return r(()=>QE(i,a,u));case"transformation":return r(()=>ZE(i,a,u));case"hash_table":return ME(i,a,u,s);case"custom":const l=Px(i.op);if(l&&l.customExecutor)return l.customExecutor(new kE(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Es(o)?o.then(i=>[].concat(i)):[].concat(o)}class _f{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(n,e,t,s){const r=new Set,o=[];let i=null,a=null;const u=new Set,l=new Set(Object.keys(n).map(h=>_t(h)[0]));s=s||[];const c=new Set(s.map(h=>_t(h.name)[0])),d=[...e];for(;d.length>0;){const h=d.pop();if((ws(h)||iR(h)||aR(h))&&i==null&&(i=h,a=i.children.map(p=>p.name).filter(p=>r.has(p))),r.add(h.name),t[h.name]==null&&!l.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){o.push(h.name);continue}h.inputs.forEach(p=>{u.has(p.name)||(u.add(p.name),d.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:i,syncInputs:a}}function JE(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(y=>_t(y)[0]).map(y=>n.nodes[y]),o=n.initNodes||[],i=y=>t.has(typeof y=="string"?y:y.name);function a(y){return[...new Map(y.map(x=>[x.name,x])).values()]}const u=a([...r,...n.weights,...o]).filter(i),l=a([...u,...Object.values(n.nodes)]).filter(i),c=new Map(l.map(y=>[y.name,y])),d={};for(const y of l){d[y.name]=d[y.name]||0;for(const x of y.children)i(x)||(d[x.name]=Number.POSITIVE_INFINITY),d[x.name]=(d[x.name]||0)+1}const h=Object.entries(d).filter(([,y])=>y===0).map(([y])=>y),p=[...h];for(;h.length>0;){const y=h.pop(),x=c.get(y);for(const w of x.children.filter(i))--d[w.name]===0&&(p.push(w.name),h.push(w.name))}const f=p.map(y=>c.get(y)),g=eR(f,u);return tR(g,u),g}function eR(n,e){const t=new Map(n.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),a=t.get(i);for(const u of a.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(i=>r.has(i.name))}class Qo extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function tR(n,e){const t=new Map(n.map((a,u)=>[a.name,u])),s=new Set(e.map(a=>a.name)),r=a=>s.has(typeof a=="string"?a:a.name),o=new Set(n.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of n){for(const u of a.children.filter(i)){if(!t.has(u.name))throw new Qo(`Child ${u.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(u.name))throw new Qo(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!r(a))for(const u of a.inputs){if(!t.has(u.name))throw new Qo(`Input ${u.name} of node ${a.name} is unreachable.`);if(t.get(u.name)>t.get(a.name))throw new Qo(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}function nR(n){const e=new Map(n.map((a,u)=>[a.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((a,u)=>ws(a)?t:u),r=a=>{const u=s[e.get(a.name)];return u??-1},o=n.map((a,u)=>a.children.map(r).reduce((l,c)=>Math.max(l,c),s[u])),i=new Map;for(let a=0;a<n.length;++a){const u=o[a];if(u===t)continue;const l=n[a],c=n[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(l)}return i}const sR=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),rR=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),oR=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ws(n){return sR.has(n.op)}function iR(n){return rR.has(n.op)}function aR(n){return oR.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Ai(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=Af(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:i}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const l=t.map(d=>d.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=JE(this.graph,s),u=nR(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return xn(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(h=>this.graph.nodes[_t(h)[0]]),o=t.map(h=>_t(h)[0]),i=new Set(o);let a=o.map(h=>this.graph.nodes[h]);a.length===0&&(a=this._outputs);const u=this.getCompilationKey(r,a);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,a),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return fe(()=>{const h=new _f(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(x=>{const[w,$]=_t(x,h),S=[];S[$]=e[x],p[w]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(S))});const f=this.getFrozenTensorIds(p),{orderedNodes:g,nodeLiveUntilMap:y}=l;for(const x of g){if(p[x.name])continue;const w=Rf(x,p,h,this._resourceManager);if(Es(w))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);p[x.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,p,h,f,i,y.get(x.name))}return this.parent==null&&h.dispose(f),t.map(x=>rt(x,p,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,i,a){if(!(ws(t)||i.has(e))){for(const u of s[e])u!=null&&(a[u.id]=(a[u.id]||0)+t.children.length);for(const u of t.inputs){if(ws(u))continue;const l=If(u.name,s,r);if(l!=null)for(const c of l){if(!c||c.kept||o.has(c.id))continue;const d=a[c.id];d===1?(c.dispose(),delete a[c.id]):d!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,i){function a(u){return ws(u)||o.has(u.name)}if(!(ws(e)||i==null))for(const u of i){if(a(u))continue;const l=If(u.name,t,s);for(const c of l)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const i=new _f(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,t,s),u=t.map(h=>rt(h,a,i)),l=u.map(h=>h.id),c=Object.keys(e).map(h=>e[h].id),d=new Set([...l,...c,...this.weightIds]);return Object.values(a).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(d),u}async executeFunctionAsync(e,t,s){const r=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),i=o.map(S=>this.graph.nodes[_t(S)[0]]),a=s.map(S=>_t(S)[0]),u=new Set(a);let l=a.map(S=>this.graph.nodes[S]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=Af(e,l,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[E,P]=_t(S),F=[];F[P]=e[S],g[E]=F});const y={},x=this.getFrozenTensorIds(g),w={};for(;f.length>0;){const S=this.processStack(i,f,t,g,w,x,u,y,c);await Promise.all(S)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=l.filter(S=>!ws(S)&&!rt(S.name,g,t)).map(S=>S.name);if($.length>0){let S="";throw h!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${d}]. ${S}`)}return g}processStack(e,t,s,r,o,i,a,u,l){const c=[];for(;t.length>0;){const d=t.pop();s.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&v("isConstant",d.node,r,s)&&([h]=Nn(d.node.name,s)),r[d.node.name]==null){const p=Rf(d.node,r,s,this._resourceManager);h||([h]=Nn(d.node.name,s));const f=s.currentContext;Es(p)?c.push(p.then(g=>(r[h]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(g)),s.currentContext=f,this.checkTensorForDisposal(h,d.node,r,s,i,a,u),this.processChildNodes(d.node,t,s,r,o,l),g))):(r[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,r,s,i,a,u),this.processChildNodes(d.node,t,s,r,o,l))}else this.processChildNodes(d.node,t,s,r,o,l)}return c}processChildNodes(e,t,s,r,o,i){e.children.forEach(a=>{const[u]=Nn(a.name,s);o[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!rt(l,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(l=>!!rt(l,r,s))&&(o[u]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=_t(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===s.shape.length&&s.shape.every((u,l)=>i[l]===-1||i[l]===u);T(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&T(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const i=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];i!=null?r[i.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=_t(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=_t(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class uR{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lR="?tfjs-format=file",cR="model.json";class dR{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=ix){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new uR}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Es(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await ty(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Ai(kf.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=kf.Instance.transformGraph(e.modelInitializer);this.initializer=new Ai(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Ke?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Ke)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,i)=>{var a,u,l;const c=(l=(u=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||u===void 0?void 0:u[i])===null||l===void 0?void 0:l.resourceId;return c!=null?o[i]=this.resourceIdToCapturedInput[c]:o[i]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],i=t[o];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function pr(n,e={},t=ix){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=hR(n));const s=new dR(n,e,t);return await s.load(),s}function hR(n){return n.endsWith("/")||(n=n+"/"),`${n}${cR}${lR}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gt=M();Gt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Gt.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Gt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Gt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Gt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Gt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Gt.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Gt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Gt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Gt.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Gt.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Gt.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Gt.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pR{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fR{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,r=!0){let o;const i=Pf(e,t);return r?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,o=Pf(s,r),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Pf(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mR=class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,r){const o=Of(s),i=e*t*o,a=Df(e,t,s,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=i;const u=this.device.createTexture({size:[e,t],format:s,usage:r});return this.usedTextures.get(a).push(u),u}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,r=e.format,o=e.usage,i=Df(t,s,r,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),u=a.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);const l=Of(r),c=t*s*l;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function Df(n,e,t,s){return`${n}_${e}_${t}_${s}`}function Of(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",r=n.map(i=>`${e}.${s[i]}`),o=new Array(t-1);o[t-2]=r[t-1];for(let i=t-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}const us=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var fr;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(fr||(fr={}));const yR=(n,e,t,s,r)=>{const o={dtype:s.dtype,shape:s.shape},i=bR(t,o,e),a=n.createShaderModule({code:i,label:e.constructor.name});let u=M().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const l=u.split(",");(u==="all"||l.some(c=>e.shaderKey.toLowerCase().includes(c)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return r?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},xe=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ye(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function _n(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function Z(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function Ff(n,e){let t;return t=`
     ${xR(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function xR(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function bR(n,e,t){const s=[],r=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${Fx(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const f=t.pixelsOpType===fr.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${vs(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${vs(n[0].dtype,t.outputComponent)}>;`,g=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${f}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const y=Bf(t);return[Lf,s.join(`
`),gi(e.shape),t.getUserCode(),Ff(y,t)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((f,g)=>{const y=Ye(n[g].shape.length);a+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${y}, `,o=n[g].shape.length-1,i=Ye(o),a+=`${f.charAt(0).toLowerCase()+f.slice(1)}ShapeStrides: ${i}, `});const u=Ye(e.shape.length);a+=`outShape : ${u}, `,o=e.shape.length-1,i=Ye(o),a+=`
         outShapeStrides: ${i}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=TR(a),s.push(a),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${vs(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((f,g)=>{s.push(`
      @group(0) @binding(${1+g}) var<storage, read> ${f}: array<${t.variableComponents?vs(n[g].dtype,t.variableComponents[g]):vs(n[g].dtype,t.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const l=IR(e.shape,t.dispatchLayout),c=[Lf,s.join(`
`)+vR,gi(e.shape),l,kR(e.shape.length)];t.atomic||c.push(NR(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((f,g)=>{c.push(`${gi(n[g].shape,f)}`)});const d=n.map((f,g)=>$R(f,e.shape,t.variableComponents?t.variableComponents[g]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(d),c.push(t.getUserCode());const h=Bf(t);return c.push(Ff(h,t)),c.join(`
`)}function wR(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const r=[],o=[];e.forEach(c=>{r.push(c.shape),o.push(c.dtype)}),r.push(t.shape),o.push(t.dtype);const i=e.map(c=>hr(c.shape,t.shape)),a=e.map(c=>Ae(c.shape,t.shape)).join("_"),u=i.map(c=>c.join("_")).join(";"),l=Fx(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+r.map(c=>c.length).join(",")+o.join(",")+n.variableNames.join(",")+u+a+l,s}const Lf=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,vR=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function gi(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const o=Xe(n),i=Ye(t),a=[];for(let l=0;l<t;l++)a.push(`d${l}`);if(o.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+o.map((l,c)=>{const d=`let ${a[c]} = index2 / uniforms.${r}.${_n(c)}`,h=c===o.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${r}.${_n(c)}`:`index2 = index2 - ${a[c]} * uniforms.${r}.${_n(c)}`;return`${d}; ${h};`}).join(""),`
    fn ${s}(index : i32) -> ${i} {
      ${u}
      return ${i}(${a.join(",")});
    }
  `}function CR(n,e){const t=n.name,s=n.shape.length,r=Ye(s),o="get"+t.charAt(0).toUpperCase()+t.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=i.map(c=>`${c} : i32`).join(", ");if(s<1)return`
      fn ${o}() -> ${xe(e)} {
        return ${xe(e)}(${t}[0]);
      }
    `;const u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let l=`${s}D`;return s===0&&(l="1D"),`
    fn ${o}(${a}) -> ${xe(e)} {
      return ${xe(e)}(${t}[getIndexFromCoords${l}(${r}(${i.join(",")}),
        ${u})${e===1?"":` / ${e}`}]);
    }
   `}function SR(n,e,t,s){const r=n.name,o=r.charAt(0).toUpperCase()+r.slice(1),i="get"+o+"ByOutput",a=n.shape.length,u=e.length,l=Ye(u);if(Ae(n.shape,e)&&s)return`
    fn ${i}Index(globalIndex : i32) -> ${xe(t)} {
      return ${xe(t)}(${r}[globalIndex]);
    }

    fn ${i}Coords(coords : ${l}) -> ${xe(t)} {
      return ${xe(t)}(${r}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const c=hr(n.shape,e),d=u-a;let h="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${xe(t)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${l}) -> ${xe(t)}{
      return get${o}();
    }
  `;u<2&&c.length>=1?h="coords = 0;":h=c.map(y=>`coords.${_n(y+d)} = 0;`).join(`
`);let p="";if(u<2&&a>0)p="coords";else if(u>1){const y=Ye(a),x=n.shape.map((w,$)=>`coords.${_n($+d)}`).join(", ");p=`${y}(${x})`}else p="coords";const f=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,g=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${xe(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${h}
    return ${xe(t)}(${r}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }

  fn ${i}Coords(coordsIn : ${l}) -> ${xe(t)} {
    var coords = coordsIn;
    ${h}
    return ${xe(t)}(${r}[getIndexFromCoords${g}(${p}, ${f})${t===1?"":` / ${t}`}]);
  }
`}function $R(n,e,t,s){let r=CR(n,t);return n.shape.length<=e.length&&(r+=SR(n,e,t,s)),r}function IR(n,e){const{x:t,y:s=[],z:r=[]}=e,o=n.length,i=t.length+s.length+r.length;if(i!==o)return"";if(t.length===o)return`fn getOutputCoords() -> ${Ye(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const u=[t,s,r];for(let h=0;h<u.length;h++){const p=u[h];if(p.length!==0)if(p.length===1)a+=`let d${p[0]} = i32(globalId[${h}]);`;else{const f=gR(p,"uniforms.outShape");a+=`var index${h} = i32(globalId[${h}]);`;for(let g=0;g<f.length;g++)a+=`let d${p[g]} = index${h} / ${f[g]};`,g===f.length-1?a+=`let d${p[g+1]} = index${h} - d${p[g]} * ${f[g]};`:a+=`index${h} = index${h} - d${p[g]} * ${f[g]};`}}const l=[];for(let h=0;h<i;h++)l.push(`d${h}`);const c=Ye(i);let d=`fn getOutputCoords() -> ${c} {
  ${a}
`;return l.length===0?d+=`return ${c}(0); }`:d+=`return ${c}(${l.join(",")}); }`,d}function kR(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:T(!1,()=>`Unsupported ${n}D shape`);break}return e}function Fx(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function vs(n,e=1){if(n==="float32")return xe(e,"f32");if(n==="int32"||n==="bool")return xe(e,"i32");throw new Error(`type ${n} is not supported.`)}function NR(n,e,t){const s=n.length,r=vs(e,t);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${xe(t)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${xe(t,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=Ye(s);o+=`
      fn setOutputAtCoords(${i.map(u=>`${u} : i32`).join(", ")}, value : ${xe(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(u=>`${u} : i32`).join(", ")}, value : ${xe(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return o}function TR(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,r,o)=>`vec${r}, @align(16) ${o}`),n}function Bf(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function J(n,e,t=[1,1,1],s=[1,1,1]){const[r,o,i]=[Math.ceil(Ns(n.x.map(a=>e[a]))/(t[0]*s[0])),n.y?Math.ceil(Ns(n.y.map(a=>e[a]))/(t[1]*s[1])):1,n.z?Math.ceil(Ns(n.z.map(a=>e[a]))/(t[2]*s[2])):1];return[r,o,i]}function ER(n,e,t,s=!1){const r=[8,8,1],o=[4,4,1];return s||(n<=8&&(o[1]=1),e<=16&&t<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:o}}function Lx(n,e,t=!1){if(t)return[8,8,1];const s=Ns(n.x.map(o=>e[o])),r=Ns(n.y.map(o=>e[o]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function Bx(n,e,t=!1){if(t)return[4,4,1];const s=Ns(n.x.map(o=>e[o])),r=Ns(n.y.map(o=>e[o]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function se(n){return{x:n.map((e,t)=>t)}}function zf(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function zx(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function Vx(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&T(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var yn;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(yn||(yn={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RR=M().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),_R=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(i=>i<=t))return r;T(r[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(r[0]));return o>t?(o=Math.ceil(Math.cbrt(r[0])),T(o<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Cr extends rl{nextDataId(){return Cr.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!zx())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new pR(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new fR(this.device),this.textureManager=new mR(this.device),this.tensorMap=new rg(this,At()),M().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:t,values:e,refCount:1}),r}move(e,t,s,r,o){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:t,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(M().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),M().getBool("WEBGPU_USE_PROFILE_TOOL")&&(T(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const g=this.readSync(r.real.dataId),y=this.readSync(r.imag.dataId),x=za(mo(g,y).buffer,"float32");return this.convertAndCacheOnCPU(e,x),x}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=t.resource,a=i.size;T(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=a/4,l=new ArrayBuffer(a),c=256,d=256,h=o.map(g=>new OffscreenCanvas(c,d)),p=new OffscreenCanvas(c,d);this.endComputePassEncoder(),h.map((g,y)=>{const x=g.getContext("webgpu");return x.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[y]}),x.getCurrentTexture()}).map((g,y)=>{const x=c*4,w=(L,R,A)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:x,offset:A},{texture:g},{width:L,height:R}),this.submitQueue();const k=p.getContext("2d",{willReadFrequently:!0});k.clearRect(0,0,L,R),k.drawImage(h[y],0,0);const W=k.getImageData(0,0,L,R).data,G=o[y],K=new Uint8ClampedArray(l,A,L*R*4);for(let X=0;X<K.length;X+=4)if(G==="premultiplied")K[X+3]=W[X+3];else{const ee=W[X];K[X]=W[X+2],K[X+1]=W[X+1],K[X+2]=ee}},$=Math.floor(u/(c*d));let S=c,E=d,P=0;for(let L=0;L<$;L++)w(S,E,P),P+=c*d*4;const F=u%(c*d);E=Math.floor(F/c),E>0&&(w(S,E,P),P+=E*(c*4)),S=F%c,S>0&&w(S,1,P)});const f=za(l,t.dtype);return this.convertAndCacheOnCPU(e,f),f}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let r;if(t.dtype==="complex64"){const o=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];r=mo(i,a)}else{const o=await this.getBufferData(t.resource);r=za(o,t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=zf(i.dtype)*H(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),i.resource=r,At().makeTensorFromDataId(o,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:r,shape:o,resource:i}=t;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,u=a.size,l=a.usage,c=this.bufferManager.acquireBuffer(u,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,c,0,u),this.submitQueue();const d=this.makeTensorInfo(o,r),h=At().makeTensorFromTensorInfo(d),p=this.tensorMap.get(d.dataId);return p.resource=c,{tensorRef:h,buffer:c}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Pn(r));return Pe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Pe(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Dn(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Dn(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(o);return a.kernelMs=og(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&So(s[0])&&(s=s.map(o=>Qn(o))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=zf(t.dtype)*H(t.shape);let r;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(r=this.bufferManager.acquireBuffer(s,o,!0),r.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,r,0,s),this.stagingPendingDisposal.push(i)}else{const i=r.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(s,o);t.resource=r}makeUniforms(e){let t=0,s=0;const r=[];let o=1;e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:T(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(l=16),l>o&&(o=l),t=Math.ceil(t/l)*l,s=u.data.length,r.push(t),t+=u.data.length*4}),t=Math.ceil(t/o)*o;const i=new ArrayBuffer(t);e.forEach((u,l)=>{const c=r[l];u.type==="int32"?new Int32Array(i,c,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(i,c,u.data.length).set(u.data):new Float32Array(i,c,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,s,r,o){if(o||(o=this.makeTensorInfo(e.outputShape,s)),H(o.shape)===0)return this.tensorMap.get(o.dataId).values=Sn(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=_R(this.device,e);const i=t.map((u,l)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:e.variableNames[l]}});e.shaderKey=wR(e,i,o);const a=M().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=yR(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,t,r),o}recordAndSubmit(e,t,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=s.concat(t).map(p=>p.shape);const h="int32";i.map(p=>{o.push({type:h,data:p});const f=Xe(p);o.push({type:h,data:f})})}else{const h=Xe(t.shape);o.push({type:a,data:h})}if(e.size){const h=H(e.outputShape);o.push({type:a,data:[e.outputComponent?h/e.outputComponent:h]})}r&&(o=[...o,...r]);const u=[this.tensorToBinding(t),...s.map(h=>this.tensorToBinding(h)),this.makeUniforms(o)];s.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:u.map((h,p)=>({binding:p,resource:h}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const d={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),d.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(d)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(d)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(c||M().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===fr.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=RR){return M().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&H(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Cr.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zx()&&Zg("webgpu",async()=>{const n={powerPreference:M().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const r=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(t),i="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new Cr(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pe;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(pe||(pe={}));const AR="let resultTemp = a + b;",PR="let resultTemp = atan2(a, b);",DR="let resultTemp = areal * breal - aimag * bimag;",OR="let resultTemp = areal * bimag + aimag * breal;",FR="let resultTemp = a / b;",LR="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",BR=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,zR=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,VR=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,MR=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,WR=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,UR=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,GR="return f32(a >= 1.0 && b >= 1.0);",HR=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,jR="return f32(a >= 1.0 || b >= 1.0);",KR=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,XR="let resultTemp = max(a, b);",qR="let resultTemp = min(a, b);",YR=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,QR=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,ZR="let resultTemp = a * b;",JR=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,e3=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,t3=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,n3=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,s3="if (a < 0.0) { return b * a; }  return a;",r3=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,o3="let resultTemp = (a - b) * (a - b);",i3="let resultTemp = a - b;";function Oh(n,e){let t;do{switch(n){case pe.ATAN2:t=PR;break;case pe.MAX:t=XR;break;case pe.MIN:t=qR;break;case pe.MOD:t=e?QR:YR;break;case pe.NOT_EQUAL:t=e?e3:JR;break;case pe.POW:t=e?n3:t3;break;default:continue}let s,r,o;return e?(s="isnanVec4",r="vec4<f32>",o="vec4<bool>"):(s="isnan",r="f32",o="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case pe.ADD:t=AR;break;case pe.COMPLEX_MULTIPLY_IMAG:t=OR;break;case pe.COMPLEX_MULTIPLY_REAL:t=DR;break;case pe.DIV:t=FR;break;case pe.ELU_DER:t=LR;break;case pe.EQUAL:t=BR;break;case pe.FLOOR_DIV:t=zR;break;case pe.GREATER:t=VR;break;case pe.GREATER_EQUAL:t=MR;break;case pe.LESS:t=WR;break;case pe.LESS_EQUAL:t=UR;break;case pe.LOGICAL_AND:return e?HR:GR;case pe.LOGICAL_OR:return e?KR:jR;case pe.MUL:t=ZR;break;case pe.PRELU:return e?r3:s3;case pe.SQUARED_DIFFERENCE:t=o3;break;case pe.SUB:t=i3;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Q;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(Q||(Q={}));const a3="return abs(a);",u3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,l3=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,c3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,d3="return asinh(a);",h3=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,p3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,f3="return ceil(a);",m3="return cos(a);",g3=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,y3="return exp(a) - 1.0;",x3="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",b3=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,w3=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${wh};
  let a1 = ${vh};
  let a2 = ${Ch};
  let a3 = ${Sh};
  let a4 = ${$h};
  let a5 = ${Ih};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,v3="return exp(a);",C3="return floor(a);",S3="return f32(!isnan(a) && !isinf(a));",$3="return f32(isinf(a));",I3="return f32(isnan(a));",k3="return a;",N3=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,T3=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,E3="return f32(!(a >= 1.0));",R3="return -a;",_3="if (a < 0.0) { return uniforms.alpha * a; } return a;",A3=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,P3="return 1.0 / a;",D3="return select(a, 0.0, a < 0.0);",O3="return clamp(a, 0.0, 6.0);",F3="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",L3=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,B3="return round(a);",z3="return inverseSqrt(a);",V3=`
  if (a >= 0.0) {
    return ${bh} * a;
  } else {
    return ${xh} * (exp(a) - 1.0);
  }
`,M3="return 1.0 / (1.0 + exp(-1.0 * a));",W3="return sign(a);",U3="return sin(a);",G3=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,H3=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,j3="return sqrt(a);",K3="return a * a;",X3=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,q3="return tan(a);",Y3=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Q3="return f32(i32((a)));";function ys(n,e){switch(n){case Q.ABS:return a3;case Q.ACOS:return u3;case Q.ACOSH:return l3;case Q.ASIN:return c3;case Q.ASINH:return d3;case Q.ATAN:return h3;case Q.ATANH:return p3;case Q.COS:return m3;case Q.COSH:return g3;case Q.CEIL:return f3;case Q.ELU:return e?b3:x3;case Q.ERF:return w3;case Q.EXP:return v3;case Q.EXPM1:return y3;case Q.FLOOR:return C3;case Q.IS_FINITE:return S3;case Q.IS_INF:return $3;case Q.IS_NAN:return I3;case Q.LINEAR:return k3;case Q.LOG:return N3;case Q.LOG1P:return T3;case Q.LOGICAL_NOT:return E3;case Q.NEG:return R3;case Q.LEAKYRELU:return e?A3:_3;case Q.RECIPROCAL:return P3;case Q.RELU:return e?L3:D3;case Q.RELU6:return e?F3:O3;case Q.ROUND:return B3;case Q.RSQRT:return z3;case Q.SELU:return V3;case Q.SIGMOID:return M3;case Q.SIGN:return W3;case Q.SIN:return U3;case Q.SINH:return G3;case Q.SOFTPLUS:return H3;case Q.SQRT:return j3;case Q.SQUARE:return K3;case Q.STEP:return X3;case Q.TAN:return q3;case Q.TANH:return Y3;case Q.TO_INT:return Q3;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n,e=!1,t=!1,s=3){if(n===null)return"";let r="";if(n==="linear")r=ys(Q.LINEAR);else if(n==="relu")r=ys(Q.RELU,t);else if(n==="elu")r=ys(Q.ELU,t);else if(n==="relu6")r=ys(Q.RELU6,t);else if(n==="prelu")r=Oh(pe.PRELU,t);else if(n==="sigmoid")r=ys(Q.SIGMOID,t);else if(n==="leakyrelu")r=ys(Q.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const i=xe(t?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${s}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:a=`
      fn activation(a : ${i}, coords : vec${s}<i32>) -> ${i} {
        ${r}
      }`,a}function Ms(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(n,e,t=!1,s=!1,r=!1,o=1){T(n&&o===1||!n,()=>`transposeA ${n} is not compatible with component size ${o}`);const i=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${xe(o)} {
    var value = ${xe(o)}(0.0);
    ${t&&r?i:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${xe(o)} {
    var value = ${xe(o)}(0.0);
    ${a}
    return value;
  }
  `}function Fh(n,e,t,s,r=!1,o=!1,i=!1,a=1){return`
  ${Mx(t,s,r,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${xe(a)}) {
    ${r&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ms(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const Z3=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,J3=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",o="";for(let i=0;i<e;i++)r+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function ia(n,e,t=!1,s=32,r=!1,o=32,i=!1){const a=e[1]*n[1],u=e[0]*n[0],l=t?a:s,c=t?s:a,d=l/e[0],h=s/e[1],p=n[1],f=n[0];return T((t&&d===4&&n[1]===4||!t&&(d===3||d===4))&&l%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${d} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${d} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${d}<f32>, ${l/d}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${s}>;

  ${Z()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${f};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${r?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${h};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Z3(t,d)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${h}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${J3(t,d,p,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const Vf=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,e_=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function aa(n,e,t=!1,s=32,r=!1,o=32,i=!1,a=!1){const u=n[1]*e[1],l=n[0]*e[0],c=t?u:s,d=t?s:u;T(d%e[1]===0&&c%e[0]===0&&s%e[1]===0,()=>`tileAHight ${d} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const h=d/e[1],p=c/e[0],f=s/e[1],g=n[1],y=n[0],x=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${Vf(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${y}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${y}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${y}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${y};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${y};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${h};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${h}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Vf(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${y}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${y}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${y}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${e_(t)}
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${y}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;

    ${Z()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${y}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${x}
    }
  `}const t_=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function n_(n,e=!1){T(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Z()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${t_(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}let s_=class{constructor(e,t,s=!1,r=!1,o=null,i=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=s?e[1]:e[2];if(this.isVec4=(l%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const h=ER(t[1],l,t[2],s);this.workgroupSize=h.workgroupSize,this.elementsPerThread=h.elementsPerThread}this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=o!=null,d=a!=null;c&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=r,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=d,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%r===0,a=t%o===0,u=s%this.tileInner===0;return[i,a,u]}getUserCode(){return`
      ${Wn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Fh(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?ia(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?n_(this.workgroupSize,this.transposeA):aa(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r_(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Z()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class o_{constructor(e,t=!1,s=!1,r=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=r!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${Wn(this.activation,this.hasPreluActivationWeights)}
      ${Fh(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${r_(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Z()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class a_{constructor(e,t,s,r=!1,o=!1,i=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const l=i!=null;l&&this.variableNames.push("bias");const c=u!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=o,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${o}`}getUserCode(){return`
      ${Wn(this.activation,this.hasPreluActivationWeights)}
      ${Fh(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${i_(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u_{constructor(e,t,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,T(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=J(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${Mx(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${xe(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${us("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?ia(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):aa(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class l_{constructor(e,t=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${Wn(this.activation,this.hasPreluActivationWeights)}
    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ms(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c_=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function St(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||br(r),o==="string"){const i=Je(o,H(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new c_(s),a=[{type:"float32",data:[r]}];return e.runWebGPUProgram(i,[],o,a)}}const d_={kernelName:rc,backendName:"webgpu",kernelFunc:St};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:r}=t,o=H(s.shape),i=ig(r,o),a=H(i);return T(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:i,dtype:s.dtype}}const h_={kernelName:td,backendName:"webgpu",kernelFunc:ie};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,c=e.shape.length,d=t?n.shape[l-2]:n.shape[l-1],h=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[l-1]:n.shape[l-2],f=s?e.shape[c-2]:e.shape[c-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),x=H(g),w=H(y),S=be(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);T(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[x,d,p]:[x,p,d],P=s?[w,f,h]:[w,h,f],F=ie({inputs:{x:n},backend:r,attrs:{shape:E}}),L=ie({inputs:{x:e},backend:r,attrs:{shape:P}}),R=[F,L],A=Math.max(x,w),k=[F,L],W=[{type:"int32",data:[p]},{type:"int32",data:[f]},{type:"int32",data:[d]}];let G,K;const X=[A,p,f];let ee=M().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(ee<0){const de=M().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),he=de>0?de:r.thresholdToIncreaseWorkgroups,Ce=A*Math.ceil(p/32)*Math.ceil(f/32);Ce<=he||p<=8&&Ce<=he*2?A*p*f<=128?ee=yn.MatMulReduceProgram:A===1&&h>=2e3?ee=yn.MatMulSplitKProgram:ee=yn.MatMulSmallOutputSizeProgram:ee=yn.MatMulPackedProgram}switch(ee){case yn.MatMulReduceProgram:G=new o_(X,t,s,o,u,i);break;case yn.MatMulSplitKProgram:{if(K=St({backend:r,attrs:{shape:X,value:0,dtype:n.dtype}}),G=new u_(X,h,t,s),o||u){K=r.runWebGPUProgram(G,k,n.dtype,W,K);const he=new l_(K.shape,o,u,i);let Ce=null;const Re=[K];o&&Re.push(o),i&&Re.push(i),u==="leakyrelu"&&(Ce=[{type:"float32",data:[a]}],he.uniforms+=" alpha : f32,");const De=r.runWebGPUProgram(he,Re,K.dtype,Ce);R.push(K);const je=ie({inputs:{x:De},backend:r,attrs:{shape:S}});R.push(De);for(const nn of R)r.disposeData(nn.dataId);return je}break}case yn.MatMulSmallOutputSizeProgram:G=new a_(E,P,X,t,s,o,u,i);break;case yn.MatMulPackedProgram:const de=r.adapterInfo.isIntel();G=new s_(E,X,t,s,o,u,i,de);break;default:throw new Error(`Unsupported MatMulProgramType ${ee}.`)}o&&k.push(o),i&&k.push(i),u==="leakyrelu"&&(W.push({type:"float32",data:[a]}),G.uniforms+=" alpha : f32,"),K=r.runWebGPUProgram(G,k,n.dtype,W,K);const ce=ie({inputs:{x:K},backend:r,attrs:{shape:S}});R.push(K);for(const de of R)r.disposeData(de.dataId);return ce}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;return ua({a:r,b:o,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}const f_={kernelName:vi,backendName:"webgpu",kernelFunc:p_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mf=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=be(t,s),this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Oh(this.op,!1)}
      }

      ${Z("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pi=class{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=be(t,s),this.dispatchLayout=se(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4===0,o=s.length>0&&s[s.length-1]%4===0;r&&o?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(Kp(s)||s[s.length-1]===1)||o&&(Kp(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${Oh(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Z("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Z("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pt(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const m_={kernelName:Gi,backendName:"webgpu",kernelFunc:Pt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),i=t.tensorMap.get(o.dataId),a=Pt({inputs:{x:s},backend:t}),u=Pt({inputs:{x:r},backend:t});return i.complexTensorInfos={real:a,imag:u},o}const g_={kernelName:El,backendName:"webgpu",kernelFunc:Ws};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sr=class{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${ys(this.op,!1)}
      }
      ${Z("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ne({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:r})=>{const{x:o}=s,i=r,a=t||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const l=i.tensorMap.get(o.dataId),c=e(l.values,a);return i.makeTensorInfo(o.shape,a,c)}const u=new Sr(o.shape,n);return i.runWebGPUProgram(u,[o],a)}}function st({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:r,backend:o})=>{const{a:i,b:a}=r,u=o;if(t&&i.dtype==="complex64"){const d=u.tensorMap.get(i.dataId),h=u.tensorMap.get(a.dataId);let p,f;if(n!==pe.MUL)[p,f]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(y=>{const[x,w]=y,$={dataId:x.dataId,dtype:x.dtype,shape:i.shape},S={dataId:w.dataId,dtype:w.dtype,shape:a.shape},E=new Pi(n,i.shape,a.shape);return u.runWebGPUProgram(E,[$,S],$t(x.dtype,w.dtype))});else{const y=new Mf(pe.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),x=new Mf(pe.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),w=[{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:i.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:a.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:a.shape}];p=u.runWebGPUProgram(y,w,"float32"),f=u.runWebGPUProgram(x,w,"float32")}const g=Ws({inputs:{real:p,imag:f},backend:u});return u.disposeData(p.dataId),u.disposeData(f.dataId),g}const l=s||$t(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([i,a]))&&e!=null){const d=u.tensorMap.get(i.dataId).values,h=u.tensorMap.get(a.dataId).values,p=i.dtype==="string"?ss(d):d,f=i.dtype==="string"?ss(h):h,[g,y]=e(i.shape,a.shape,p,f,l);return u.makeTensorInfo(y,l,g)}const c=new Pi(n,i.shape,a.shape);return u.runWebGPUProgram(c,[i,a],l)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kt(n){return(e,t,s,r,o)=>{const i=be(e,t),a=i.length,u=Xe(i),l=H(i),c=Sn(o,l),d=e.length,h=t.length,p=Xe(e),f=Xe(t),g=hr(e,i),y=hr(t,i);if(g.length+y.length===0)for(let x=0;x<c.length;++x)c[x]=n(s[x%s.length],r[x%r.length]);else for(let x=0;x<c.length;++x){const w=il(x,a,u),$=w.slice(-d);g.forEach(F=>$[F]=0);const S=mu($,d,p),E=w.slice(-h);y.forEach(F=>E[F]=0);const P=mu(E,h,f);c[x]=n(s[S],r[P])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Ki([0],t),[o,i]=kt((a,u)=>a!==u?1:0)(e,[],n,r,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b_=kt((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(n,e,t,s,r){const o=H(s),i=An(r,t);for(let a=0;a<n.length;a++){const u=n[a];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(o>0?i[u]+=e[a]:i[u]+=1)}return i}function v_(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],i=Pe([r,t],e.dtype);for(let a=0;a<r;a++)for(let u=0;u<o;u++){const l=n.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(s?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C_=kt((n,e)=>n&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(n){return(e,t,s)=>{const r=Je(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S_=Un(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(n,e,t,s){const r=Je(t,H(e));if(s&&t!=="string"){let o=0;n.forEach(i=>{const a=H(i.shape);r.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?ss(i.vals):i.vals;let u=0;for(let l=0;l<i.shape[0];++l){const c=l*e[1]+o;for(let d=0;d<i.shape[1];++d)r[c+d]=a[u++]}o+=i.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_=kt((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_=Un(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_=Un(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T_=Un(n=>Math.floor(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E_=kt((n,e)=>Math.floor(n/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(n,e,t,s,r,o,i,a,u){const l=Pe([s,o],t);for(let c=0;c<s;c++){const d=[];let h=0;for(let p=0;p<r;p++){const f=n[c*r+p];h+=f*i[p],d.push(f)}if(h<0||h>=u/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let p=0;p<o;p++)l.values[c*o+p]=e.get(...e.indexToLoc(h*o+p))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n,e,t){const s=Pe(t,n.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A_=kt((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P_=kt((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D_=kt((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_=kt((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n,e,t){const s=(e-n)/(t-1),r=An(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L_=Un(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(n,e,t,s){const r=Sn(s,H(t));for(let o=0;o<r.length;++o){const i=o*e;let a=n[i];for(let u=0;u<e;++u){const l=n[i+u];(Number.isNaN(l)||l>a)&&(a=l)}r[o]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_=kt((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_=kt((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wx=kt((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(n,e,t){const s=wr(-1,t);return Wx([],e,s,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_=kt((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(n,e,t,s,r){const o=e.length,i=H(e),a=Xe(e),u=Xe(r),l=Sn(t,H(r));for(let c=0;c<i;++c){const d=il(c,o,a),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[s[f]];const p=mu(h,o,u);l[p]=n[c]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(n,e,t,s){const[r,o]=Ut(n,s),i=$t(e,"int32"),a=An(H(r),i),u=H(o);for(let l=0;l<a.length;++l){const c=l*u;let d=1;for(let h=0;h<u;++h)d*=t[c+h];a[l]=d}return{outVals:a,outShape:r,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=il(r,e.length,Xe(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function j_(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function K_(n,e,t,s){const r=[];let o=0;const i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);j_(t,s);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const c=e[l+1];for(let d=1;d<u+1;++d)a[l].push(d*c)}for(let l=0;l<n.length;++l){let c=n[l],d=n[l]+1;for(let h=0;h<t.length;++h){const p=t[h],f=h+e.length-1;if(f>=0){const g=a[f],y=g[g.length-1]-p[c];for(let x=c;x<d;++x)a[f].push(p[x+1]+y)}c=p[c],d=p[d]}d!==c&&(r.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:r,numValues:o}}function X_(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=Je("int32",s);e.push(r),n[t].forEach((o,i)=>r[i]=o)}return e}function Wf(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function q_(n,e,t,s,r,o){const i=Wf(e,2)[1],a=Wf(o,2)[1];let u=0;for(const l of t)for(let c=l[0];c<l[1];++c){for(let d=0;d<s;++d)r[u*a+d]=n[c*i+d];++u}}function Y_(n,e,t,s,r){const o=e.slice();o[0]=r;const i=Je(t,H(o)),a=n.length,u=a===0?0:a/e[0];return q_(n,e,s,u,i,o),[i,o]}function Q_(n,e,t,s,r,o,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(H_(o,i,u),s.length===0)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:c,valueSlices:d,numValues:h}=K_(o,i,n,l),p=X_(c),f=Y_(t,s,r,d,h);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uf=2147483647;function Z_(n,e,t,s,r,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,u=r.length===0,l=i.length===0,c=[];a||c.push(e[0]),u||c.push(r[0]),l||c.push(i[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],h=Je("int32",d+1);h[0]=0;for(let y=0;y<d;++y){const x=a?n[0]:n[y],w=u?s[0]:s[y],$=l?o[0]:o[y];if($===0)throw new Error("Requires delta != 0");let S;if($>0&&w<x||$<0&&w>x)S=0;else if(S=Math.ceil(Math.abs((w-x)/$)),S>Uf)throw new Error(`Requires ((limit - start) / delta) <= ${Uf}`);h[y+1]=h[y]+S}const p=h[d],f=Je(t,p);let g=0;for(let y=0;y<d;++y){const x=h[y+1]-h[y];let w=a?n[0]:n[y];const $=l?o[0]:o[y];for(let S=0;S<x;++S)f[g++]=w,w+=$}return[h,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jt=un;class Di{constructor(e,t,s,r,o,i,a,u,l,c){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=yx(c),this.raggedRank=xx(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===jt.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===jt.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case jt.VALUE_ROWIDS:return Di.getMaxWidthValueRowID(t);case jt.ROW_SPLITS:return Di.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${jt[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let i=1;i<t;++i){const a=e[i];a!==r&&(r=a,o=Math.max(i-s,o),s=i)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Hf(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;bx(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=gx(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let i=0;for(let a=0;a<r;++a,i+=t)o.push(i);for(let a=r;a<e;++a)o.push(-1);return T(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,i=[];for(let a=0;a<o-1;++a){const u=e[a+1]-e[a];let l=Math.min(r,u),c=t[a];c===-1&&(l=0);for(let d=0;d<l;++d)i.push(c),c+=s;for(let d=0;d<u-l;++d)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,i=[];if(o===0)return[];let a=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];i.push(l);for(let c=1;c<o;++c){const d=e[c];if(d===u)l>=0&&(++a,a<r?l+=s:l=-1);else{if(a=0,u=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);l=t[d]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case jt.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case jt.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${jt[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case jt.FIRST_DIM_SIZE:return e[0];case jt.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case jt.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${jt[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const o=Hf(s,!1),i=Je(this.valuesDType,H(o));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,r[l],s[l]);this.setOutput(this.raggedRank,u,i,o)}return[o,i]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,i=s;let a=r.slice();a=a.slice(e+1);const u=H(a),l=t.length;let c=this.defaultValue;if(c.length!==u&&c.length!==1){const f=this.defaultValueShape;fe(()=>{const g=j(c,f);c=to(g,a).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=l;++f){let g=f<l?t[f]:-1;if(g===p){++p;continue}if(h<p){const y=o.subarray(d*u),x=i.subarray(h*u),w=(p-h)*u;Gf(x,y,w)}if(f>=l){const y=s.length;g=Math.floor(y/u)}if(g>p)if(this.defaultValue.length===1)i.subarray(p*u,g*u).fill(this.defaultValue[0]),p=g;else for(;g>p;){const y=i.slice(p*u);Gf(y,c,u),++p}g<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}}function Gf(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function Hf(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function J_(n,e,t,s,r,o,i,a,u,l){return new Di(n,e,t,s,r,o,i,a,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(n,e,t,s){const r=n===e,o=n<e&&t<0,i=e<n&&t>1;if(r||o||i)return An(0,s);const a=Math.abs(Math.ceil((e-n)/t)),u=An(a,s);e<n&&t===1&&(t=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tA=Un(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nA(n,e,t,s,r,o,i,a,u,l){const c=[s/r,r],d=n.values,h=e.values;if(s===0)return Pe(t,e.dtype);const p=u instanceof lr?u:Pe(c,e.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<o;f++){const g=[];let y=0;for(let x=0;x<i;x++){const w=d[f*i+x];g.push(w),y+=w*a[x]}if(y<0||y>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let x=0;x<r;x++)l?p.values[y*r+x]+=h[f*r+x]:p.values[y*r+x]=e.rank===0?h[0]:h[f*r+x]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sA=Un(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(n,e,t,s,r){const o=lh(s,e,t),i=H(t),a=Xe(s);if(o){const d=ch(e,a);return r==="string"?n.slice(d,d+i):n.subarray(d,d+i)}const u=r==="string"?ss(n):n,l=Pe(s,r,u),c=Pe(t,r);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,g)=>f+e[g]);c.set(l.get(...p),...h)}return r==="string"?Ax(c.values):c.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(n,e,t,s,r,o,i){const a=e[0],u=o[0],l=new Array(u),c=new Array(a),d=e[1];if(u===0){if(a!==0)throw new Error(wx(a));const y=Je(t,0),x=Je(r,0);return[y,[0,d],x,l,c]}let h=!0,p=0;const f=new Array(u).fill(0);for(let y=0;y<a;++y){const x=n[y*d];if(x<0)throw new Error(vx(y,x));if(x>=u)throw new Error(Cx(y,x,u));++f[x],h=h&&x>=p,p=x}let g=!0;for(let y=0;y<u;++y){const x=f[y]===0;l[y]=x,g=g&&!x,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&h){const y=n,x=s;for(let w=0;w<a;++w)c[w]=w;return[y,[a,d],x,l,c]}else{const y=f[u-1],x=Je(t,y*d),w=Je(r,y),$=new Array(u).fill(0);for(let S=0;S<a;++S){const E=n[S*d],P=$[E],F=(E===0?0:f[E-1])+P;$[E]++;for(let L=0;L<d;++L)x[F*d+L]=n[S*d+L];w[F]=s[S],c[S]=F}for(let S=0;S<u;++S)if($[S]===0){const P=S===0?0:f[S-1];x[P*d+0]=S;for(let F=1;F<d;++F)x[P*d+F]=0;w[P]=i}return[x,[y,d],w,l,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(n,e,t,s,r){const o=H(s),i=e[0],a=r.length,u=[];let l=1,c=-1;for(let y=0;y<a;++y){const x=r[y];if(x===-1){if(c!==-1)throw new Error(Sx(c,y));c=y,u.push(1)}else{if(x<0)throw new Error($x(y,x));l*=x,u.push(x)}}if(c!==-1){if(l<=0)throw new Error(Ix());const y=Math.trunc(o/l);if(l*y!==o)throw new Error(kx(s,u));u[c]=y}if(H(u)!==o)throw new Error(Nx(s,u));const h=s.length,p=[];if(h>0){p[h-1]=1;for(let y=h-2;y>=0;--y)p[y]=p[y+1]*s[y+1]}const f=[];if(a>0){f[a-1]=1;for(let y=a-2;y>=0;--y)f[y]=f[y+1]*u[y+1]}const g=Je(t,i*a);for(let y=0;y<i;++y){let x=0;for(let w=0;w<h;++w)x+=n[y*h+w]*p[w];for(let w=0;w<a;++w)g[y*a+w]=Math.trunc(x/f[w]),x%=f[w]}return[g,[i,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA(n,e,t,s,r,o=!1,i=0){const a=s.length,u=[e[0],n.length/e[0]],l=u[1],d=a>0?r[a-1]+1:0;if(d<0)throw new Error(Au());const h=e.slice();h[0]=d;const p=h.reduce(($,S)=>$*S,1),f=Je(t,p);if(a===0)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error(Au());let g=0,y=1,x=0,w=r[g];for(;;){let $=0;if(y<a){if($=r[y],w===$){++y;continue}if(w>=$)throw new Error(Tx())}if(w<0||w>=d)throw new Error(Ex(w,d));w>x&&f.fill(i,x*l,w*l);for(let S=g;S<y;++S){const E=s[S];if(E<0||E>=u[0])throw new Error(Rx(S,s[S],u[0]));for(let P=0;P<l;P++)f[w*l+P]+=n[E*l+P]}if(o)for(let S=0;S<l;S++)f[w*l+S]/=y-g;if(g=y,++y,x=w+1,w=$,y>a)break}return x<d&&f.fill(i,x*l,d*l),[f,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uA=Un(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lA=kt((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cA=Un((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(n,e,t,s){const r=Pe(n,e.dtype);for(let o=0;o<r.size;o++){const i=r.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*t[u]+s[u];r.set(e.get(...a),...i)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hA{constructor(e,t,s,r,o,i){this.separator=Qn(e),this.nGramWidths=t,this.leftPad=Qn(s),this.rightPad=Qn(r),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(o-(a+1))),d=i-(l+c),h=t+(l>0?0:a-u);let p=0;p+=l*this.leftPad.length;for(let w=0;w<d;++w)p+=e[h+w].length;p+=c*this.rightPad.length;const f=l+c+d-1;p+=f*this.separator.length,s[r+a]=new Uint8Array(p);const g=s[r+a];let y=0;const x=w=>w.forEach($=>g[y++]=$);for(let w=0;w<l;++w)x(this.leftPad),x(this.separator);for(let w=0;w<d-1;++w)x(e[h+w]),x(this.separator);if(d>0){x(e[h+d-1]);for(let w=0;w<c;++w)x(this.separator),x(this.rightPad)}else{for(let w=0;w<c-1;++w)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<r;++l){let c=t[l]>=u;if(c=c&&t[l]<=s,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${s}]`);u=t[l]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const o=r-1,i=Je("int32",r);if(s===0||r===0){const u=new Array(s);for(let l=0;l<=o;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const l=t[u]-t[u-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}const a=new Array(i[o]);for(let u=0;u<o;++u){const l=t[u];let c=i[u];if(this.nGramWidths.forEach(d=>{const h=t[u+1]-t[u],p=this.getNumNGrams(h,d);this.createNGrams(e,l,a,c,p,d),c+=p}),this.preserveShort&&c===i[u]){const d=t[u+1]-t[u];if(d===0)continue;const h=d+2*this.padWidth;this.createNGrams(e,l,a,c,1,h)}}return[a,i]}}function pA(n,e,t,s,r,o,i,a){return new hA(t,s,r,o,i,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&s.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(r,o);(!t||i.length!==0)&&s.push(i),r=o+1}}function mA(n,e,t){const s=n.length,r=[];let o=0,i=0;const a=new Array(s);for(let h=0;h<s;++h){const p=r.length;fA(n[h],e,t,r);const f=r.length-p;a[h]=f,o+=f,i=Math.max(i,f)}const u=Je("int32",o*2),l=new Array(o),c=[s,i];let d=0;for(let h=0;h<s;++h)for(let p=0;p<a[h];++p)u[d*2]=h,u[d*2+1]=p,l[d]=r[d],++d;return[u,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(n,e){const t=Je("int32",n.length);for(let s=0;s<n.length;++s)t[s]=K1(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yA=kt((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Pe(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),i=new Array(n.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%n.shape[u];const a=n.locToIndex(i);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yr=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Ux(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,u=e-t+1,l=Math.log(a),c=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),h=Math.max(t,Math.floor(e-u*c/a+d)),p=Math.min(s,Math.floor(e+(a-u)*c/a+d));Ux(n,e,h,p)}const r=n[e];let o=t,i=s;for(Ur(n,t,e),Yr(n[s],r)>0&&Ur(n,t,s);o<i;){for(Ur(n,o,i),o++,i--;Yr(n[o],r)<0;)o=o+1;for(;Yr(n[i],r)>0;)i=i-1}Yr(n[t],r)===0?Ur(n,t,i):(i=i+1,Ur(n,i,s)),i<=e&&(t=i+1),e<=i&&(s=i-1)}}function bA(n,e,t,s,r){const o=e[e.length-1],[i,a]=[n.length/o,o],u=Sn(t,i*s),l=Sn("int32",i*s);for(let d=0;d<i;d++){const h=d*a,p=n.subarray(h,h+a);let f=new Array(p.length);p.forEach((w,$)=>f[$]={value:w,index:$}),s<f.length&&(Ux(f,s),f=f.slice(0,s)),r&&f.sort(Yr);const g=d*s,y=u.subarray(g,g+s),x=l.subarray(g,g+s);for(let w=0;w<s;w++)y[w]=f[w].value,x[w]=f[w].index}const c=e.slice();return c[c.length-1]=s,[Pe(c,t,u),Pe(c,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(n,e,t,s){const r=Ue(e,t)[0],o=[1,t[0],1];for(let f=0;f<r;f++)o[0]*=t[f];o[1]=t[r];for(let f=r+1;f<t.length;f++)o[2]*=t[f];const i=new Map,a=new Int32Array(t[r]),u=new lr(o,s,n),l=[],c=o[0]===1&&o[2]===1;for(let f=0;f<t[r];f++){let g;if(c)g=n[f].toString();else{const x=[];for(let w=0;w<o[0];w++)for(let $=0;$<o[2];$++)x.push(u.get(w,f,$));g=x.join(",")}const y=i.get(g);if(y!=null)a[f]=y;else{const x=i.size;i.set(g,x),a[f]=x,l.push(f)}}const d=o.slice();d[1]=i.size;const h=new lr(d,s);l.forEach((f,g)=>{for(let y=0;y<o[0];y++)for(let x=0;x<o[2];x++)h.set(u.get(y,f,x),y,g,x)});const p=t.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gx=Object.freeze(Object.defineProperty({__proto__:null,addImpl:b_,bincountImpl:w_,bincountReduceImpl:v_,bitwiseAndImpl:C_,castImpl:x_,ceilImpl:S_,concatImpl:$_,equalImpl:I_,expImpl:k_,expm1Impl:N_,floorDivImpl:E_,floorImpl:T_,gatherNdImpl:R_,gatherV2Impl:__,greaterEqualImpl:P_,greaterImpl:A_,lessEqualImpl:O_,lessImpl:D_,linSpaceImpl:F_,logImpl:L_,maxImpl:B_,maximumImpl:z_,minimumImpl:V_,multiplyImpl:Wx,negImpl:M_,notEqualImpl:W_,prodImpl:G_,raggedGatherImpl:Q_,raggedRangeImpl:Z_,raggedTensorToTensorImpl:J_,rangeImpl:eA,rsqrtImpl:tA,scatterImpl:nA,sigmoidImpl:sA,simpleAbsImpl:y_,sliceImpl:rA,sparseFillEmptyRowsImpl:oA,sparseReshapeImpl:iA,sparseSegmentReductionImpl:aA,sqrtImpl:uA,squaredDifferenceImpl:lA,staticRegexReplaceImpl:cA,stridedSliceImpl:dA,stringNGramsImpl:pA,stringSplitImpl:mA,stringToHashBucketFastImpl:gA,subImpl:yA,tileImpl:xA,topKImpl:bA,transposeImpl:U_,uniqueImpl:wA},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:vA,castImpl:CA,ceilImpl:SA,concatImpl:$A,equalImpl:IA,expImpl:kA,expm1Impl:NA,floorImpl:TA,floorDivImpl:EA,gatherNdImpl:RA,gatherV2Impl:_A,greaterEqualImpl:AA,greaterImpl:PA,lessEqualImpl:DA,lessImpl:OA,logImpl:FA,maxImpl:LA,maximumImpl:BA,minimumImpl:zA,multiplyImpl:VA,negImpl:MA,notEqualImpl:WA,prodImpl:UA,rangeImpl:GA,rsqrtImpl:HA,scatterImpl:jA,simpleAbsImpl:KA,sliceImpl:XA,stridedSliceImpl:qA,stringNGramsImpl:YA,subImpl:QA,tileImpl:ZA,topKImpl:JA,transposeImpl:eP}=Gx;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tP=Ne({opType:Q.ABS,cpuKernelImpl:KA}),nP={kernelName:ul,backendName:"webgpu",kernelFunc:tP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP=Ne({opType:Q.ACOS}),rP={kernelName:ll,backendName:"webgpu",kernelFunc:sP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oP=Ne({opType:Q.ACOSH}),iP={kernelName:cl,backendName:"webgpu",kernelFunc:oP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aP=st({opType:pe.ADD,cpuKernelImpl:vA,supportsComplex:!0}),uP={kernelName:Wi,backendName:"webgpu",kernelFunc:aP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lP=class{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const t=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Z("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cP(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Pt({inputs:{x:s[0]},backend:t});const r=s.map(a=>a.dtype).reduce((a,u)=>$t(a,u)),o=s.map(a=>a.shape),i=new lP(o);return t.runWebGPUProgram(i,s,r)}const dP={kernelName:dl,backendName:"webgpu",kernelFunc:cP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hP{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){T(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Z()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pP=class{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ye(this.outputShape.length),t=Hx(this.newDim);return`
      ${Z("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function Hx(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${_n(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $n(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,i=t,a=r.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=r.shape[o[c]];if(t.shouldExecuteOnCPU([r])){const d=i.tensorMap.get(r.dataId).values,h=eP(d,r.shape,r.dtype,o,u);return t.makeTensorInfo(u,r.dtype,h)}if(r.shape.length===2&&Ae(o,[1,0])){const c=new hP(r.shape,o);return i.runWebGPUProgram(c,[r],r.dtype)}const l=new pP(r.shape,o);return i.runWebGPUProgram(l,[r],r.dtype)}const fP={kernelName:eo,backendName:"webgpu",kernelFunc:$n};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mP=class{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Ut(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Z("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP={mean:"float32",all:"bool",any:"bool"};function Us(n,e,t,s,r){const o=n.shape.length,i=[],a=Ue(e,n.shape);let u=a;const l=dt(u,o);let c=n;l!=null&&(c=$n({inputs:{x:n},attrs:{perm:l},backend:r}),u=ht(u.length,o),i.push(c)),Lt(s,u,o);const[d,h]=Ut(c.shape,u);let p=d;t&&(p=Ft(d,a));let f;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([c])){const g=r.tensorMap.get(c.dataId).values;switch(s){case"max":const y=LA(g,H(h),p,n.dtype);f=r.makeTensorInfo(p,n.dtype,y);break;case"prod":const{outVals:x,outShape:w,outDtype:$}=UA(c.shape,c.dtype,g,u);f=r.makeTensorInfo(w,$,x);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const g=H(h),x=H(c.shape)/g,w={windowSize:g,inSize:g,batchSize:x,outSize:1},$=gP[s]||Xi(n.dtype),S=[{type:"int32",data:[g]}],E=new mP(w,s,r.device.limits.maxComputeWorkgroupSizeX),P=r.runWebGPUProgram(E,[c],$,S);i.push(P),f=ie({inputs:{x:P},attrs:{shape:p},backend:r})}return i.forEach(g=>r.disposeData(g.dataId)),f}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:o,axis:i}=s;return Us(r,i,o,"all",t)}const xP={kernelName:hl,backendName:"webgpu",kernelFunc:yP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:o,axis:i}=s;return Us(r,i,o,"any",t)}const wP={kernelName:pl,backendName:"webgpu",kernelFunc:bP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jx=class{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op=s==="min"?"<":">";const[o,i]=Ut(e,r);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=se(this.outputShape),H(i)<32?(this.type="plain",this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=J(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${_n(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)r+=`outputCoords.${_n(o)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Z("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Z("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Ue(o,r.shape);const a=dt(i,r.shape.length);let u=r;const l=[];a!=null&&(u=$n({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),i=ht(i.length,u.shape.length)),Lt("argMax",[i[0]],u.shape.length);const c=new jx(u.shape,i[0],"max"),d=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=t.runWebGPUProgram(c,[u],"int32",d);return l.forEach(p=>t.disposeData(p.dataId)),h}const CP={kernelName:fl,backendName:"webgpu",kernelFunc:vP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Ue(o,r.shape);const a=dt(i,r.shape.length);let u=r;const l=[];a!=null&&(u=$n({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),i=ht(i.length,u.shape.length)),Lt("argMin",[i[0]],u.shape.length);const c=new jx(u.shape,i[0],"min"),d=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=t.runWebGPUProgram(c,[u],"int32",d);return l.forEach(p=>t.disposeData(p.dataId)),h}const $P={kernelName:ml,backendName:"webgpu",kernelFunc:SP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP=Ne({opType:Q.ASIN}),kP={kernelName:gl,backendName:"webgpu",kernelFunc:IP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP=Ne({opType:Q.ASINH}),TP={kernelName:yl,backendName:"webgpu",kernelFunc:NP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP=Ne({opType:Q.ATAN}),RP={kernelName:xl,backendName:"webgpu",kernelFunc:EP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P=st({opType:pe.ATAN2}),AP={kernelName:wl,backendName:"webgpu",kernelFunc:_P};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=Ne({opType:Q.ATANH}),DP={kernelName:bl,backendName:"webgpu",kernelFunc:PP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OP{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let go=class{constructor(e,t,s=!1,r=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=o,this.shaderKey=`pool2D_${t}_${s}_${r}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}},Lh=class{constructor(e,t,s=!1,r=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=o,this.shaderKey=`pool3D_${t}_${s}_${r}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s;return Us(r,o,i,"max",t)}const FP={kernelName:Tc,backendName:"webgpu",kernelFunc:Kx};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xx(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{keepDims:o,axis:i}=s;return Us(r,i,o,"mean",t)}const LP={kernelName:Pc,backendName:"webgpu",kernelFunc:Xx};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&Ae(e.inShape,e.outShape))return Pt({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=n.shape.length,a=ie({inputs:{x:n},backend:s,attrs:{shape:[n.shape[i-3]*n.shape[i-2],n.shape[i-1]]}});let u;t==="avg"?u=Xx({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(T(t==="max",()=>`Invalid pool type ${t}`),u=Kx({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const l=ie({inputs:{x:u},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(u.dataId),l}let r;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new OP(e):(t==="avg"?r=new go(e,"avg"):(T(t==="max",()=>`Invalid pool type ${t}`),r=new go(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[n],n.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,c=Jt(r.shape,o,i,1,a,u);return qx(r,c,"avg",t)}const zP={kernelName:vl,backendName:"webgpu",kernelFunc:BP};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],d=Vn(r.shape,o,i,c,a,l,u),h=new Lh(d,"avg"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return t.runWebGPUProgram(h,[r],r.dtype,p)}const MP={kernelName:Cl,backendName:"webgpu",kernelFunc:VP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let WP=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},UP=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,d=Vn(i.shape,a,u,1,l,c),h=new UP(d),p=1/(d.filterDepth*d.filterHeight*d.filterWidth),f=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return t.runWebGPUProgram(h,[r],i.dtype,f)}const HP={kernelName:pg,backendName:"webgpu",kernelFunc:GP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;Vx([r,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Jt(i.shape,a,u,1,l),d=new WP(c),h=1/(c.filterHeight*c.filterWidth),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[h]}];return t.runWebGPUProgram(d,[r],i.dtype,p)}const KP={kernelName:hg,backendName:"webgpu",kernelFunc:jP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return ua({a:r,b:o,transposeA:i,transposeB:a,backend:t})}const qP={kernelName:Sl,backendName:"webgpu",kernelFunc:XP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YP=class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ye(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ye(this.rank),t=QP(this.rank);let s;return this.start.length===1?s=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((o,i)=>`sourceLoc.${Gu[i]} = uniforms.start.${_n(i)} + coords.${Gu[i]};`),`
      ${Z("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}};const Gu=["x","y","z","w","u","v"];function QP(n){if(n===1)return"sourceLoc";if(n<=6)return Gu.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s,[a,u]=dh(r,o,i);if(ah(r,a,u),t.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=t.tensorMap.get(r.dataId),h=XA(d.values,a,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,h)}if(H(u)===0)return t.makeTensorInfo(u,r.dtype,[]);const l=new YP(a,u),c=[{type:"int32",data:a}];return t.runWebGPUProgram(l,[r],r.dtype,c)}const ZP={kernelName:pd,backendName:"webgpu",kernelFunc:$r};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;T(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,$)=>w*$),u=To(r.shape,o,a),l=Eo(u.length,o.length),c=Ro(r.shape,o,a),d=gh(i,o.length),h=yh(c,i,o.length),p=[],f=ie({inputs:{x:r},backend:t,attrs:{shape:u}}),g=$n({inputs:{x:f},backend:t,attrs:{perm:l}}),y=ie({inputs:{x:g},backend:t,attrs:{shape:c}}),x=$r({inputs:{x:y},backend:t,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(y),p.forEach(w=>t.disposeData(w.dataId)),x},eD={kernelName:$l,backendName:"webgpu",kernelFunc:JP};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=`
  fn bincount_write(index: i32, value: f32) {
    ${us("&result[index]","value","float32")}
  }
`,nD=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class Yx{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?nD:tD}
  ${Z("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=H(r.shape),l=H(o.shape)>0,c=[i],d=o.dtype,h=St({backend:t,attrs:{shape:c,value:0,dtype:d}}),p=new Yx([a],l),f=[{type:"int32",data:[i]}],g=l?[r,o]:[r];return t.runWebGPUProgram(p,g,d,f,h)}const rD={kernelName:Il,backendName:"webgpu",kernelFunc:sD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oD{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Z("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e;if(t.shouldExecuteOnCPU([s,r])){const c=t.tensorMap.get(s.dataId),d=t.tensorMap.get(r.dataId),h=c.values,p=d.values,f=be(Array.from(h),Array.from(p));return t.makeTensorInfo([f.length],"int32",Int32Array.from(f))}const o=H(s.shape),i=H(r.shape),a=Math.max(o,i),u=new oD(a),l=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return t.runWebGPUProgram(u,[s,r],"int32",l)}const aD={kernelName:kl,backendName:"webgpu",kernelFunc:iD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qx=st({opType:pe.NOT_EQUAL,dtype:"bool",cpuKernelImpl:WA}),uD={kernelName:Mc,backendName:"webgpu",kernelFunc:Qx};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return Pt({inputs:{x:r.complexTensorInfos.real},backend:t})}const lD={kernelName:Zc,backendName:"webgpu",kernelFunc:_o};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(n,e){const t=new Sr(n.shape,Q.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Pt({inputs:{x:r},backend:t});const i=Bn(r.shape),a=Hu({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Ws({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeData(a.dataId),u}if(r.dtype==="complex64"){const i=_o({inputs:{input:r},backend:t}),a=Hu({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeData(i.dataId),a}if(!ag(r.dtype,o)){const i=Pt({inputs:{x:r},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const i=t.tensorMap.get(r.dataId).values,[a,u,l]=CA(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,u,l)}if(o==="int32")return cD(r,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Sn("bool",1)),u=Qx({inputs:{a:r,b:i},backend:t});return t.disposeData(i.dataId),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const dD={kernelName:Ui,backendName:"webgpu",kernelFunc:Hu};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hD=Ne({opType:Q.CEIL,cpuKernelImpl:SA}),pD={kernelName:Nl,backendName:"webgpu",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fD{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Z("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mD=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Z("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;const u=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return H(r.shape)%4===0?a=new fD(r.shape):a=new mD(r.shape),t.runWebGPUProgram(a,[r],r.dtype,u)}const yD={kernelName:Tl,backendName:"webgpu",kernelFunc:gD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xD=class{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jf(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function bD(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.tensorMap.get(s.dataId),o=new xD(s.shape),i=[jf(s,r.complexTensorInfos.real),jf(s,r.complexTensorInfos.imag)];return t.runWebGPUProgram(o,i,i[0].dtype)}const wD={kernelName:Rl,backendName:"webgpu",kernelFunc:bD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vD=class{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Zt(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Z("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function la(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.tensorMap.get(s.dataId);return Pt({inputs:{x:r.complexTensorInfos.imag},backend:t})}const CD={kernelName:fc,backendName:"webgpu",kernelFunc:la};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(n,e,t){const s=n[0].dtype;if(s==="complex64"){const f=n.map($=>_o({inputs:{input:$},backend:t})),g=n.map($=>la({inputs:{input:$},backend:t})),y=Qr(f,e,t),x=Qr(g,e,t),w=Ws({inputs:{real:y,imag:x},backend:t});return f.forEach($=>t.disposeData($.dataId)),g.forEach($=>t.disposeData($.dataId)),t.disposeData(y.dataId),t.disposeData(x.dataId),w}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const f=n.map(E=>{const F=[-1,H(E.shape.slice(e))];return ie({inputs:{x:E},backend:t,attrs:{shape:F}})}),g=f.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),y=Zt(f.map(E=>E.shape),1),x=f[0].shape[0]===1,w=$A(g,y,s,x),$=Zt(n.map(E=>E.shape),e),S=t.makeTensorInfo($,s,w);return f.forEach(E=>t.disposeData(E.dataId)),S}const o=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>o){const f=[];for(let y=0;y<n.length;y+=o){const x=n.slice(y,y+o);f.push(Qr(x,e,t))}const g=Qr(f,e,t);for(const y of f)t.disposeData(y.dataId);return g}const{tensors2D:i,outShape:a}=SD(n,e,t),u=i.map(f=>f.shape),l=new vD(u),c=[],d=new Array(u.length-1);if(d.length>0){d[0]=u[0][1],c.push({type:"int32",data:[d[0]]});for(let f=1;f<d.length;f++)d[f]=d[f-1]+u[f][1],c.push({type:"int32",data:[d[f]]})}const h=t.runWebGPUProgram(l,i,i[0].dtype,c);i.forEach(f=>t.disposeData(f.dataId));const p=ie({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeData(h.dataId),p}function SD(n,e,t){const s=Zt(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>ie({inputs:{x:o},backend:t,attrs:{shape:[H(o.shape.slice(0,e)),H(o.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Ue(r,e[0].shape)[0],i=e.map(l=>l.shape);ph(i,o);const a=Zt(e.map(l=>l.shape),o);if(H(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>H(l.shape)>0);return u.length===1?Pt({inputs:{x:u[0]},backend:t}):Qr(u,o,t)}const $D={kernelName:_l,backendName:"webgpu",kernelFunc:Zx};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n,e,t,s,r=!1,o=null,i=!1,a=4,u=4,l=4){const c=R=>{switch(R){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${R} is not supported.`)}},d=R=>{switch(R){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${R} is not supported.`)}},h=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,p=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=n?"uniforms.xShape[1]":"uniforms.xShape[2]",g=n?"uniforms.xShape[2]":"uniforms.xShape[3]",y=n?"row":"col",x=n?"col":"row",w=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${y} / outWidth;
      let outCol = ${y} % outWidth;

      let WRow = ${x} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${x} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${x} % inChannels;
      var resData = ${xe(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${g}) {
        ${h}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,$=n?e&&s?`
      ${w}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${w}
      }
      return ${xe(a)}(0.0);`:s&&t?`
      ${w}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${w}
      }
      return ${xe(a)}(0.0);`,S=`${d(u)}`,E=xe(l),P=xe(n?a:u),F=xe(n?u:a);return`
      ${Wn(o,i,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${P} {
        ${n?$:S}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${F} {
        ${n?S:$}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${E}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${p}
        ${Ms(r,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class kD{constructor(e,t,s,r,o=!1,i=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Lx(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Bx(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?ia(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):aa(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ID(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ND{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Wn(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Ms(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Z("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TD{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Z("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function ED({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=t.dataFormat==="channelsLast",l=!u,c=!1,d=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",h=[];let p,f;if(d){const x=t.inHeight*t.inWidth*t.inChannels;p=ie({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,x]}}),f=ie({inputs:{x:e},backend:s,attrs:{shape:[1,x,t.outChannels]}})}else p=ie({inputs:{x:n},backend:s,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),f=ie({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(h.push(p),h.push(f),o!=null){const x=Oi(o.shape,u);x!=null&&(o=ie({inputs:{x:o},backend:s,attrs:{shape:x}}),h.push(o))}if(r!=null){const x=Oi(r.shape,u);x!=null&&(r=ie({inputs:{x:r},backend:s,attrs:{shape:x}}),h.push(r))}const g=ua({a:u?p:f,b:u?f:p,transposeA:l,transposeB:c,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),y=ie({inputs:{x:g},backend:s,attrs:{shape:t.outShape}});h.push(g);for(const x of h)s.disposeData(x.dataId);return y}function RD({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:d,strideHeight:h,padInfo:p,outWidth:f,outHeight:g,dilationWidth:y,dilationHeight:x,dataFormat:w}=t,$=w==="channelsLast",S=u*l*c,E=g*f,P=$?[t.batchSize,E,S]:[t.batchSize,S,E],F=new TD(P,$),L=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[h,d]},{type:"int32",data:[x,y]},{type:"int32",data:[f]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],R=s.runWebGPUProgram(F,[n],n.dtype,L),A=[];A.push(R);const k=ie({inputs:{x:e},backend:s,attrs:{shape:[1,S,-1]}});if(A.push(k),o!=null){const ee=Oi(o.shape,$);ee!=null&&(o=ie({inputs:{x:o},backend:s,attrs:{shape:ee}}),A.push(o))}if(r!=null){const ee=Oi(r.shape,$);ee!=null&&(r=ie({inputs:{x:r},backend:s,attrs:{shape:ee}}),A.push(r))}const K=ua({a:$?R:k,b:$?k:R,transposeA:!$,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),X=ie({inputs:{x:K},backend:s,attrs:{shape:t.outShape}});A.push(K);for(const ee of A)s.disposeData(ee.dataId);return X}function Jx({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=r!=null,l=o!=null,c=t.dataFormat==="channelsLast",d=c&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",h=M().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!h&&(d||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return ED({x:n,filter:e,convInfo:t,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const p=M().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=p>-1?p:s.thresholdToIncreaseWorkgroups,g=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(M().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=f)return RD({x:n,filter:e,convInfo:t,backend:s,bias:r,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let y;const x=[t.padInfo.top,t.padInfo.left],w=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(h)y=new ND(t,u,a,l);else{const P=c?t.outHeight*t.outWidth:t.outChannels,F=c?t.outChannels:t.outHeight*t.outWidth,L=t.filterHeight*t.filterWidth*t.inChannels;w.push({type:"int32",data:[P]},{type:"int32",data:[F]},{type:"int32",data:[L]});const R=s.adapterInfo.isIntel();y=new kD(t,P,F,L,u,a,l,R)}const $=[],S=[n,e];u&&(!c&&r.shape.length===1&&(r=ie({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),$.push(r)),S.push(r)),l&&(!c&&o.shape.length===1&&(o=ie({inputs:{x:o},backend:s,attrs:{shape:[o.shape[0],1,1]}}),$.push(o)),S.push(o)),a==="leakyrelu"&&(w.push({type:"float32",data:[i]}),y.uniforms+=" alpha : f32,");const E=s.runWebGPUProgram(y,S,n.dtype,w);for(const P of $)s.disposeData(P.dataId);return E}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n){const{inputs:e,attrs:t,backend:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=t,d=hn(u),h=Ze(r.shape,o.shape,i,l,a,c,!1,d);return Jx({x:r,filter:o,convInfo:h,backend:s})}const AD={kernelName:Al,backendName:"webgpu",kernelFunc:_D};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PD=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${Z()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${Z("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},DD=class{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Z("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},OD=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Z("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},FD=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Z("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,d=hn(u),h=Ze(r.shape,c,i,1,a,l,!1,d),p=new DD(h),f=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]}];return t.runWebGPUProgram(p,[r,o],r.dtype,f)}const BD={kernelName:Pl,backendName:"webgpu",kernelFunc:LD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${xe(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${xe(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${xe(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${xe(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${xe(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${xe(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${xe(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class VD{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,T(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Lx(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Bx(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?ia(this.elementsPerThread,this.workgroupSize):aa(this.elementsPerThread,this.workgroupSize);return`
    ${zD(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s,d=hn(l),h=Ze(i,o.shape,a,1,u,c,!1,d),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize,h.outHeight,h.outWidth,h.outChannels]}];let f;if(M().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||h.dataFormat!=="channelsLast")f=new PD(h);else{f=new VD(h);const g=h.inHeight*h.inWidth,y=h.inChannels,x=h.filterHeight*h.filterWidth*h.outChannels;p.push({type:"uint32",data:[g]},{type:"uint32",data:[y]},{type:"uint32",data:[x]})}return t.runWebGPUProgram(f,[r,o],"float32",p)}const WD={kernelName:Dl,backendName:"webgpu",kernelFunc:MD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UD{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=as(r.shape,o.shape,i,u,a),c=[l.padInfo.front,l.padInfo.top,l.padInfo.left],d=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],h=new UD(l),p=$t(r.dtype,o.dtype);return t.runWebGPUProgram(h,[r,o],p,d)}const HD={kernelName:Ol,backendName:"webgpu",kernelFunc:GD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jD(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:u}=s,l=as(r.shape,u,i,1,a),c=new OD(l),d=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return t.runWebGPUProgram(c,[r,o],o.dtype,d)}const KD={kernelName:mg,backendName:"webgpu",kernelFunc:jD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,pad:a,inputShape:u}=s,l=as(u,o.shape,i,1,a),c=new FD(l),d=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return t.runWebGPUProgram(c,[r,o],r.dtype,d)}const qD={kernelName:Fl,backendName:"webgpu",kernelFunc:XD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD=Ne({opType:Q.COS}),QD={kernelName:Ll,backendName:"webgpu",kernelFunc:YD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD=Ne({opType:Q.COSH}),JD={kernelName:Bl,backendName:"webgpu",kernelFunc:ZD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eO=class{constructor(e,t,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=t;this.outputShape=[o,s[0],s[1],e],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tO=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=s,c=new eO(r.shape[3],o.shape,a,u),d=[{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[r,o,i],"float32",d)},nO={kernelName:Ml,backendName:"webgpu",kernelFunc:tO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yo;(function(n){n.Prod="*",n.Sum="+"})(yo||(yo={}));let Kf=class{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===yo.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${Xf(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${r-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${r}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${Z("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${qf(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${qf(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${Xf(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function Xf(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function qf(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0(n,e,t,s,r,o){const i=e.shape.length,a=dt([s],i);let u=e;a!=null&&(u=$n({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=ht(1,i)[0];if(l!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=u.shape[l];let d=Pt({inputs:{x:u},backend:t});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new Kf(n,u.shape,!1,o),f=d,g=[{type:"float32",data:[h]}];d=t.runWebGPUProgram(p,[d],d.dtype,g),t.disposeData(f.dataId)}if(r){const h=new Kf(n,u.shape,r,o),p=d,f=[{type:"float32",data:[0]}];d=t.runWebGPUProgram(h,[d],d.dtype,f),t.disposeData(p.dataId)}if(a!=null){const h=No(a),p=$n({inputs:{x:d},backend:t,attrs:{perm:h}});return t.disposeData(d.dataId),t.disposeData(u.dataId),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return e0(yo.Prod,r,t,o,i,a)}const rO={kernelName:zl,backendName:"webgpu",kernelFunc:sO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return e0(yo.Sum,r,t,o,i,a)}const iO={kernelName:Vl,backendName:"webgpu",kernelFunc:oO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s,u=r.shape.length===1,c=H(o.shape)>0,d=o.dtype,h=u?[r.shape[0]]:[r.shape[0],r.shape[1]],p=u?[i]:[r.shape[0],i],f=St({backend:t,attrs:{shape:p,value:0,dtype:d}}),g=new Yx(h,c,a),y=[{type:"int32",data:[i]}],x=c?[r,o]:[r];return t.runWebGPUProgram(g,x,d,y,f)}const uO={kernelName:Wl,backendName:"webgpu",kernelFunc:aO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lO=class{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],l=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],d=u*o,h=l*o,p=c/(o*o),f=i==="NHWC"?[a,d,h,p]:[a,p,d,h],g=[{type:"int32",data:[o]}],y=new lO(f,i);return t.runWebGPUProgram(y,[r],r.dtype,g)}const dO={kernelName:Ul,backendName:"webgpu",kernelFunc:cO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hO{constructor(e,t,s,r=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=o,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Wn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Z()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ms(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t0{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=se(o),this.dispatch=J(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),T(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${Wn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Z("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ms(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n0=class{constructor(e,t=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Wn(this.activation,this.hasPreluActivation,!1,4)}

      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Ms(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s,d=hn(u);let h=l;h==null&&(h=[1,1]);const p=Ze(r.shape,o.shape,i,h,a,c,!0,d),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],g=p.dataFormat==="channelsLast";let y;return!g&&p.inHeight>16&&p.inWidth>16&&p.strideHeight===1&&p.strideWidth===1&&p.dilationWidth===1&&p.dilationHeight===1&&p.inChannels===p.outChannels?y=new hO(p.outShape,p.filterHeight,p.filterWidth):g&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4===0?(y=new t0(p),f.push({type:"int32",data:[y.virtualWidth]})):(y=new n0(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),t.runWebGPUProgram(y,[r,o],r.dtype,f)}const fO={kernelName:Gl,backendName:"webgpu",kernelFunc:pO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mO=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},gO=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s,d=Ze(r.shape,c,i,a,u,l,!0),h=new mO(d),p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outChannels/d.inChannels]}];return t.runWebGPUProgram(h,[r,o],"float32",p)}const xO={kernelName:Hl,backendName:"webgpu",kernelFunc:yO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s,d=Ze(c,o.shape,i,a,u,l,!0),h=new gO(d),p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.outChannels/d.inChannels]}];return t.runWebGPUProgram(h,[r,o],r.dtype,p)}const wO={kernelName:jl,backendName:"webgpu",kernelFunc:bO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vO=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=H(s.shape),i=ie({inputs:{x:s},backend:t,attrs:{shape:[o]}}),a=new vO(o),u=t.runWebGPUProgram(a,[i],i.dtype),l=ie({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeData(i.dataId),t.disposeData(u.dataId),l}const SO={kernelName:Kl,backendName:"webgpu",kernelFunc:CO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $O=class{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Z("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=Io(r.shape,o.shape,i,a,"NHWC",u),c=[l.padInfo.top,l.padInfo.left],d=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],h=new $O(l);return t.runWebGPUProgram(h,[r,o],r.dtype,d)}const kO={kernelName:Xl,backendName:"webgpu",kernelFunc:IO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NO{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=se(e.outShape),this.dispatch=J(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Z("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${us("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class TO{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=se(e.outShape),this.dispatch=J(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Z("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${us("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=s,c=Io(r.shape,o.shape,a,u,"NHWC",l),d=o.dtype,h=new TO(c,o.shape,d),p=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[H(c.outShape)]}],f=St({backend:t,attrs:{shape:o.shape,value:0,dtype:d}});return t.runWebGPUProgram(h,[r,o,i],d,p,f)}const RO={kernelName:B1,backendName:"webgpu",kernelFunc:EO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=s,c=Io(r.shape,o.shape,a,u,"NHWC",l),d=r.dtype,h=new NO(c,d),p=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[H(c.outShape)]}],f=St({backend:t,attrs:{shape:c.inShape,value:0,dtype:d}});return t.runWebGPUProgram(h,[r,o,i],d,p,f)}const AO={kernelName:L1,backendName:"webgpu",kernelFunc:_O};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PO{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=fr.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Z("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:o,options:i}=s,[a,u]=r.shape.slice(0,2),{imageOptions:l}=i||{},c=(l==null?void 0:l.alpha)||1,d=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",h=[a,u],p=new PO(h,r.dtype,d);o.width=u,o.height=a;const f="webgpu";let g=o.getContext(f),y;g||(y=new OffscreenCanvas(u,a),g=y.getContext(f));const x=r.shape.length===3?r.shape[2]:1;g.configure({device:t.device,format:d,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const w="int32",$=t.makeTensorInfo(h,w),S=t.tensorMap.get($.dataId);S.resource=g.getCurrentTexture(),S.external=!0;const E=[{type:"uint32",data:[x]},{type:"float32",data:[c]}];if(t.runWebGPUProgram(p,[r],w,E,$),y){const P=o.getContext("2d");if(!P)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");P.drawImage(y,0,0)}return t.disposeData($.dataId),r}const OO={kernelName:gg,backendName:"webgpu",kernelFunc:DO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s0=st({opType:pe.MUL,cpuKernelImpl:VA,supportsComplex:!0}),FO={kernelName:zc,backendName:"webgpu",kernelFunc:s0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return Us(r,o,i,"sum",t)}const LO={kernelName:wd,backendName:"webgpu",kernelFunc:r0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BO(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:u}=kh(r,o.length);Th(i.length,u,o);const{path:l,steps:c}=Eh(a,u),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const y of c[g]){const{permutationIndices:x,expandDims:w}=Nh(p,u[y]);let $;Rh(x)?$=o[y]:($=$n({inputs:{x:o[y]},backend:t,attrs:{perm:x}}),f.push($));const S=$.shape.slice();for(let E=0;E<w.length;++E)S.splice(w[E],0,1);Ae($.shape,S)||($=ie({inputs:{x:$},backend:t,attrs:{shape:S}}),f.push($)),h===null?h=$:(h=s0({inputs:{a:$,b:h},backend:t}),f.push(h))}g<d-1&&(l[g]>=0&&(h=r0({inputs:{x:h},backend:t,attrs:{axis:l[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&t.disposeData(g.dataId);return h}const zO={kernelName:Yl,backendName:"webgpu",kernelFunc:BO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO=Ne({opType:Q.ELU}),MO={kernelName:Ql,backendName:"webgpu",kernelFunc:VO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WO=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=new Pi(pe.ELU_DER,s.shape,r.shape);return t.runWebGPUProgram(o,[s,r],s.dtype)},UO={kernelName:yg,backendName:"webgpu",kernelFunc:WO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO=st({opType:pe.EQUAL,dtype:"bool",cpuKernelImpl:IA}),HO={kernelName:Jl,backendName:"webgpu",kernelFunc:GO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO=Ne({opType:Q.ERF}),KO={kernelName:Zl,backendName:"webgpu",kernelFunc:jO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XO=Ne({opType:Q.EXP,cpuKernelImpl:kA,dtype:"float32"}),qO={kernelName:ec,backendName:"webgpu",kernelFunc:XO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ju(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=r;return r<0&&(T(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),a.splice(u,0,1),ie({inputs:{x:o},backend:s,attrs:{shape:a}})}const YO={kernelName:tc,backendName:"webgpu",kernelFunc:ju};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QO=Ne({opType:Q.EXPM1,cpuKernelImpl:NA}),ZO={kernelName:nc,backendName:"webgpu",kernelFunc:QO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yf=class{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0(n,e,t){const s=t.tensorMap.get(n.dataId),r=H(n.shape),o=n.shape[n.shape.length-1],i=r/o,a=[],u=ie({inputs:{x:n},backend:t,attrs:{shape:[i,o]}});a.push(u);const l=u.shape,c=new Yf("real",l),d=new Yf("imag",l),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=e?2*Math.PI:-2*Math.PI,f=e?l[1]:1,g=[{type:"float32",data:[p]},{type:"float32",data:[f]}],y=t.runWebGPUProgram(c,h,"float32",g);a.push(y);const x=t.runWebGPUProgram(d,h,"float32",g);a.push(x);const w=Ws({inputs:{real:y,imag:x},backend:t});a.push(w);const $=ie({inputs:{x:w},backend:t,attrs:{shape:n.shape}});return a.forEach(S=>t.disposeData(S.dataId)),$}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(n){const{inputs:e,backend:t}=n,{input:s}=e;return o0(s,!1,t)}const eF={kernelName:sc,backendName:"webgpu",kernelFunc:JO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tF=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nF={kernelName:oc,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new tF(t.shape);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sF=Ne({opType:Q.FLOOR,cpuKernelImpl:TA}),rF={kernelName:ic,backendName:"webgpu",kernelFunc:sF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oF=st({opType:pe.FLOOR_DIV,cpuKernelImpl:EA,dtype:"int32"}),iF={kernelName:ac,backendName:"webgpu",kernelFunc:oF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aF=class{constructor(e,t,s=!1){this.pixelsOpType=fr.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Z("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF={kernelName:wi,backendName:"webgpu",kernelFunc:lF};let Qs,qa=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function lF(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[c,d]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[d,c,o],p=M().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,f=i||a;if(l||u||f){let w;if(p)w=t.device.importExternalTexture({source:r});else{if(f){const G=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Qs==null||G!==qa)&&(qa=G,Qs=document.createElement("canvas").getContext("2d",{willReadFrequently:qa})),Qs.canvas.width=c,Qs.canvas.height=d,Qs.drawImage(r,0,0,c,d),r=Qs.canvas}const A=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,W=t.textureManager.acquireTexture(h[1],h[0],"rgba8unorm",A);t.queue.copyExternalImageToTexture({source:r},{texture:W},[h[1],h[0]]),w=W}const $=H(h),S=Xe(h),E=new aF(h,o,p),P=[{type:"uint32",data:[$]},{type:"uint32",data:[o]},{type:"uint32",data:[...S]}],F=t.makeTensorInfo([d,c],"int32"),L=t.tensorMap.get(F.dataId);L.resource=w;const R=t.runWebGPUProgram(E,[F],"int32",P);return t.disposeData(F.dataId),R}const g=r.data;let y=g;if(o!=null&&o!==4){y=new Uint8Array(r.width*r.height*o);const w=g.length;let $=0;for(let S=0;S<w;S++)S%4<o&&(y[$++]=g[S])}const x=t.makeTensorInfo(h,"int32",new Int32Array(y));return t.uploadToGPU(x.dataId),x}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cF=class{constructor(e,t,s,r,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],be(e,t),be(e,s),this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(be(e,r),this.variableNames.push("offset")),o!=null&&(be(e,o),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${Z("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dF={kernelName:uc,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:r,offset:o,mean:i,variance:a}=n,{varianceEpsilon:u}=e,l=t,c=[s,i,a];let d=null;o!=null&&(d=o.shape,c.push(o));let h=null;r!=null&&(h=r.shape,c.push(r));const p=new cF(s.shape,i.shape,a.shape,d,h),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,c,s.dtype,f)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s,g=hn(c),y=Ze(r.shape,o.shape,u,d,l,h,!1,g);return Jx({x:r,filter:o,convInfo:y,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:f,activation:p})}const pF={kernelName:Ci,backendName:"webgpu",kernelFunc:hF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s;let f=c;f==null&&(f=[1,1]),T(bt(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);const g=Ze(r.shape,o.shape,u,f,l,d,!0),y=[r,o],x=i!=null,w=a!=null;x&&y.push(i),w&&y.push(a);const $=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let S;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(S=new t0(g,x,h,w),$.push({type:"int32",data:[S.virtualWidth]})):(S=new n0(g,x,h,w),$.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),h==="leakyrelu"&&($.push({type:"float32",data:[p]}),S.uniforms+=" alpha : f32,"),t.runWebGPUProgram(S,y,"float32",$)}const mF={kernelName:Si,backendName:"webgpu",kernelFunc:fF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gF=class{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ye(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=H(s.shape),[u,l,c,d]=ih(s,r),h=ie({inputs:{x:r},backend:t,attrs:{shape:[l,i]}}),p=ie({inputs:{x:s},backend:t,attrs:{shape:[H(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const w=t.readSync(r.dataId),$=t.bufferSync(s),S=RA(w,$,s.dtype,l,i,c,d,s.shape,a);return t.makeTensorInfo(u,s.dtype,S.values)}const f=new gF(i,[l,c]),g=[{type:"int32",data:[i]},{type:"int32",data:d}],y=t.runWebGPUProgram(f,[p,h],p.dtype,g),x=ie({inputs:{x:y},backend:t,attrs:{shape:u}});return t.disposeData(h.dataId),t.disposeData(p.dataId),t.disposeData(y.dataId),x}const xF={kernelName:cc,backendName:"webgpu",kernelFunc:yF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bF=class{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=wF(this.aShape);return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function wF(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,u=Ue(i,r.shape)[0],l=Ph(r,o,u,a),c=H(o.shape),d=[],h=ie({inputs:{x:r},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=ie({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,c/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([r,o])){const $=t.tensorMap.get(p.dataId).values,S=Pe(p.shape,p.dtype,$),P=t.tensorMap.get(h.dataId).values,F=Pe(h.shape,h.dtype,P),L=_A(F,S,f);return d.forEach(R=>t.disposeData(R.dataId)),t.makeTensorInfo(l.outputShape,L.dtype,L.values)}const g=new bF(h.shape,f),y=t.runWebGPUProgram(g,[h,p],h.dtype);d.push(y);const x=ie({inputs:{x:y},backend:t,attrs:{shape:l.outputShape}});return d.forEach(w=>t.disposeData(w.dataId)),x}const vF={kernelName:lc,backendName:"webgpu",kernelFunc:i0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF=st({opType:pe.GREATER,cpuKernelImpl:PA,dtype:"bool"}),SF={kernelName:dc,backendName:"webgpu",kernelFunc:CF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F=st({opType:pe.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:AA}),IF={kernelName:hc,backendName:"webgpu",kernelFunc:$F};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kF(n){const{inputs:e,backend:t}=n,{input:s}=e;return o0(s,!0,t)}const NF={kernelName:pc,backendName:"webgpu",kernelFunc:kF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=Ne({opType:Q.IS_FINITE,dtype:"bool"}),EF={kernelName:mc,backendName:"webgpu",kernelFunc:TF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF=Ne({opType:Q.IS_INF,dtype:"bool"}),_F={kernelName:gc,backendName:"webgpu",kernelFunc:RF};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AF=Ne({opType:Q.IS_NAN,dtype:"bool"}),PF={kernelName:yc,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,i=[{type:"float32",data:[o]}],a=new Sr(r.shape,Q.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[r],"float32",i)}const OF={kernelName:xc,backendName:"webgpu",kernelFunc:DF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FF=st({opType:pe.LESS,dtype:"bool",cpuKernelImpl:OA}),LF={kernelName:bc,backendName:"webgpu",kernelFunc:FF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BF=st({opType:pe.LESS_EQUAL,dtype:"bool",cpuKernelImpl:DA}),zF={kernelName:wc,backendName:"webgpu",kernelFunc:BF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VF{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=(r-s)/(o-1),a=new VF(o),u=[{type:"float32",data:[s]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",u)}const WF={kernelName:vc,backendName:"webgpu",kernelFunc:MF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=Ne({opType:Q.LOG,cpuKernelImpl:FA}),GF={kernelName:Cc,backendName:"webgpu",kernelFunc:UF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=Ne({opType:Q.LOG1P}),jF={kernelName:Sc,backendName:"webgpu",kernelFunc:HF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF=st({opType:pe.LOGICAL_AND,dtype:"bool"}),XF={kernelName:$c,backendName:"webgpu",kernelFunc:KF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qF=Ne({opType:Q.LOGICAL_NOT}),YF={kernelName:Ic,backendName:"webgpu",kernelFunc:qF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QF=st({opType:pe.LOGICAL_OR}),ZF={kernelName:kc,backendName:"webgpu",kernelFunc:QF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let JF=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${a0}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}};class eL{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,T(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=J(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Z()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${a0}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=s;let l;o>16?l=new JF(r.shape):l=new eL(r.shape,o);const c=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return t.runWebGPUProgram(l,[r],r.dtype,c)}const nL={kernelName:Nc,backendName:"webgpu",kernelFunc:tL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sL=class{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=s,d=new sL(r.shape),h=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[c]}];return t.runWebGPUProgram(d,[r,o,i],r.dtype,h)}const oL={kernelName:xg,backendName:"webgpu",kernelFunc:rL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL=st({opType:pe.MAX,cpuKernelImpl:BA}),aL={kernelName:Ec,backendName:"webgpu",kernelFunc:iL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,c=Jt(r.shape,o,i,1,a,u);return qx(r,c,"max",t)}const lL={kernelName:Rc,backendName:"webgpu",kernelFunc:uL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],d=Vn(r.shape,o,i,c,a,l,u),h=new Lh(d,"max"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return t.runWebGPUProgram(h,[r],r.dtype,p)}const dL={kernelName:_c,backendName:"webgpu",kernelFunc:cL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hL=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},pL=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fL(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,d=[1,1,1],h=Vn(i.shape,a,u,d,l,c),p=new Lh(h,"max",!0);let f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[i],"int32",f),y=new pL(h);f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const x=t.runWebGPUProgram(y,[r,g],i.dtype,f);return t.disposeData(g.dataId),x}const mL={kernelName:wg,backendName:"webgpu",kernelFunc:fL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;Vx([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,h=Jt(a.shape,u,l,1,c,d),p=new go(h,"max",!0);let f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];const g=t.runWebGPUProgram(p,[a],"int32",f),y=new hL(h);f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const x=t.runWebGPUProgram(y,[r,g],a.dtype,f);return t.disposeData(g.dataId),x}const yL={kernelName:bg,backendName:"webgpu",kernelFunc:gL};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xL(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=s,{x:u}=e;T(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const l=[1,1];T(bt(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Jt(u.shape,r,o,l,i),d=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let h=new go(c,"max",!1);const p=t.runWebGPUProgram(h,[u],u.dtype,d);h=new go(c,"max",!0,!0,a);const f=t.runWebGPUProgram(h,[u],"int32",d);return[p,f]}const bL={kernelName:Ac,backendName:"webgpu",kernelFunc:xL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return Us(r,o,i,"min",t)}const vL={kernelName:Dc,backendName:"webgpu",kernelFunc:wL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CL=st({opType:pe.MIN,cpuKernelImpl:zA}),SL={kernelName:Oc,backendName:"webgpu",kernelFunc:CL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $L=class{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,o)=>r[0]+e[o]+r[1]),this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((r,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((l,c)=>`uniforms.pad${c}[0]`).join(","),s=this.xShape.map((l,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),r=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=Ye(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${r}) {
              ${i} = ${r} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL={kernelName:Fc,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:r,mode:o}=e,i=t,a=r.map(c=>({type:"int32",data:[c[0],c[1]]})),u=new $L(s.shape,r,o);return i.runWebGPUProgram(u,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kL=st({opType:pe.MOD}),NL={kernelName:Lc,backendName:"webgpu",kernelFunc:kL};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TL=class{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Z("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EL{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Z("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=ie({inputs:{x:r},backend:t,attrs:{shape:[H(r.shape)/r.shape[o],r.shape[o]]}}),a=new EL(i.shape),u=t.runWebGPUProgram(a,[i],r.dtype),l=ie({inputs:{x:u},backend:t,attrs:{shape:r.shape}});return t.disposeData(i.dataId),t.disposeData(u.dataId),l}const RL={kernelName:Sd,backendName:"webgpu",kernelFunc:u0};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,u=a?r:u0({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new TL(l,o),h=[{type:"float32",data:[i]},{type:"int32",data:[c]}],p=t.runWebGPUProgram(d,[u],"int32",h);return a||t.disposeData(u.dataId),p}const AL={kernelName:Bc,backendName:"webgpu",kernelFunc:_L};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PL(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.tensorMap.get(s.dataId),[i,a]=MA(o.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const r=new Sr(s.shape,Q.NEG);return t.runWebGPUProgram(r,[s],s.dtype)}const DL={kernelName:Vc,backendName:"webgpu",kernelFunc:PL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OL(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=s,l=t.readSync(r.dataId),c=t.readSync(o.dataId),{selectedIndices:d}=eh(l,c,i,a,u);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const FL={kernelName:Wc,backendName:"webgpu",kernelFunc:OL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LL(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,c=t.readSync(r.dataId),d=t.readSync(o.dataId),h=i,p=a,f=u,g=l,{selectedIndices:y,selectedScores:x}=th(c,d,h,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const BL={kernelName:Uc,backendName:"webgpu",kernelFunc:LL};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zL=class{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Z("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VL(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:u}=s,l=H(r.shape),c=new zL(l,i),d=ie({inputs:{x:r},backend:t,attrs:{shape:[l]}}),h=[{type:"float32",data:[a]},{type:"float32",data:[u]}],p=t.runWebGPUProgram(c,[d],o,h);t.disposeData(d.dataId);const f=[...r.shape,i],g=ie({inputs:{x:p},backend:t,attrs:{shape:f}});return t.disposeData(p.dataId),g}const ML={kernelName:Hc,backendName:"webgpu",kernelFunc:VL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fi(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=_o({inputs:{input:s},backend:t}),o=Fi({inputs:{x:r},backend:t}),i=la({inputs:{input:s},backend:t}),a=Fi({inputs:{x:i},backend:t}),u=Ws({inputs:{real:o,imag:a},backend:t});return t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return St({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const WL={kernelName:Ld,backendName:"webgpu",kernelFunc:Fi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=_o({inputs:{input:s},backend:t}),o=l0({inputs:{x:r},backend:t}),i=la({inputs:{input:s},backend:t}),a=Fi({inputs:{x:i},backend:t}),u=Ws({inputs:{real:o,imag:a},backend:t});return t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return St({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const UL={kernelName:Gc,backendName:"webgpu",kernelFunc:l0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return ju({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Ot(o,c.shape,"All tensors passed to stack must have matching shapes"),T(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const d=ju({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(d),d}),l=Zx({inputs:u,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeData(c.dataId)),l}const HL={kernelName:jc,backendName:"webgpu",kernelFunc:GL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0(n,e=!1){const t=n.length,s=Ye(t),r=n.map((d,h)=>`uniforms.pad${h}[0]`).join(","),o=n.map((d,h)=>`uniforms.pad${h}[0] + uniforms.xShape${t>1?`[${h}]`:""}`).join(","),i=t>1?`${s}(${r})`:`${r}`,a=t>1?`${s}(${o})`:`${o}`,u=t>1?"any(paddedCoords < start)":"paddedCoords < start",l=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}let jL=class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${c0(this.xShape)}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KL=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;if(o.every(l=>Ae(l,[0,0])))return Pt({inputs:{x:r},backend:t});if(H(r.shape)===0){const l=o.map((c,d)=>c[0]+r.shape[d]+c[1]);return St({backend:t,attrs:{shape:l,value:i,dtype:r.dtype}})}const a=[{type:"float32",data:[i]}];o.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));const u=new jL(r.shape,o);return t.runWebGPUProgram(u,[r],r.dtype,a)},XL={kernelName:Kc,backendName:"webgpu",kernelFunc:KL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qL=st({opType:pe.POW}),YL={kernelName:Xc,backendName:"webgpu",kernelFunc:qL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QL(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=new Pi(pe.PRELU,s.shape,r.shape);return t.runWebGPUProgram(o,[s,r],"float32")}const ZL={kernelName:qc,backendName:"webgpu",kernelFunc:QL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return Us(r,o,i,"prod",t)}const eB={kernelName:Yc,backendName:"webgpu",kernelFunc:JL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tB=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:i}=t,a=GA(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},nB={kernelName:Qc,backendName:"webgpu",kernelFunc:tB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sB=st({opType:pe.DIV}),rB={kernelName:ql,backendName:"webgpu",kernelFunc:sB};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oB=Ne({opType:Q.RECIPROCAL}),iB={kernelName:Jc,backendName:"webgpu",kernelFunc:oB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aB=Ne({opType:Q.RELU}),uB={kernelName:ed,backendName:"webgpu",kernelFunc:aB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lB=Ne({opType:Q.RELU6}),cB={kernelName:rd,backendName:"webgpu",kernelFunc:lB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dB=class{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,size:i,halfPixelCenters:a}=s,[u,l]=i,c=o&&u>1?1:0,d=o&&l>1?1:0,p=[{type:"float32",data:[c,d]},{type:"float32",data:[a?.5:0]}],f=new dB(r.shape,u,l);return t.runWebGPUProgram(f,[r],"float32",p)}const pB={kernelName:sd,backendName:"webgpu",kernelFunc:hB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fB=class{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,[,a,u]=r.shape,[,l,c]=o.shape,d=[i&&l>1?a-1:a,i&&c>1?u-1:u],h=[i&&l>1?l-1:l,i&&c>1?c-1:c],p=d[0]/h[0],f=d[1]/h[1],g=1/p,y=1/f,x=Math.ceil(g)*2+2,w=Math.ceil(y)*2+2,$=new fB(r.shape,i),S=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"int32",data:[x]},{type:"int32",data:[w]}];return t.runWebGPUProgram($,[o],o.dtype,S)}const gB={kernelName:kg,backendName:"webgpu",kernelFunc:mB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yB=class{constructor(e,t,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=o&&u>1?1:0,d=o&&l>1?1:0,p=[{type:"float32",data:[c,d]},{type:"float32",data:[o?.5:0]}],f=new yB(r.shape,u,l,i);return t.runWebGPUProgram(f,[r],r.dtype,p)}const bB={kernelName:nd,backendName:"webgpu",kernelFunc:xB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wB=class{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vB(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,[,a,u]=r.shape,[,l,c]=o.shape,d=[i&&l>1?a-1:a,i&&c>1?u-1:u],h=[i&&l>1?l-1:l,i&&c>1?c-1:c],p=d[0]/h[0],f=d[1]/h[1],g=1/p,y=1/f,x=Math.ceil(g)*2+2,w=Math.ceil(y)*2+2,$=new wB(r.shape,i),S=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"int32",data:[x]},{type:"int32",data:[w]}];return t.runWebGPUProgram($,[o],o.dtype,S)}const CB={kernelName:Ig,backendName:"webgpu",kernelFunc:vB};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SB=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,i=r.shape.length;if(i===0)return Pt({inputs:{x:r},backend:t});const a=r.shape,u=[1,1,1,1];a.forEach((y,x)=>{const w=x+4-i;u[w]=y});const l=Ue(o,r.shape),c=[0,0,0,0];l.forEach(y=>{const x=y+4-i;c[x]=1});const d=[{type:"int32",data:c}],h=ie({inputs:{x:r},backend:t,attrs:{shape:u}}),p=new SB(u),f=t.runWebGPUProgram(p,[h],h.dtype,d);t.disposeData(h.dataId);const g=ie({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),g}const IB={kernelName:od,backendName:"webgpu",kernelFunc:$B};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kB=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Z("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NB={kernelName:zd,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,u=new kB(s.shape,o),[l,c]=mh(i,s.shape[1],s.shape[2]),d=[{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof o=="number"?d.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):d.push({type:"float32",data:o}),a.runWebGPUProgram(u,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TB=Ne({opType:Q.ROUND}),EB={kernelName:id,backendName:"webgpu",kernelFunc:TB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RB=Ne({opType:Q.RSQRT,cpuKernelImpl:HA}),_B={kernelName:ad,backendName:"webgpu",kernelFunc:RB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let so=class{constructor(e,t,s,r,o,i,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=se(e),this.dispatch=J(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${a}_${u}_${o.length}`;const l=Ye(o.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",o="";this.dispatchLayout.x.length===1?(r="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(l,c)=>`coords[${c}]`).join(", ")})`;return`
    ${o}
      ${Z("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${vs(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?us("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=Bs(o,r,i),h=[d/l,l];if(d===0)return t.makeTensorInfo(i,r.dtype);const p=ie({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),f=ie({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),g=f.dtype,y=St({backend:t,attrs:{shape:h,value:0,dtype:g}}),x=H(f.shape),w=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[x]}],$=new so(f.shape,a,p.shape.length,f.shape.length,c,h,g),S=t.runWebGPUProgram($,[f,p],g,w,y),E=ie({inputs:{x:S},backend:t,attrs:{shape:i}});return t.disposeData(p.dataId),t.disposeData(f.dataId),t.disposeData(S.dataId),E}const PB={kernelName:ud,backendName:"webgpu",kernelFunc:AB};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DB=class{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Z("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=new DB([o.shape[0],o.shape[1]],i),u=[{type:"int32",data:[r.shape[1]]}];return t.runWebGPUProgram(a,[r,o],"int32",u)}const FB={kernelName:cd,backendName:"webgpu",kernelFunc:OB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LB=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${r[a]}`),a<this.cRank&&o.push(`${r[a]}`);e=o.join(),t=i.join()}return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,i=new LB(s.shape.length,r.shape,r.shape.length);return t.runWebGPUProgram(i,[s,r,o],$t(r.dtype,o.dtype))}const zB={kernelName:dd,backendName:"webgpu",kernelFunc:BB};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VB=Ne({opType:Q.SELU}),MB={kernelName:hd,backendName:"webgpu",kernelFunc:VB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WB=Ne({opType:Q.SIGMOID}),UB={kernelName:yd,backendName:"webgpu",kernelFunc:WB};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GB=Ne({opType:Q.SIGN}),HB={kernelName:gd,backendName:"webgpu",kernelFunc:GB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jB=Ne({opType:Q.SIN}),KB={kernelName:fd,backendName:"webgpu",kernelFunc:jB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XB=Ne({opType:Q.SINH}),qB={kernelName:md,backendName:"webgpu",kernelFunc:XB};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YB=Ne({opType:Q.SOFTPLUS}),QB={kernelName:xd,backendName:"webgpu",kernelFunc:YB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZB{constructor(e,t,s,r,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(r.length);for(let u=0;u<a.length;u++)a[u]=r[o[u]];this.outputShape=a,this.newDim=o,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ye(r.length)}, paddedXShapeStrides : ${Ye(i)}, `,s.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=Ye(this.outputShape.length),t=Hx(this.newDim);return`
      ${gi(this.paddedXShape,"PaddedX")}
      ${Z("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${c0(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JB=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;T(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,$)=>w*$),u=[[0,0]];u.push(...i);for(let w=1+o.length;w<r.shape.length;++w)u.push([0,0]);const l=u.map((w,$)=>w[0]+r.shape[$]+w[1]),c=To(l,o,a,!1),d=Eo(c.length,o.length,!1),h=Ro(l,o,a,!1),p=Xe(l),f=new ZB(r.shape,l,u,c,d,p.length),g=[{type:"int32",data:c},{type:"int32",data:p}];u.map(w=>g.push({type:"int32",data:[w[0],w[1]]}));const y=t.runWebGPUProgram(f,[r],r.dtype,g),x=ie({inputs:{x:y},backend:t,attrs:{shape:h}});return t.disposeData(y.dataId),x},ez={kernelName:vd,backendName:"webgpu",kernelFunc:JB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tz{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=se([t]),this.dispatch=J(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${us("&result[outIndex]","value",this.type)}
      }
    }
  `}}class nz{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=se(t),this.dispatch=J(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${us("&result[segmentId]","1","int32")}
      }
    }
  `}}class sz{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=se(e),this.dispatch=J(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0(n,e,t,s=!1,r){const i=H(n.shape)/n.shape[0],a=n.dtype,u=H(e.shape),l=r.readSync(t.dataId),d=u>0?l[u-1]+1:0;let h;const p=n.shape.slice();p[0]=d;const f=u*i,g=St({backend:r,attrs:{shape:p,value:0,dtype:a}});h=new tz(p,f,a);let y=[{type:"int32",data:[i]},{type:"int32",data:[f]}];const x=r.runWebGPUProgram(h,[n,e,t],a,y,g);if(s)return x;const w=St({backend:r,attrs:{shape:[d],value:0,dtype:"int32"}});h=new nz(d,t.shape);const $=r.runWebGPUProgram(h,[t],"int32",null,w),S=St({backend:r,attrs:{shape:p,value:0,dtype:a}});h=new sz(p,a),y=[{type:"int32",data:[i]}];const E=r.runWebGPUProgram(h,[x,$],a,y,S);return r.disposeData(x.dataId),r.disposeData($.dataId),E}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rz(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;return d0(s,r,o,!1,t)}const oz={kernelName:$d,backendName:"webgpu",kernelFunc:rz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iz(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;return d0(s,r,o,!0,t)}const az={kernelName:Id,backendName:"webgpu",kernelFunc:iz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uz=class{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*t[r];this.outputShape=s,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=lz(this.rank,"uniforms.");return`
      ${Z("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function lz(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n;r++)s.push(`(${t[r]} % ${e}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(t.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const u=t.readSync(r.dataId),l=r.dtype==="string"?u.map(h=>Pn(h)):u,c=Pe(r.shape,r.dtype,l),d=ZA(c,o);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new uz(r.shape,o);return t.runWebGPUProgram(i,[r],r.dtype)}const cz={kernelName:Hi,backendName:"webgpu",kernelFunc:Bh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dz(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=Bs(o,r,a),p=!1;if(o.dtype==="string"){const L=t.bufferSync(r),R=t.bufferSync(o),A=Pn(t.readSync(i.dataId)[0]),k=jA(L,R,a,h,c,l,u,d,A,p);return t.makeTensorInfo(a,k.dtype,k.values)}const f=[h/c,c],g=ie({inputs:{x:r},backend:t,attrs:{shape:[l,u]}}),y=o.shape.length?ie({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}):Pt({inputs:{x:o},backend:t}),x=y.dtype,w=t.makeTensorInfo([],x,An(1,x)),$=ie({inputs:{x:i},backend:t,attrs:{shape:Array(f.length).fill(1)}}),S=Bh({inputs:{x:$},backend:t,attrs:{reps:f}}),E=H([l,c]),P=[{type:"int32",data:[u]},{type:"int32",data:d},{type:"int32",data:[E]}];switch(l){case 0:break;case 1:{const L=new so([l,c],u,g.shape.length,y.shape.length,d,f,x,p);t.runWebGPUProgram(L,[y,g],x,P,S)}break;default:{const L=new so([l,c],u,g.shape.length,w.shape.length,d,f,x,p);t.runWebGPUProgram(L,[w,g],x,P,S)}{const L=new so([l,c],u,g.shape.length,y.shape.length,d,f,x);t.runWebGPUProgram(L,[y,g],x,P,S)}}const F=ie({inputs:{x:S},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData($.dataId),t.disposeData(w.dataId),t.disposeData(S.dataId),F}const hz={kernelName:kd,backendName:"webgpu",kernelFunc:dz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=Ue(i,r.shape)[0],u=_h(r,o,a),l=r.shape.length,c=new Array(l).fill(0),d=r.shape.slice();return u.map(h=>{const p=[...d];p[a]=h;const f=$r({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=h,f})}const fz={kernelName:Cd,backendName:"webgpu",kernelFunc:pz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mz=Ne({opType:Q.SQRT}),gz={kernelName:bd,backendName:"webgpu",kernelFunc:mz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yz={kernelName:Eg,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,r=new Sr(t.shape,Q.SQUARE);return s.runWebGPUProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xz=st({opType:pe.SQUARED_DIFFERENCE}),bz={kernelName:Nd,backendName:"webgpu",kernelFunc:xz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wz({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=new Sr(s.shape,Q.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(r,[s],s.dtype,o)}const vz={kernelName:Bd,backendName:"webgpu",kernelFunc:wz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cz=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ye(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let r=0;t=this.outputShape.map((o,i)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${r-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Z("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:w,end:$,strides:S}=hh(r.shape,o,i,a,u,l,c,d,h);let E;if(g)E=ie({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||x){T(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const P=uh(w,$,S),F=$r({inputs:{x:r},backend:t,attrs:{begin:w,size:P}});E=ie({inputs:{x:F},backend:t,attrs:{shape:f}}),t.disposeData(F.dataId)}else if(t.shouldExecuteOnCPU([r])){const F=t.readSync(r.dataId),L=Pe(r.shape,r.dtype,F),R=qA(p,L,S,w);E=t.makeTensorInfo(f,r.dtype,R.values)}else{const F=new Cz(p),L=[{type:"int32",data:w},{type:"int32",data:S}],R=t.runWebGPUProgram(F,[r],r.dtype,L);E=ie({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeData(R.dataId)}return E}const $z={kernelName:Td,backendName:"webgpu",kernelFunc:Sz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iz(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:d}=e,h=t.readSync(c.dataId),p=t.readSync(d.dataId),[f,g]=YA(h,p,r,o,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",g)]}const kz={kernelName:Ed,backendName:"webgpu",kernelFunc:Iz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nz=st({opType:pe.SUB,cpuKernelImpl:QA,supportsComplex:!0}),Tz={kernelName:Rd,backendName:"webgpu",kernelFunc:Nz};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ez=Ne({opType:Q.TAN}),Rz={kernelName:_d,backendName:"webgpu",kernelFunc:Ez};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _z=Ne({opType:Q.TANH}),Az={kernelName:Ad,backendName:"webgpu",kernelFunc:_z};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pz(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=Bs(i,o,r.shape),h=[d/l,l];if(d===0)return t.makeTensorInfo(r.shape,o.dtype);const p=[],f=ie({inputs:{x:o},backend:t,attrs:{shape:[u,a]}});p.push(f);const g=ie({inputs:{x:i},backend:t,attrs:{shape:[u,l]}});p.push(g);const y=ie({inputs:{x:r},backend:t,attrs:{shape:h}});p.push(y);const x=Bh({inputs:{x:y},backend:t,attrs:{reps:Array(h.length).fill(1)}}),w=new so([u,l],a,f.shape.length,g.shape.length,c,h,r.dtype,!1),$=H([u,l]),S=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[$]}],E=t.runWebGPUProgram(w,[g,f],y.dtype,S,x);p.push(E);const P=ie({inputs:{x:E},backend:t,attrs:{shape:r.shape}});return p.forEach(F=>t.disposeData(F.dataId)),P}const Dz={kernelName:ld,backendName:"webgpu",kernelFunc:Pz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Oz=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Z("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},Fz=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Z("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(n,e){e!==null&&n.disposeData(e.dataId)}function Qf(n){let e=1;for(;e<n;)e*=2;return e}function Lz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s,a=r.shape,u=a[a.length-1];if(t.shouldExecuteOnCPU([r])){const E=t.readSync(r.dataId),[P,F]=JA(E,a,r.dtype,o,i);return[t.makeTensorInfo(P.shape,P.dtype,P.values),t.makeTensorInfo(F.shape,F.dtype,F.values)]}if(o===0)return a[a.length-1]=0,[t.makeTensorInfo(a,r.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(u===1)return[r,St({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const c=H(a)/u,d=ie({inputs:{x:r},attrs:{shape:[c,u]},backend:t}),h=Qf(o),p=Qf(u);let f=null;const g=()=>f===null?[d,d]:[d,f],y=(E,P,F)=>{const L=g(),R=new Oz(F),k=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[E]},{type:"int32",data:[P]}],W=f;f=t.runWebGPUProgram(R,L,"int32",k),Zs(t,W)};for(let E=1;E<h;E*=2){const P=E*2;for(let F=E;F>=1;F/=2)y(P,F,[c,p])}for(let E=p;E>h;E/=2){const P=g(),F=new Fz([c,E/2]),R=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[h]}],A=f;f=t.runWebGPUProgram(F,P,"int32",R),Zs(t,A);const k=h/2,W=k*2;for(let G=k;G>=1;G/=2)y(W,G,f.shape)}let x=f;f=$r({inputs:{x:f},backend:t,attrs:{begin:0,size:[c,o]}}),Zs(t,x);let w=i0({inputs:{x:d,indices:f},backend:t,attrs:{axis:1,batchDims:1}});Zs(t,d);const $=a.slice(0,-1);$.push(o),x=f,f=ie({inputs:{x:f},attrs:{shape:$},backend:t}),Zs(t,x);const S=w;return w=ie({inputs:{x:w},attrs:{shape:$},backend:t}),Zs(t,S),[w,f]}const Bz={kernelName:Pd,backendName:"webgpu",kernelFunc:Lz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zz=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Z("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vz(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=s,[c,d,h,p]=r.shape,[f,g]=l??[d,h],y=[c,f,g,p],x=new zz(y),w=i==="nearest"?1:2;let $;switch(a){case"constant":$=1;break;case"reflect":$=2;break;case"wrap":$=3;break;case"nearest":$=4;break;default:$=1;break}const S=[{type:"int32",data:[w]},{type:"int32",data:[$]},{type:"float32",data:[u]}];return t.runWebGPUProgram(x,[r,o],"float32",S)}const Mz={kernelName:Dd,backendName:"webgpu",kernelFunc:Vz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wz(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,u=r.shape[o],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(l[c++]=i.shape[g]);const d=[],h=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(u);for(let g=0;g<f.length;g++){h[o]=g;const y=$r({inputs:{x:i},backend:t,attrs:{begin:h,size:p}}),x=ie({inputs:{x:y},backend:t,attrs:{shape:l}});f[g]=x,d.push(y)}return d.forEach(g=>t.disposeData(g.dataId)),f}const Uz={kernelName:Od,backendName:"webgpu",kernelFunc:Wz};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gz{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=se(e),this.dispatch=J(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Z("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${us("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,u=[];let l=0;const c=dt([l],a);let d=r;c!=null&&(d=$n({inputs:{x:r},backend:t,attrs:{perm:c}}),u.push(d),l=ht(1,a)[0]);const h=Ah(d.shape,l,i),p=H([d.shape[l]]),f=ie({inputs:{x:d},backend:t,attrs:{shape:[-1,p]}});u.push(f);const g=r.dtype,y=[f.shape[0],i],x=St({backend:t,attrs:{shape:y,value:0,dtype:g}}),w=new Gz(f.shape,y,g),$=[{type:"int32",data:[i]},{type:"int32",data:[H(f.shape)]}],S=t.runWebGPUProgram(w,[f,o],g,$,x),E=ie({inputs:{x:S},backend:t,attrs:{shape:h}});u.push(S);let P=E;if(c!=null){u.push(E);const F=No(c);P=$n({inputs:{x:P},backend:t,attrs:{perm:F}})}return u.forEach(F=>t.disposeData(F.dataId)),P}const jz={kernelName:Fd,backendName:"webgpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kz=[f_,nP,rP,iP,uP,dP,xP,wP,CP,$P,kP,TP,RP,AP,DP,zP,MP,HP,KP,qP,eD,rD,aD,dD,pD,yD,g_,wD,$D,AD,BD,WD,HD,KD,qD,QD,JD,nO,rO,iO,uO,dO,xO,wO,fO,SO,kO,RO,AO,OO,zO,MO,UO,HO,KO,qO,YO,ZO,eF,d_,nF,uF,rF,iF,dF,pF,mF,xF,vF,SF,IF,m_,NF,CD,EF,_F,PF,OF,LF,zF,WF,jF,GF,XF,YF,ZF,nL,oL,FP,aL,lL,yL,dL,mL,bL,LP,vL,SL,IL,NL,AL,FO,DL,FL,BL,uD,ML,UL,HL,XL,YL,ZL,eB,nB,lD,rB,iB,uB,cB,h_,pB,gB,bB,CB,IB,NB,EB,_B,PB,FB,zB,MB,UB,HB,KB,qB,ZP,vz,$z,kz,RL,QB,ez,oz,az,hz,fz,gz,yz,bz,Tz,LO,Rz,Az,Dz,cz,Bz,Mz,fP,Uz,jz,WL];for(const n of Kz)Dg(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var h0=function(n,e){return(h0=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(t[r]=s[r])})(n,e)};function p0(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}h0(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Be=function(){return(Be=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function Ie(n,e,t,s){return new(t||(t=Promise))(function(r,o){function i(l){try{u(s.next(l))}catch(c){o(c)}}function a(l){try{u(s.throw(l))}catch(c){o(c)}}function u(l){var c;l.done?r(l.value):(c=l.value,c instanceof t?c:new t(function(d){d(c)})).then(i,a)}u((s=s.apply(n,[])).next())})}function ke(n,e){var t,s,r,o,i={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(l){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;i;)try{if(t=1,s&&(r=2&c[0]?s.return:c[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,c[1])).done)return r;switch(s=0,r&&(c=[2&c[0],r.value]),c[0]){case 0:case 1:r=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,s=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(r=i.trys,!((r=r.length>0&&r[r.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){i.label=c[1];break}if(c[0]===6&&i.label<r[1]){i.label=r[1],r=c;break}if(r&&i.label<r[2]){i.label=r[2],i.ops.push(c);break}r[2]&&i.ops.pop(),i.trys.pop();continue}c=e.call(n,i)}catch(d){c=[6,d],s=0}finally{t=r=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Is(n,e,t){if(t||arguments.length===2)for(var s,r=0,o=e.length;r<o;r++)!s&&r in e||(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return n.concat(s||Array.prototype.slice.call(e))}var In=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],xo=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function Li(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function f0(n){return Ie(this,void 0,void 0,function(){var e,t;return ke(this,function(s){switch(s.label){case 0:return e=document.createElement("canvas"),n instanceof Ke?[4,oh(n,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=Li(n.width),e.height=Li(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),s.label=3;case 3:return[2,e]}})})}function m0(n){return Ie(this,void 0,void 0,function(){var e,t,s,r,o,i;return ke(this,function(a){switch(a.label){case 0:return n instanceof Ke?(e=n.shape.slice(0,2),t=e[0],s=e[1],r=ImageData.bind,[4,oh(n)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,a.sent(),s,t]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=Li(n.width),o.height=Li(n.height),i.drawImage(n,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function Xz(n){return Ie(this,void 0,void 0,function(){var e,t;return ke(this,function(s){switch(s.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,f0(n)]:[3,2];case 1:return t=s.sent(),[3,3];case 2:t=n,s.label=3;case 3:return e=t,[2,ax(e,4)]}})})}function g0(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var jr={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},qz=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,m0(this.mask)]})})},n.prototype.toTensor=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,Xz(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function Yz(n){return g0(n),"person"}var Qz=function(){function n(e){var t,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new C1.Pose({locateFile:function(r,o){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(r)}return"".concat(o,"/").concat(r)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(r){if(s.height=r.image.height,s.width=r.image.width,r.poseLandmarks==null)s.poses=[];else{var o=s.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(o.segmentation={maskValueToLabel:Yz,mask:new qz(r.segmentationMask)}),s.poses=[o]}})}return n.prototype.translateOutput=function(e,t){var s=this,r={keypoints:e.map(function(o,i){return{x:o.x*s.width,y:o.y*s.height,z:o.z,score:o.visibility,name:xo[i]}})};return t!=null&&(r.keypoints3D=t.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:xo[i]}})),r},n.prototype.estimatePoses=function(e,t,s){return Ie(this,void 0,void 0,function(){var r,o;return ke(this,function(i){switch(i.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Ke?(o=ImageData.bind,[4,oh(e)]):[3,2];case 1:return r=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,i.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},s)];case 4:return i.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function Zz(n){return Ie(this,void 0,void 0,function(){var e,t;return ke(this,function(s){switch(s.label){case 0:return e=function(r){if(r==null)return Be({},jr);var o=Be({},r);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=jr.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=jr.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=jr.smoothSegmentation),o.modelType==null&&(o.modelType=jr.modelType),o}(n),[4,(t=new Qz(e)).initialize()];case 1:return s.sent(),[2,t]}})})}function mr(n){return n instanceof Ke?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function y0(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function zh(n){return n instanceof Ke?n:ax(n)}function x0(n,e,t){return Ku(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function Ku(n,e){T(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),T(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function Ya(n,e,t){var s=t.rotationVectorStartKeypointIndex,r=t.rotationVectorEndKeypointIndex,o=n.locationData,i=o.relativeKeypoints[s].x*e.width,a=o.relativeKeypoints[s].y*e.height,u=o.relativeKeypoints[r].x*e.width,l=o.relativeKeypoints[r].y*e.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),d=function(h,p,f){var g,y=h.locationData,x=f.rotationVectorStartKeypointIndex,w=f.rotationVectorEndKeypointIndex;g=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var $=y.relativeKeypoints[x].x*p.width,S=y.relativeKeypoints[x].y*p.height,E=y.relativeKeypoints[w].x*p.width,P=y.relativeKeypoints[w].y*p.height;return y0(g-Math.atan2(-(P-S),E-$))}(n,e,t);return{xCenter:i/e.width,yCenter:a/e.height,width:c/e.width,height:c/e.height,rotation:d}}function b0(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function Qa(n,e,t,s,r,o,i){return n[e][r]*(n[t][o]*n[s][i]-n[t][i]*n[s][o])}function ft(n,e,t){var s=(e+1)%4,r=(e+2)%4,o=(e+3)%4,i=(t+1)%4,a=(t+2)%4,u=(t+3)%4;return Qa(n,s,r,o,i,a,u)+Qa(n,r,o,s,i,a,u)+Qa(n,o,s,r,i,a,u)}function Zf(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var s=[],r=0,o=n;r<o.length;r++){var i=o[r],a=i.x-.5,u=i.y-.5,l=t.ignoreRotation?0:e.rotation,c=Math.cos(l)*a-Math.sin(l)*u,d=Math.sin(l)*a+Math.cos(l)*u;c=c*e.width+e.xCenter,d=d*e.height+e.yCenter;var h=i.z*e.width,p=Be({},i);p.x=c,p.y=d,p.z=h,s.push(p)}return s}function w0(n,e){var t=function(s,r,o,i){var a=r-s,u=i-o,l=u/a;return{scale:l,offset:o-s*l}}(0,255,e[0],e[1]);return fe(function(){return ue(Y(n,t.scale),t.offset)})}function Xu(n,e,t){var s,r,o,i,a,u,l,c,d,h,p,f,g,y,x=e.outputTensorSize,w=e.keepAspectRatio,$=e.borderMode,S=e.outputTensorFloatRange,E=mr(n),P=function(R,A){return A?{xCenter:A.xCenter*R.width,yCenter:A.yCenter*R.height,width:A.width*R.width,height:A.height*R.height,rotation:A.rotation}:{xCenter:.5*R.width,yCenter:.5*R.height,width:R.width,height:R.height,rotation:0}}(E,t),F=function(R,A,k){if(k===void 0&&(k=!1),!k)return{top:0,left:0,right:0,bottom:0};var W=A.height,G=A.width;Ku(A,"targetSize"),Ku(R,"roi");var K,X,ee=W/G,ce=R.height/R.width,de=0,he=0;return ee>ce?(K=R.width,X=R.width*ee,he=(1-ce/ee)/2):(K=R.height/ee,X=R.height,de=(1-ee/ce)/2),R.width=K,R.height=X,{top:he,left:de,right:de,bottom:he}}(P,x,w),L=(s=P,r=E.width,o=E.height,i=!1,a=s.width,u=s.height,l=i?-1:1,c=Math.cos(s.rotation),d=Math.sin(s.rotation),h=s.xCenter,p=s.yCenter,f=1/r,g=1/o,(y=new Array(16))[0]=a*c*l*f,y[1]=-u*d*f,y[2]=0,y[3]=(-.5*a*c*l+.5*u*d+h)*f,y[4]=a*d*l*g,y[5]=u*c*g,y[6]=0,y[7]=(-.5*u*c-.5*a*d*l+p)*g,y[8]=0,y[9]=0,y[10]=a*f,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,b0(y));return{imageTensor:fe(function(){var R=zh(n),A=Yt(x0(L,E,x),[1,8]),k=$==="zero"?"constant":"nearest",W=ks.transform(zt(ze(R,"float32")),A,"bilinear",k,0,[x.height,x.width]);return S!=null?w0(W,S):W}),padding:F,transformationMatrix:L}}function Jf(n,e,t,s){return s===1?.5*(n+e):n+(e-n)*t/(s-1)}function Jz(n){return fe(function(){var e=function(r){return fe(function(){return[we(r,[0,0,0],[1,-1,1]),we(r,[0,0,1],[1,-1,-1])]})}(n),t=e[0],s=e[1];return{boxes:Oe(s),logits:Oe(t)}})}function v0(n){return n!=null&&n.currentTime!=null}function em(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<n.length;++i){var a=n[i];t=Math.min(t,a.x),s=Math.max(s,a.x),r=Math.min(r,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:r,xMax:s,yMax:o,width:s-t,height:o-r},e}function e4(n,e,t,s){return Ie(this,void 0,void 0,function(){var r,o,i,a,u;return ke(this,function(l){switch(l.label){case 0:return n.sort(function(c,d){return Math.max.apply(Math,d.score)-Math.max.apply(Math,c.score)}),r=Yt(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=ct(n.map(function(c){return c.score[0]})),[4,ks.nonMaxSuppressionAsync(r,o,e,t)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=n.filter(function(c,d){return a.indexOf(d)>-1}),_e([r,o,i]),[2,u]}})})}function C0(n,e){return n.map(function(t){var s=Be(Be({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(s.z=t.z*e.width),s})}function t4(n,e,t){return Ie(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,d,h,p,f,g,y,x,w,$,S,E,P,F,L,R,A;return ke(this,function(k){switch(k.label){case 0:if(s=Oe(e,[0]),r=s.shape,o=r[0],i=r[1],a=r[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return u=[],[4,s.buffer()];case 1:for(l=k.sent(),c=0;c<n.length;c++)if(d=n[c],h=Be({},d),u.push(h),p=Math.trunc(h.x*i),f=Math.trunc(h.y*o),!(p<0||p>=i||f<0||p>=o)){for(g=Math.trunc((t.kernelSize-1)/2),y=Math.max(0,p-g),x=Math.min(i,p+g+1),w=Math.max(0,f-g),$=Math.min(o,f+g+1),S=0,E=0,P=0,F=0,L=w;L<$;++L)for(R=y;R<x;++R)A=l.get(L,R,c),S+=A,F=Math.max(F,A),E+=R*A,P+=L*A;F>=t.minConfidenceToRefine&&S>0&&(h.x=E/i/S,h.y=P/o/S)}return s.dispose(),[2,u]}})})}function tm(n,e){var t=e.left,s=e.top,r=e.left+e.right,o=e.top+e.bottom;return n.map(function(i){return Be(Be({},i),{x:(i.x-t)/(1-r),y:(i.y-s)/(1-o),z:i.z/(1-r)})})}function n4(n,e,t){return ro()==="webgl"?function(s,r,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},u=dr();return fe(function(){var l=u.compileAndRun(a,[s,r]);return At().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(n,e,t):fe(function(){var s=ye(e,.5),r=qt(s),o=ye(1,co(1,Y(r,ue(5.68842,Y(r,ue(-.748699,Y(r,ue(-57.8051,Y(r,ue(291.309,Y(r,-624.717)))))))))));return ue(e,Y(ye(n,e),Y(o,t.combineWithPreviousRatio)))})}function s4(n,e,t){return Ie(this,void 0,void 0,function(){var s,r,o,i,a;return ke(this,function(u){switch(u.label){case 0:return s=n[0],r=n[1],o=function(l,c,d){return fe(function(){var h,p,f,g;d.reverseOutputOrder?(p=Oe(we(l,[0,d.boxCoordOffset+0],[-1,1])),h=Oe(we(l,[0,d.boxCoordOffset+1],[-1,1])),g=Oe(we(l,[0,d.boxCoordOffset+2],[-1,1])),f=Oe(we(l,[0,d.boxCoordOffset+3],[-1,1]))):(h=Oe(we(l,[0,d.boxCoordOffset+0],[-1,1])),p=Oe(we(l,[0,d.boxCoordOffset+1],[-1,1])),f=Oe(we(l,[0,d.boxCoordOffset+2],[-1,1])),g=Oe(we(l,[0,d.boxCoordOffset+3],[-1,1]))),p=ue(Y(Se(p,d.xScale),c.w),c.x),h=ue(Y(Se(h,d.yScale),c.h),c.y),d.applyExponentialOnBoxSize?(f=Y(Fn(Se(f,d.hScale)),c.h),g=Y(Fn(Se(g,d.wScale)),c.w)):(f=Y(Se(f,d.hScale),c.h),g=Y(Se(g,d.wScale),c.h));var y=ye(h,Se(f,2)),x=ye(p,Se(g,2)),w=ue(h,Se(f,2)),$=ue(p,Se(g,2)),S=nt([j(y,[d.numBoxes,1]),j(x,[d.numBoxes,1]),j(w,[d.numBoxes,1]),j($,[d.numBoxes,1])],1);if(d.numKeypoints)for(var E=0;E<d.numKeypoints;++E){var P=d.keypointCoordOffset+E*d.numValuesPerKeypoint,F=void 0,L=void 0;d.reverseOutputOrder?(F=Oe(we(l,[0,P],[-1,1])),L=Oe(we(l,[0,P+1],[-1,1]))):(L=Oe(we(l,[0,P],[-1,1])),F=Oe(we(l,[0,P+1],[-1,1])));var R=ue(Y(Se(F,d.xScale),c.w),c.x),A=ue(Y(Se(L,d.yScale),c.h),c.y);S=nt([S,j(R,[d.numBoxes,1]),j(A,[d.numBoxes,1])],1)}return S})}(r,e,t),i=fe(function(){var l=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(l=yy(s,-t.scoreClippingThresh,t.scoreClippingThresh)),l=Rn(l)):l}),[4,r4(o,i,t)];case 1:return a=u.sent(),_e([o,i]),[2,a]}})})}function r4(n,e,t){return Ie(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,d,h,p,f;return ke(this,function(g){switch(g.label){case 0:return s=[],[4,n.data()];case 1:return r=g.sent(),[4,e.data()];case 2:for(o=g.sent(),i=0;i<t.numBoxes;++i)if(!(t.minScoreThresh!=null&&o[i]<t.minScoreThresh||(a=i*t.numCoords,u=o4(r[a+0],r[a+1],r[a+2],r[a+3],o[i],t.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(t.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],d=t.numKeypoints*t.numValuesPerKeypoint,h=0;h<d;h+=t.numValuesPerKeypoint)p=a+t.keypointCoordOffset+h,f={x:r[p+0],y:t.flipVertically?1-r[p+1]:r[p+1]},c.relativeKeypoints.push(f);s.push(u)}return[2,s]}})})}function o4(n,e,t,s,r,o,i){return{score:[r],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-t:n,xMax:s,yMax:o?1-n:t,width:s-e,height:t-n}}}}function i4(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function nm(n,e,t,s){return Ie(this,void 0,void 0,function(){var r,o,i,a,u,l,c,d;return ke(this,function(h){switch(h.label){case 0:return t=t||e.flipHorizontally||!1,s=s||e.flipVertically||!1,r=n.size,o=r/e.numLandmarks,[4,n.data()];case 1:for(i=h.sent(),a=[],u=0;u<e.numLandmarks;++u)l=u*o,(d={x:0,y:0}).x=t?e.inputImageWidth-i[l]:i[l],o>1&&(d.y=s?e.inputImageHeight-i[l+1]:i[l+1]),o>2&&(d.z=i[l+2]),o>3&&(d.score=i4(e.visibilityActivation,i[l+3])),a.push(d);for(c=0;c<a.length;++c)(d=a[c]).x=d.x/e.inputImageWidth,d.y=d.y/e.inputImageHeight,d.z=d.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function sm(n,e,t){var s=n.width,r=n.height,o=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(o=function(l,c){return c.rotation!=null?l+=c.rotation:c.rotationDegree!=null&&(l+=Math.PI*c.rotationDegree/180),y0(l)}(o,t)),o===0)n.xCenter=n.xCenter+s*t.shiftX,n.yCenter=n.yCenter+r*t.shiftY;else{var i=(e.width*s*t.shiftX*Math.cos(o)-e.height*r*t.shiftY*Math.sin(o))/e.width,a=(e.width*s*t.shiftX*Math.sin(o)+e.height*r*t.shiftY*Math.cos(o))/e.height;n.xCenter=n.xCenter+i,n.yCenter=n.yCenter+a}{var u=Math.max(s*e.width,r*e.height);s=u/e.width,r=u/e.height}return n.width=s*t.scaleX,n.height=r*t.scaleY,n}function a4(n,e){return n.map(function(t){var s=Be(Be({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),s})}var Xn=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var s;return this.initialized?s=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},n.prototype.applyWithAlpha=function(e,t,s){return this.alpha=t,this.apply(e,s)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Za=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Xn(this.getAlpha(this.minCutOff)),this.dx=new Xn(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),u)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),qu=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Is([],e,!0);o=1/s}return e.map(function(i,a){var u=Be(Be({},i),{x:r.xFilters[a].apply(i.x,t,o),y:r.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(u.z=r.zFilters[a].apply(i.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new Za(t.config)}),this.yFilters=e.map(function(s){return new Za(t.config)}),this.zFilters=e.map(function(s){return new Za(t.config)}))},n}(),Ja=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Xn(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,s){if(e==null)return e;var r,o=Math.trunc(t);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)r=1;else{for(var i=e*s-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,u=i,l=a,c=(1+this.window.length)*(1e6/30),d=0,h=this.window;d<h.length;d++){var p=h[d];if(l+p.duration>c)break;u+=p.distance,l+=p.duration}var f=u/(1e-6*l);r=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,r)},n}(),u4=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,s){var r=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Is([],e,!0);o=1/s}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var u=Be(Be({},i),{x:r.xFilters[a].apply(i.x,t,o),y:r.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(u.z=r.zFilters[a].apply(i.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new Ja(t.config)}),this.yFilters=e.map(function(s){return new Ja(t.config)}),this.zFilters=e.map(function(s){return new Ja(t.config)}))},n}(),eu=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new u4(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new qu(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,s,r,o){if(r===void 0&&(r=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(o,s):1,a=r?C0(e,s):e,u=this.keypointsFilter.apply(a,t,i);return r?a4(u,s):u},n}(),rm=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Xn(t.alpha)}));for(var s=[],r=0;r<e.length;++r){var o=e[r],i=Be({},o);i.score=this.visibilityFilters[r].apply(o.score),s.push(i)}return s},n}(),l4={interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Js={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},c4={maxPoses:1,flipHorizontal:!1},d4={applyExponentialOnBoxSize:!1,flipVertically:!1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},h4=.3,om={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25},p4={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},f4={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},m4={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},g4={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},y4={kernelSize:7,minConfidenceToRefine:.5},im={alpha:.1},x4={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},b4={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},w4={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},v4={activation:"none"},C4={combineWithPreviousRatio:.7},S4=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,f0(this.mask)]})})},n.prototype.toImageData=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,m0(this.mask)]})})},n.prototype.toTensor=function(){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function $4(n){return g0(n),"person"}var I4=function(){function n(e,t,s,r,o,i){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=s,this.enableSegmentation=r,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(d){d.reduceBoxesInLowestLayer==null&&(d.reduceBoxesInLowestLayer=!1),d.interpolatedScaleAspectRatio==null&&(d.interpolatedScaleAspectRatio=1),d.fixedAnchorSize==null&&(d.fixedAnchorSize=!1);for(var h=[],p=0;p<d.numLayers;){for(var f=[],g=[],y=[],x=[],w=p;w<d.strides.length&&d.strides[w]===d.strides[p];){var $=Jf(d.minScale,d.maxScale,w,d.strides.length);if(w===0&&d.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),x.push(.1),x.push($),x.push($);else{for(var S=0;S<d.aspectRatios.length;++S)y.push(d.aspectRatios[S]),x.push($);if(d.interpolatedScaleAspectRatio>0){var E=w===d.strides.length-1?1:Jf(d.minScale,d.maxScale,w+1,d.strides.length);x.push(Math.sqrt($*E)),y.push(d.interpolatedScaleAspectRatio)}}w++}for(var P=0;P<y.length;++P){var F=Math.sqrt(y[P]);f.push(x[P]/F),g.push(x[P]*F)}var L=0,R=0;if(d.featureMapHeight.length>0)L=d.featureMapHeight[p],R=d.featureMapWidth[p];else{var A=d.strides[p];L=Math.ceil(d.inputSizeHeight/A),R=Math.ceil(d.inputSizeWidth/A)}for(var k=0;k<L;++k)for(var W=0;W<R;++W)for(var G=0;G<f.length;++G){var K={xCenter:(W+d.anchorOffsetX)/R,yCenter:(k+d.anchorOffsetY)/L,width:0,height:0};d.fixedAnchorSize?(K.width=1,K.height=1):(K.width=g[G],K.height=f[G]),h.push(K)}p=w}return h}(l4);var a=ct(this.anchors.map(function(d){return d.width})),u=ct(this.anchors.map(function(d){return d.height})),l=ct(this.anchors.map(function(d){return d.xCenter})),c=ct(this.anchors.map(function(d){return d.yCenter}));this.anchorTensor={x:l,y:c,w:a,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?Yt([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,s){return Ie(this,void 0,void 0,function(){var r,o,i,a,u,l,c,d,h,p,f,g,y,x,w,$,S,E,P,F,L,R,A;return ke(this,function(k){switch(k.label){case 0:return r=function(W){var G;if((G=W==null?c4:Be({},W)).maxPoses==null&&(G.maxPoses=1),G.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(G.maxPoses,". Should be > 0."));if(G.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return G}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=s!=null?1e3*s:v0(e)?1e6*e.currentTime:null,o=mr(e),i=fe(function(){return ze(zh(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((u=k.sent()).length===0)return this.reset(),i.dispose(),[2,[]];l=u[0],a=this.poseDetectionToRoi(l,o),k.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return c=k.sent(),i.dispose(),c==null?(this.reset(),[2,[]]):(d=c.landmarks,h=c.auxiliaryLandmarks,p=c.poseScore,f=c.worldLandmarks,g=c.segmentationMask,y=this.poseLandmarkFiltering(d,h,f,o),x=y.actualLandmarksFiltered,w=y.auxiliaryLandmarksFiltered,$=y.actualWorldLandmarksFiltered,S=this.poseLandmarksToRoi(w,o),this.regionOfInterest=S,E=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(P=x!=null?C0(x,o):null)!=null&&P.forEach(function(W,G){W.name=xo[G]}),(F=$)!=null&&F.forEach(function(W,G){W.name=xo[G]}),L={score:p,keypoints:P,keypoints3D:F},E!==null&&(R=fe(function(){var W=zt(E,2),G=ns(W,[[0,0],[0,0],[0,1]]);return Fy(G,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||_e(E),A={maskValueToLabel:$4,mask:new S4(R)},L.segmentation=A),[2,[L]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=n4(t,e,C4),_e(e)),_e(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),_e([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(_e(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Yt([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return Ie(this,void 0,void 0,function(){var t,s,r,o,i,a,u,l,c,d;return ke(this,function(h){switch(h.label){case 0:return t=Xu(e,p4),s=t.imageTensor,r=t.padding,o=this.detectorModel.predict(s),i=Jz(o),a=i.boxes,[4,s4([u=i.logits,a],this.anchorTensor,d4)];case 1:return(l=h.sent()).length===0?(_e([s,o,u,a]),[2,l]):[4,e4(l,this.maxPoses,h4)];case 2:return c=h.sent(),d=function(p,f){p===void 0&&(p=[]);for(var g=f.left,y=f.top,x=f.left+f.right,w=f.top+f.bottom,$=0;$<p.length;$++){var S=p[$],E=S.locationData.relativeBoundingBox,P=(E.xMin-g)/(1-x),F=(E.yMin-y)/(1-w),L=E.width/(1-x),R=E.height/(1-w);E.xMin=P,E.yMin=F,E.width=L,E.height=R,E.xMax=P+L,E.yMax=F+R;var A=S.locationData.relativeKeypoints;A&&A.forEach(function(k){var W=(k.x-g)/(1-x),G=(k.y-y)/(1-w);k.x=W,k.y=G})}return p}(c,r),_e([s,o,u,a]),[2,d]}})})},n.prototype.poseDetectionToRoi=function(e,t){return sm(Ya(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,om)},n.prototype.poseLandmarksByRoi=function(e,t){return Ie(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,d,h,p,f,g,y;return ke(this,function(x){switch(x.label){case 0:if(s=mr(t),r=Xu(t,f4,e),o=r.imageTensor,i=r.padding,a=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(o,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=x.sent())==null?(_e(l),_e(o),[2,null]):(d=c.landmarks,h=c.auxiliaryLandmarks,p=c.poseScore,f=c.worldLandmarks,g=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,i,a,d,h,f,g)]);case 2:return y=x.sent(),_e(l),_e(o),[2,Be({poseScore:p},y)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,s,r,o,i,a,u){return Ie(this,void 0,void 0,function(){var l,c,d,h,p,f;return ke(this,function(g){return l=tm(o,s),c=tm(i,s),d=Zf(l,t),h=Zf(c,t),p=function(y,x){for(var w=[],$=0,S=y;$<S.length;$++){var E=S[$],P=E.x,F=E.y,L=x.rotation,R=Math.cos(L)*P-Math.sin(L)*F,A=Math.sin(L)*P+Math.cos(L)*F,k=Be({},E);k.x=R,k.y=A,w.push(k)}return w}(a,t),f=null,this.enableSegmentation&&(f=fe(function(){var y=u.shape,x=y[0],w=y[1],$=function(P){var F=b0(new Array(16).fill(0));F[0][0]=ft(P,0,0),F[1][0]=-ft(P,0,1),F[2][0]=ft(P,0,2),F[3][0]=-ft(P,0,3),F[0][2]=ft(P,2,0),F[1][2]=-ft(P,2,1),F[2][2]=ft(P,2,2),F[3][2]=-ft(P,2,3),F[0][1]=-ft(P,1,0),F[1][1]=ft(P,1,1),F[2][1]=-ft(P,1,2),F[3][1]=ft(P,1,3),F[0][3]=-ft(P,3,0),F[1][3]=ft(P,3,1),F[2][3]=-ft(P,3,2),F[3][3]=ft(P,3,3);for(var L=P[0][0]*F[0][0]+P[1][0]*F[0][1]+P[2][0]*F[0][2]+P[3][0]*F[0][3],R=0;R<F.length;R++)for(var A=0;A<F.length;A++)F[R][A]/=L;return F}(r),S=Yt(x0($,{width:w,height:x},e),[1,8]),E=[1,x,w,1];return Oe(ks.transform(j(u,E),S,"bilinear","constant",0,[e.height,e.width]),[0,3])}),_e(u)),[2,{landmarks:d,auxiliaryLandmarks:h,worldLandmarks:p,segmentationMask:f}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return Ie(this,void 0,void 0,function(){var t,s,r,o,i,a,u,l,c,d,h,p,f;return ke(this,function(g){switch(g.label){case 0:return t=e[0],s=e[1],r=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,nm(t,m4)];case 2:return[4,t4(g.sent(),r,y4)];case 3:return u=g.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,nm(o,g4)];case 4:return d=g.sent(),h=d.slice(0,33),p=function(y,x,w){for(var $=[],S=0;S<y.length;S++){var E=Be({},x[S]);E.score=y[S].score,$.push(E)}return $}(l,h),f=this.enableSegmentation?function(y,x,w){return fe(function(){var $=Oe(y,[0]),S=$.shape[2];if(S===1){var E=$;switch(x.activation){case"none":break;case"sigmoid":E=Rn(E);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(x.activation,")"))}var P=E;return Oe(P,[2])}throw new Error("Unsupported number of tensor channels ".concat(S))})}(i,v4):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:p,segmentationMask:f}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return sm(Ya(em(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,om)},n.prototype.poseLandmarkFiltering=function(e,t,s,r){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var u=Ya(em(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new rm(im)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new rm(im)),i=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new eu(x4)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,r,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new eu(b4)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,r,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new eu(w4)),a=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else o=e,i=t,a=s;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},n}();function k4(n){return Ie(this,void 0,void 0,function(){var e,t,s,r,o,i;return ke(this,function(a){switch(a.label){case 0:return e=function(u){var l=Be({},u??Js);if(l.enableSmoothing==null&&(l.enableSmoothing=Js.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=Js.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=Js.smoothSegmentation),l.modelType==null&&(l.modelType=Js.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=Js.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([pr(e.detectorModelUrl,{fromTFHub:t}),pr(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return r=a.sent(),o=r[0],i=r[1],[2,new I4(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Ts,Cn,S0=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,r=t.keypointTrackerParams.keypointFalloff;s<r.length;s++){var o=r[s];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(s){return e-s.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,s){for(var r=Array.from(Array(t[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var u=a[i];if(r.length!==0){for(var l=-1,c=-1,d=0,h=r;d<h.length;d++){var p=h[d],f=t[u][p];f>=this.minSimilarity&&f>c&&(l=p,c=f)}if(l>=0){var g=this.tracks[l];g=Object.assign(g,this.createTrack(e[u],s,g.id)),e[u].id=g.id;var y=r.indexOf(l);r.splice(y,1)}else o.push(u)}else o.push(u)}for(var x=0,w=o;x<w.length;x++){u=w[x];var $=this.createTrack(e[u],s);this.tracks.push($),e[u].id=$.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,s){return s.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var r={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:Is([],e.keypoints,!0).map(function(o){return Be({},o)})};return e.box!==void 0&&(r.box=Be({},e.box)),r},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(s){return!e.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),N4=function(n){function e(t){return n.call(this,t)||this}return p0(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(r){return s.tracks.map(function(o){return s.iou(r,o)})})},e.prototype.iou=function(t,s){var r=Math.max(t.box.xMin,s.box.xMin),o=Math.max(t.box.yMin,s.box.yMin),i=Math.min(t.box.xMax,s.box.xMax),a=Math.min(t.box.yMax,s.box.yMax);if(r>=i||o>=a)return 0;var u=(i-r)*(a-o);return u/(t.box.width*t.box.height+s.box.width*s.box.height-u)},e}(S0),T4=function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return p0(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],r=0,o=t;r<o.length;r++){for(var i=o[r],a=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];a.push(this.oks(i,c))}s.push(a)}return s},e.prototype.oks=function(t,s){for(var r=this.area(s.keypoints)+1e-6,o=0,i=0,a=0;a<t.keypoints.length;++a){var u=t.keypoints[a],l=s.keypoints[a];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){i+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),d=2*this.keypointFalloff[a];o+=Math.exp(-1*c/(2*r*Math.pow(d,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(t){var s=this,r=t.filter(function(u){return u.score>s.keypointThreshold}),o=Math.min.apply(Math,Is([1],r.map(function(u){return u.x}),!1)),i=Math.max.apply(Math,Is([0],r.map(function(u){return u.x}),!1)),a=Math.min.apply(Math,Is([1],r.map(function(u){return u.y}),!1));return(i-o)*(Math.max.apply(Math,Is([0],r.map(function(u){return u.y}),!1))-a)},e}(S0);function E4(n){switch(n){case Cn.BlazePose:return xo.reduce(function(e,t,s){return e[t]=s,e},{});case Cn.PoseNet:case Cn.MoveNet:return In.reduce(function(e,t,s){return e[t]=s,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Ts||(Ts={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(Cn||(Cn={}));var am=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],$0={modelType:"SinglePose.Lightning",enableSmoothing:!0},um={},lm={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},tu={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},cm={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function R4(n,e,t,s){for(var r={},o=0,i=In;o<i.length;o++){var a=i[o];r[a]=[e[t[a]].y*s.height,e[t[a]].x*s.width]}if(function(w,$){return(w[$.left_hip].score>.2||w[$.right_hip].score>.2)&&(w[$.left_shoulder].score>.2||w[$.right_shoulder].score>.2)}(e,t)){var u=(r.left_hip[0]+r.right_hip[0])/2,l=(r.left_hip[1]+r.right_hip[1])/2,c=function(w,$,S,E,P){for(var F=["left_shoulder","right_shoulder","left_hip","right_hip"],L=0,R=0,A=0;A<F.length;A++)(X=Math.abs(E-S[F[A]][0]))>L&&(L=X),(ee=Math.abs(P-S[F[A]][1]))>R&&(R=ee);for(var k=0,W=0,G=0,K=Object.keys(S);G<K.length;G++){var X,ee,ce=K[G];w[$[ce]].score<.2||((X=Math.abs(E-S[ce][0]))>k&&(k=X),(ee=Math.abs(P-S[ce][1]))>W&&(W=ee))}return[L,R,k,W]}(e,t,r,u,l),d=c[0],h=c[1],p=c[2],f=c[3],g=Math.max(1.9*h,1.9*d,1.2*p,1.2*f),y=[u-(g=Math.min(g,Math.max(l,s.width-l,u,s.height-u))),l-g];if(g>Math.max(s.width,s.height)/2)return Yu(n==null,s);var x=2*g;return{yMin:y[0]/s.height,xMin:y[1]/s.width,yMax:(y[0]+x)/s.height,xMax:(y[1]+x)/s.width,height:(y[0]+x)/s.height-y[0]/s.height,width:(y[1]+x)/s.width-y[1]/s.width}}return Yu(n==null,s)}function Yu(n,e){var t,s,r,o;return n?e.width>e.height?(t=1,s=e.height/e.width,r=0,o=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(t=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,o=0):(t=1,s=e.height/e.width,r=0,o=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:o,yMax:r+t,xMax:o+s,height:t,width:s}}function _4(n){var e,t=n==null?$0:Be({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(am.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(am));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Ts.BoundingBox),t.trackerType===Ts.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(s){var r=dm(tu,s);return r.keypointTrackerParams=Be({},tu.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),r}(t.trackerConfig):t.trackerConfig=tu;else{if(t.trackerType!==Ts.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,dm(cm,e)):t.trackerConfig=cm}return t}function dm(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var A4=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=E4(Cn.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new qu(lm),this.cropRegionFilterYMin=new Xn(.9),this.cropRegionFilterXMin=new Xn(.9),this.cropRegionFilterYMax=new Xn(.9),this.cropRegionFilterXMax=new Xn(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Ts.Keypoint?this.tracker=new T4(t.trackerConfig):t.trackerType===Ts.BoundingBox&&(this.tracker=new N4(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return Ie(this,void 0,void 0,function(){var t,s,r,o,i;return ke(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return ro()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=a.sent(),a.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},o=0,i=0;i<17;++i)r.keypoints[i]={y:s[3*i],x:s[3*i+1],score:s[3*i+2]},r.keypoints[i].score>.2&&(++o,r.score+=r.keypoints[i].score);return o>0&&(r.score/=o),[2,r]}})})},n.prototype.runMultiPersonPoseModel=function(e){return Ie(this,void 0,void 0,function(){var t,s,r,o,i,a,u,l;return ke(this,function(c){switch(c.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return ro()==="webgpu"?[3,1]:(s=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:s=c.sent(),c.label=3;case 3:for(t.dispose(),r=[],o=s.length/56,i=0;i<o;++i)for(r[i]={keypoints:[]},a=56*i+51,r[i].box={yMin:s[a],xMin:s[a+1],yMax:s[a+2],xMax:s[a+3],width:s[a+3]-s[a+1],height:s[a+2]-s[a]},u=56*i+55,r[i].score=s[u],r[i].keypoints=[],l=0;l<17;++l)r[i].keypoints[l]={y:s[56*i+3*l],x:s[56*i+3*l+1],score:s[56*i+3*l+2]};return[2,r]}})})},n.prototype.estimatePoses=function(e,t,s){return t===void 0&&(t=um),Ie(this,void 0,void 0,function(){var r,o,i,a,u,l;return ke(this,function(c){switch(c.label){case 0:return t=function(d){return d==null?um:Be({},d)}(t),e==null?(this.reset(),[2,[]]):(s==null?v0(e)&&(s=1e6*e.currentTime):s*=1e3,r=zh(e),o=mr(r),i=zt(r,0),e instanceof Ke||r.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,s)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,s)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=In[l],a[u].keypoints[l].y*=o.height,a[u].keypoints[l].x*=o.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,s){return Ie(this,void 0,void 0,function(){var r,o,i,a,u=this;return ke(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=Yu(this.cropRegion==null,t)),r=fe(function(){var c=Yt([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),d=Bn([1],"int32"),h=[u.modelInputResolution.height,u.modelInputResolution.width];return ze(ks.cropAndResize(e,c,d,h,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(o=l.sent(),r.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,s,1)),a=R4(this.cropRegion,o.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(e,t,s){return Ie(this,void 0,void 0,function(){var r,o,i,a,u,l,c,d,h,p,f,g=this;return ke(this,function(y){switch(y.label){case 0:return t.width>t.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=ks.resizeBilinear(e,[i,o]),u=o,l=32*Math.ceil(i/32),a=ns(r,[[0,0],[0,l-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*t.width/t.height),i=this.multiPoseMaxDimension,r=ks.resizeBilinear(e,[i,o]),u=32*Math.ceil(o/32),l=i,a=ns(r,[[0,0],[0,0],[0,u-o],[0,0]])),r.dispose(),e.dispose(),c=ze(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(d=y.sent(),c.dispose(),d=d.filter(function(x){return x.score>=g.minPoseScore}),p=0;p<d.length;++p)for(h=0;h<d[p].keypoints.length;++h)d[p].keypoints[h].y*=l/i,d[p].keypoints[h].x*=u/o;if(this.enableTracking&&(this.tracker.apply(d,s),this.enableSmoothing)){for(p=0;p<d.length;++p)this.keypointFilterMap.has(d[p].id)||this.keypointFilterMap.set(d[p].id,new qu(lm)),d[p].keypoints=this.keypointFilterMap.get(d[p].id).apply(d[p].keypoints,s,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(x,w){f.has(w)||g.keypointFilterMap.delete(w)})}return[2,d]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:s,yMax:r,xMax:o,height:r-t,width:o-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function P4(n){return n===void 0&&(n=$0),Ie(this,void 0,void 0,function(){var e,t,s,r;return ke(this,function(o){switch(o.label){case 0:return e=_4(n),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,pr(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return t=o.sent(),[3,4];case 2:return r=void 0,e.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,pr(r,{fromTFHub:s})];case 3:t=o.sent(),o.label=4;case 4:return ro()==="webgl"&&M().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new A4(t,e)]}})})}var hm={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},pm=["MobileNetV1","ResNet50"],fm={MobileNetV1:[8,16],ResNet50:[16]},D4=[8,16,32],mm={MobileNetV1:[.5,.75,1],ResNet50:[1]},gm=[1,2,4],ym={maxPoses:1,flipHorizontal:!1},O4={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},F4=[-123.15,-115.9,-103.06];function nu(n){return Math.floor(n/2)}var L4=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(nu(e),e);)this.exchange(e,nu(e)),e=nu(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=s},n}();function B4(n,e,t,s,r,o){for(var i=o.shape,a=i[0],u=i[1],l=!0,c=Math.max(t-r,0),d=Math.min(t+r+1,a),h=c;h<d;++h){for(var p=Math.max(s-r,0),f=Math.min(s+r+1,u),g=p;g<f;++g)if(o.get(h,g,n)>e){l=!1;break}if(!l)break}return l}function z4(n){return Ie(this,void 0,void 0,function(){return ke(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function I0(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+17)}}function k0(n,e,t){var s=I0(n.heatmapY,n.heatmapX,n.id,t),r=s.y,o=s.x;return{x:n.heatmapX*e+o,y:n.heatmapY*e+r}}function N0(n,e,t,s){var r=t.x,o=t.y;return n.some(function(i){var a,u,l,c,d,h,p=i.keypoints;return a=o,u=r,l=p[s].y,c=p[s].x,(d=l-a)*d+(h=c-u)*h<=e})}var xm=In.reduce(function(n,e,t){return n[e]=t,n},{}),T0=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[xm[e],xm[t]]}),su=T0.map(function(n){return n[1]}),bm=T0.map(function(n){return n[0]});function wm(n,e,t){return n<e?e:n>t?t:n}function ru(n,e,t,s){return{y:wm(Math.round(n.y/e),0,t-1),x:wm(Math.round(n.x/e),0,s-1)}}function vm(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Cm(n,e,t,s,r,o,i,a){a===void 0&&(a=2);for(var u=s.shape,l=u[0],c=u[1],d={y:e.y,x:e.x},h=vm(d,function(w,$,S){var E=S.shape[2]/2;return{y:S.get($.y,$.x,w),x:S.get($.y,$.x,E+w)}}(n,ru(d,o,l,c),i)),p=0;p<a;p++){var f=ru(h,o,l,c),g=I0(f.y,f.x,t,r);h=vm({x:f.x*o,y:f.y*o},{x:g.x,y:g.y})}var y=ru(h,o,l,c),x=s.get(y.y,y.x,t);return{y:h.y,x:h.x,name:In[t],score:x}}function V4(n,e,t,s,r,o){var i=e.shape[2],a=su.length,u=new Array(i),l=n.part,c=n.score,d=k0(l,s,t);u[l.id]={score:c,name:In[l.id],y:d.y,x:d.x};for(var h=a-1;h>=0;--h){var p=su[h],f=bm[h];u[p]&&!u[f]&&(u[f]=Cm(h,u[p],f,e,t,s,o))}for(h=0;h<a;++h)p=bm[h],f=su[h],u[p]&&!u[f]&&(u[f]=Cm(h,u[p],f,e,t,s,r));return u}function M4(n,e,t){return t.reduce(function(s,r,o){var i=r.y,a=r.x,u=r.score;return N0(n,e,{y:i,x:a},o)||(s+=u),s},0)/t.length}function W4(n,e,t,s,r,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),Ie(this,void 0,void 0,function(){var u,l,c,d,h,p,f,g,y,x,w,$;return ke(this,function(S){switch(S.label){case 0:return[4,z4([n,e,t,s])];case 1:for(u=S.sent(),l=u[0],c=u[1],d=u[2],h=u[3],p=[],f=function(E,P,F){for(var L=F.shape,R=L[0],A=L[1],k=L[2],W=new L4(R*A*k,function(ce){return ce.score}),G=0;G<R;++G)for(var K=0;K<A;++K)for(var X=0;X<k;++X){var ee=F.get(G,K,X);ee<E||B4(X,ee,G,K,P,F)&&W.enqueue({score:ee,part:{heatmapY:G,heatmapX:K,id:X}})}return W}(i,1,l),g=a*a;p.length<o&&!f.empty();)y=f.dequeue(),x=k0(y.part,r,c),N0(p,g,x,y.part.id)||(w=V4(y,l,c,r,d,h),$=M4(p,g,w),p.push({keypoints:w,score:$}));return[2,p]}})})}function E0(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var U4=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=se(this.outputShape),this.dispatch=J(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(E0("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function G4(n,e){if(dr()instanceof Cr)return function(t,s){var r=dr(),o=new U4(s.shape),i=r.runWebGPUProgram(o,[t,s],"float32");return At().makeTensorFromTensorInfo(i)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var H4=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=se(t),this.dispatch=J(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(E0("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function j4(n,e){if(dr()instanceof Cr)return function(t,s){var r=dr(),o=new H4(t.shape),i=r.runWebGPUProgram(o,[t,s],"float32");return At().makeTensorFromTensorInfo(i)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function R0(n){var e=n.shape,t=e[0],s=e[1],r=e[2];return fe(function(){var o,i,a=j(n,[t*s,r]),u=py(a,0),l=zt(Se(u,ve(s,"int32")),1),c=zt((o=u,i=s,fe(function(){var d=Se(o,ve(i,"int32"));return ye(o,Y(d,ve(i,"int32")))})),1);return nt([l,c],1)})}function K4(n,e,t){return fe(function(){var s=function(r,o){for(var i=[],a=0;a<In.length;a++){var u=r.get(a,0).valueOf(),l=r.get(a,1).valueOf(),c=X4(u,l,a,o),d=c.x,h=c.y;i.push(h),i.push(d)}return Yt(i,[In.length,2])}(n,t);return ue(ze(Y(n.toTensor(),ve(e,"int32")),"float32"),s)})}function X4(n,e,t,s){return{y:s.get(n,e,t),x:s.get(n,e,t+In.length)}}function q4(n,e,t){return Ie(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,d,h;return ke(this,function(p){switch(p.label){case 0:return s=0,r=R0(n),[4,Promise.all([n.buffer(),e.buffer(),r.buffer()])];case 1:return o=p.sent(),i=o[0],a=o[1],u=o[2],[4,(l=K4(u,t,a)).buffer()];case 2:return c=p.sent(),d=Array.from(function(f,g){for(var y=g.shape[0],x=new Float32Array(y),w=0;w<y;w++){var $=g.get(w,0),S=g.get(w,1);x[w]=f.get($,S,w)}return x}(i,u)),h=d.map(function(f,g){return s+=f,{y:c.get(g,0),x:c.get(g,1),score:f,name:In[g]}}),r.dispose(),l.dispose(),[2,{keypoints:h,score:s/h.length}]}})})}function Y4(n,e,t){return Ie(this,void 0,void 0,function(){var s,r,o;return ke(this,function(i){return s=R0(n),r=function(a,u,l){return fe(function(){var c=j4(a,l);return ue(ze(Y(a,ve(u,"int32")),"float32"),c)})}(s,t,e),o=G4(n,s),[2,[r,o]]})})}function Sm(n,e){return(n-1)%e==0}var $m="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Im="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function km(n,e){return function(t,s){return(t-1)%s==0}(n,e)?n:Math.floor(n/e)*e+1}var Nm=function(){function n(e,t){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;T(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var r,o,i=(r=t.inputResolution,o=t.outputStride,{height:km(r.height,o),width:km(r.width,o)});(function(a){T(D4.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,u){T(Sm(a.height,u),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(u,".")}),T(Sm(a.width,u),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(u,".")})}(i,t.outputStride),this.inputResolution=i,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=ym),Ie(this,void 0,void 0,function(){return ke(this,function(s){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,s){return t===void 0&&(t=ym),s===void 0&&(s=!1),Ie(this,void 0,void 0,function(){var r,o,i,a,u,l,c,d,h,p,f,g,y,x,w,$,S,E;return ke(this,function(P){switch(P.label){case 0:return r=function(F){var L=F;if(L.maxPoses==null&&(L.maxPoses=1),L.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(L.maxPoses,". Should be > 0."));if(L.maxPoses>1){if((L=Be(Be({},O4),L)).scoreThreshold<0||L.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(L.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(L.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(L.nmsRadius,"."))}return L}(t),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=r.maxPoses,o=Xu(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=o.imageTensor,a=o.padding,u=this.architecture==="ResNet50"?ue(i,F4):w0(i,[-1,1]),l=this.posenetModel.predict(u),this.architecture==="ResNet50"?(c=Oe(l[2],[0]),d=Oe(l[3],[0]),h=Oe(l[0],[0]),p=Oe(l[1],[0])):(c=Oe(l[0],[0]),d=Oe(l[1],[0]),h=Oe(l[2],[0]),p=Oe(l[3],[0])),f=Rn(d),this.maxPoses!==1?[3,5]:s?[4,Y4(f,c,this.outputStride)]:[3,2]);case 1:return y=P.sent(),w=y[0],x=y[1],g=[w,x],[3,4];case 2:return[4,q4(f,c,this.outputStride)];case 3:w=P.sent(),g=[w],P.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,W4(f,c,h,p,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:g=P.sent(),P.label=7;case 7:if(s){if(r.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");$=this.getCanvasInfo(mr(e),this.inputResolution,a)}else E=mr(e),S=function(F,L,R,A){var k=L.height,W=L.width,G=k/(R.height*(1-A.top-A.bottom)),K=W/(R.width*(1-A.left-A.right)),X=-A.top*R.height,ee=-A.left*R.width;if(K===1&&G===1&&X===0&&ee===0)return F;for(var ce=0,de=F;ce<de.length;ce++)for(var he=0,Ce=de[ce].keypoints;he<Ce.length;he++){var Re=Ce[he];Re.x=(Re.x+ee)*K,Re.y=(Re.y+X)*G}return F}(g,E,this.inputResolution,a),r.flipHorizontal&&(S=function(F,L){for(var R=0,A=F;R<A.length;R++)for(var k=0,W=A[R].keypoints;k<W.length;k++){var G=W[k];G.x=L.width-1-G.x}return F}(S,E));return i.dispose(),u.dispose(),_e(l),c.dispose(),d.dispose(),h.dispose(),p.dispose(),f.dispose(),[2,s?[g,$]:S]}})})},n.prototype.getCanvasInfo=function(e,t,s){var r=e.height,o=e.width,i=r/(t.height*(1-s.top-s.bottom)),a=o/(t.width*(1-s.left-s.right)),u=-s.top*t.height;return[-s.left*t.width,u,a,i,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function Q4(n){return n===void 0&&(n=hm),Ie(this,void 0,void 0,function(){var e,t,s,r,o;return ke(this,function(i){switch(i.label){case 0:return(e=function(c){var d=c||hm;if(d.architecture==null&&(d.architecture="MobileNetV1"),pm.indexOf(d.architecture)<0)throw new Error("Invalid architecture ".concat(d.architecture,". ")+"Should be one of ".concat(pm));if(d.inputResolution==null&&(d.inputResolution={height:257,width:257}),d.outputStride==null&&(d.outputStride=16),fm[d.architecture].indexOf(d.outputStride)<0)throw new Error("Invalid outputStride ".concat(d.outputStride,". ")+"Should be one of ".concat(fm[d.architecture]," ")+"for architecture ".concat(d.architecture,"."));if(d.multiplier==null&&(d.multiplier=1),mm[d.architecture].indexOf(d.multiplier)<0)throw new Error("Invalid multiplier ".concat(d.multiplier,". ")+"Should be one of ".concat(mm[d.architecture]," ")+"for architecture ".concat(d.architecture,"."));if(d.quantBytes==null&&(d.quantBytes=4),gm.indexOf(d.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(d.quantBytes,". ")+"Should be one of ".concat(gm," ")+"for architecture ".concat(d.architecture,"."));if(d.architecture==="MobileNetV1"&&d.outputStride===32&&d.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return d}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,u=e.quantBytes,l="model-stride".concat(a,".json"),t=u===4?Im+"float/"+l:Im+"quant".concat(u,"/")+l,[4,pr(e.modelUrl||t)]);case 1:return s=i.sent(),[2,new Nm(s,e)];case 2:return r=function(c,d,h){var p={1:"100",.75:"075",.5:"050"},f="model-stride".concat(c,".json");return h===4?$m+"float/".concat(p[d],"/")+f:$m+"quant".concat(h,"/").concat(p[d],"/")+f}(e.outputStride,e.multiplier,e.quantBytes),[4,pr(e.modelUrl||r)];case 3:return o=i.sent(),[2,new Nm(o,e)]}var a,u,l})})}function Tm(n,e){return Ie(this,void 0,void 0,function(){var t,s;return ke(this,function(r){switch(n){case Cn.PoseNet:return[2,Q4(e)];case Cn.BlazePose:if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,k4(e)];if(t.runtime==="mediapipe")return[2,Zz(e)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case Cn.MoveNet:return[2,P4(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cs={},Zo={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Z4(n,e){Cs[n]=e}function cn(n,e){if(!(n in Cs)||e!=null){const s=eV(n,e);if(s!==null)Cs[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Cs[n];return t==null||t.isContextLost()?(delete Cs[n],cn(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Cs[n])}function J4(n){if(!M().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function eV(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??J4(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Cs[n]},!1),M().getBool("SOFTWARE_WEBGL_ENABLED")&&(Zo.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Zo)||t.getContext("experimental-webgl",Zo):t.getContext("webgl2",Zo)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bo;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(bo||(bo={}));var Vt;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Vt||(Vt={}));var ot;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ot||(ot={}));function Ao(n,e){return[e,n]}function tV(n,e){return n*e}function Jo(n){const e=H(n),t=Math.ceil(e/4);return du(t)}function Ir(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function nV(n,e){const[t,s]=Ir(n,e);return t*s*4}function Vh(n,e){const t=n;let s,r,o,i,a,u,l,c,d,h;return M().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,c=1,d=t.HALF_FLOAT,h=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,i=t.RGBA,a=n.RGBA,l=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,h=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function re(n,e){const t=e();return M().getBool("DEBUG")&&sV(n),t}function sV(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+aV(n,e))}const rV=596e-10,oV=65504;function iV(n){return!!(M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||rV<Math.abs(n)&&Math.abs(n)<oV)}function aV(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function ei(n,e){return Gn(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function uV(n,e){const t=Gn(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(re(n,()=>n.shaderSource(t,e)),re(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function lV(n,e){const t=Gn(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(re(n,()=>n.shaderSource(t,e)),re(n,()=>n.compileShader(t)),M().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw _0(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const cV=/ERROR: [0-9]+:([0-9]+):/g;function _0(n,e){const t=cV.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,i=r.map((d,h)=>rr((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const u=i.slice(0,s-1),l=i.slice(s-1,s),c=i.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${rr(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function dV(n){return Gn(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function hV(n,e){if(re(n,()=>n.linkProgram(e)),!M().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function ou(n,e){if(re(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function pV(n,e){const t=Gn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),re(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function fV(n,e){const t=Gn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return re(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),re(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function mV(n){return Gn(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function gV(n,e){const t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function yV(n){return Gn(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Em(n,e,t,s,r,o,i){const a=n.getAttribLocation(e,t);return a===-1?!1:(re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),re(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,o,i)),re(n,()=>n.enableVertexAttribArray(a)),!0)}function xV(n,e,t){SV(n,t),re(n,()=>n.activeTexture(n.TEXTURE0+t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function bV(n,e,t){return Gn(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function wV(n,e,t){return n.getUniformLocation(e,t)}function vV(n,e,t,s){re(n,()=>xV(n,e,s)),re(n,()=>n.uniform1i(t,s))}function iu(n,e,t){re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Rm(n,e){re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function ti(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+CV(n,e))}function CV(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Gn(n,e,t){const s=re(n,()=>e());if(s==null)throw new Error(t);return s}function SV(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function gr(n,e=2){return H(n.slice(0,n.length-e))}function yr(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function ni(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[gr(n),...yr(n)]),e}function $V(n,e=!1){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=M().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&M().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,u)=>u>=n.length-2?ol(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=rs(n).newShape);let r=H(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const i=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=gr(n);let u=2,l=2;n.length&&([u,l]=yr(n)),r=a*(u/2)*(l/2),o=du(r).map(c=>c*2)}else o=du(r);return o}function si(n){return n%2===0}function Bi(n,e){if(n=n.slice(-2),e=e.slice(-2),Ae(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||si(t)&&si(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&si(n[0])&&si(e[0])}let au,uu;function IV(n){if(au==null){const e=cn(n);au=e.getParameter(e.MAX_TEXTURE_SIZE)}return au}function kV(n){if(uu==null){const e=cn(n);uu=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,uu)}function NV(n){if(n===0)return 0;let e;const t=cn(n);return Xt(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Xt(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Xt(n,e){return n.getExtension(e)!=null}function _m(n){try{if(cn(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function TV(n){if(n===0)return!1;const e=cn(n);if(n===1){if(!Xt(e,"OES_texture_float"))return!1}else if(!Xt(e,"EXT_color_buffer_float"))return!1;return Qu(e)}function EV(n){if(n===0)return!1;const e=cn(n);if(n===1){if(!Xt(e,"OES_texture_float")||!Xt(e,"WEBGL_color_buffer_float"))return!1}else{if(Xt(e,"EXT_color_buffer_float"))return Qu(e);const s="EXT_color_buffer_half_float";if(Xt(e,s)){const r=e.getExtension(s);return RV(e,r)}return!1}return Qu(e)}function Qu(n){const e=Vh(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),i}function RV(n,e){const t=Vh(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(i),a}function _V(n){return n!==2?!1:cn(n).fenceSync!=null}function Po(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&T(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ae=M();ae.registerFlag("HAS_WEBGL",()=>ae.getNumber("WEBGL_VERSION")>0);ae.registerFlag("WEBGL_VERSION",()=>_m(2)?2:_m(1)?1:0);ae.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ae.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ae.get("WEBGL_VERSION")===2);ae.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ae.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ae.registerFlag("WEBGL_PACK",()=>ae.getBool("HAS_WEBGL"));ae.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_CLIP",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_REDUCE",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_LAZILY_UNPACK",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_CONV_IM2COL",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ae.getBool("WEBGL_PACK"));ae.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>IV(ae.getNumber("WEBGL_VERSION")));ae.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>kV(ae.getNumber("WEBGL_VERSION")));ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ae.getNumber("WEBGL_VERSION");return n===0?0:NV(n)});ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ae.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Xg());ae.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>TV(ae.getNumber("WEBGL_VERSION")));ae.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ae.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ae.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ae.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>EV(ae.getNumber("WEBGL_VERSION")));ae.registerFlag("WEBGL_FENCE_API_ENABLED",()=>_V(ae.getNumber("WEBGL_VERSION")));ae.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ae.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ae.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ae.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Xg()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ae.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ae.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ae.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ae.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ae.registerFlag("WEBGL_EXP_CONV",()=>!1);ae.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ae.getBool("IS_TEST"));ae.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ae.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ae.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ae.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(){let n,e,t,s,r,o,i,a,u,l;return M().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",i="out vec4 outputColor;",a=M().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(n,e,t="index"){const s=Xe(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / ${r}`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${i}; ${a};`}).join("")}function ca(n,e,t="index"){const s=Xe(e);return s.map((r,o)=>{const i=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,a=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function AV(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function PV(n,e,t="index"){const s=n.map((o,i)=>i),r=AV(s,e);return r.map((o,i)=>{const a=`int ${n[i]} = ${t} / ${r[i]}`,u=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r[i]}`:`index -= ${n[i]} * ${r[i]}`;return`${a}; ${u};`}).join("")}function Mh(n){const e=Xe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Wh(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const A0=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:P0}=BT;function DV(n,e,t){const s=[];if(n.forEach(p=>{const f=H(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Uh(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(p=>OV(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=wt(),u=BV(a);let l,c,d=MV(a);return e.isPacked?(l=FV(e.logicalShape,i,t.enableShapeUniforms),c=VV(a)):(l=LV(e.logicalShape,i,t.enableShapeUniforms),c=zV(a)),t.packedInputs&&(d+=HV),[d,u,c,r,l,o,t.userCode].join(`
`)}function kr(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return sM(n,e);case 1:return oM(n,e);case 2:return aM(n,e);case 3:return lM(n,e);case 4:return dM(n,e);case 5:return hM(n);case 6:return pM(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function D0(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return nM(n);case 1:return rM(n,e);case 2:return iM(n,e);case 3:return uM(n,e);default:return cM(n,e)}}function OV(n,e,t=!1,s){let r="";t?r+=D0(n,s):r+=kr(n,s);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(t?r+=fM(n,e):r+=mM(n,e)),r}function FV(n,e,t){switch(n.length){case 0:return O0();case 1:return jV(n,e,t);case 2:return eM(n,e,t);case 3:return XV(n,e,t);default:return YV(n,e,t)}}function LV(n,e,t){switch(n.length){case 0:return O0();case 1:return KV(n,e,t);case 2:return tM(n,e,t);case 3:return qV(n,e,t);case 4:return QV(n,e,t);case 5:return ZV(n,e);case 6:return JV(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function BV(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function zV(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function VV(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function MV(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${WV}
    ${UV}
    ${GV}
  `}const WV=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,UV=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,GV=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,HV=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function O0(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function jV(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function KV(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function XV(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function qV(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${ca(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Gs(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function YV(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let i=o,a="",u="b, r, c";for(let l=2;l<n.length-1;l++)i*=n[n.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function QV(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${ca(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Gs(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function ZV(n,e){const t=Gs(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function JV(n,e){const t=Gs(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function eM(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Ae(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function tM(n,e,t){return Ae(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Hs(n){return`offset${n}`}function nM(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=wt();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function sM(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Hs(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[a,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function rM(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=wt();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function oM(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Nr(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],i=r[1];if(i===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Hs(t);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function iM(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],u=wt();if(o!=null&&Ae(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function aM(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&Ae(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const h=o[0],p=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:a}=rs(t),u=i;if(u.length<t.length){const h=Tr(n,u),p=["row","col"];return`
      ${kr(h,e)}
      float ${r}(int row, int col) {
        return ${r}(${Er(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Nr(n)}
      }
    `;const l=o[0],c=o[1],d=Hs(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  `:l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function uM(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const h=t.slice(1),p=[1,2],f=Tr(n,h),g=["b","row","col"];return`
        ${D0(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Er(g,p)});
        }
      `}const a=wt();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const u=i[0],l=i[1],c=Math.ceil(t[2]/2),d=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${d}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function lM(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:u}=rs(t),l=a;if(l.length<t.length){const g=Tr(n,l),y=["row","col","depth"];return`
        ${kr(g,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Er(y,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Nr(n)}
      }
    `;const c=n.shapeInfo.texShape,d=c[0],h=c[1],p=n.shapeInfo.flatOffset;if(h===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(h===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Hs(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${s}, uv);
      }
  `}function cM(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=wt();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<i-1;g++)p=`int b${g}, `+p,h*=o[i-g-1],f=`b${g} * ${h} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${r.texture2D}(${t}, uv);
    }
  `}function dM(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:u,keptDims:l}=rs(t);if(u.length<t.length){const w=Tr(n,u),$=["row","col","depth","depth2"];return`
      ${kr(w,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Er($,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Nr(n)}
      }
    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;const x=Hs(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${x});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${x});
      return sampleTexture(${s}, uv);
    }
  `}function hM(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,i=e[2]*o,a=e[1]*i,{newShape:u,keptDims:l}=rs(e);if(u.length<e.length){const g=Tr(n,u),y=["row","col","depth","depth2","depth3"];return`
      ${kr(g)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Er(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${r})) +
          depth3;
        ${Nr(n)}
      }
    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1];if(p===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Hs(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function pM(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=rs(e);if(r.length<e.length){const y=Tr(n,r),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${kr(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Er(x,o)});
      }
    `}const i=e[5],a=e[4]*i,u=e[3]*a,l=e[2]*u,c=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Nr(n)}
      }
    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Hs(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Nr(n){const e=n.name,t=H(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function fM(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=P0(n.shapeInfo.logicalShape,e.logicalShape),u=Le(i),l=i-o;let c;const d=["x","y","z","w","u","v"];o===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(w=>`coords.${d[w+l]} = 0;`).join(`
`);let h="";i<2&&o>0?h="coords":h=n.shapeInfo.logicalShape.map((w,$)=>`coords.${d[$+l]}`).join(", ");let p="return outputValue;";const g=H(n.shapeInfo.logicalShape)===1,x=H(e.logicalShape)===1;if(o===1&&!g&&!x)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!x)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const w=o-2,$=o-1;a.indexOf(w)>-1&&a.indexOf($)>-1?p="return vec4(outputValue.x);":a.indexOf(w)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf($)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${h});
      ${p}
    }
  `}function mM(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===u&&n.shapeInfo.flatOffset==null&&Ae(i,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=Le(u),c=P0(n.shapeInfo.logicalShape,e.logicalShape),d=u-a;let h;const p=["x","y","z","w","u","v"];a===0?h="":u<2&&c.length>=1?h="coords = 0;":h=c.map(g=>`coords.${p[g+d]} = 0;`).join(`
`);let f="";return u<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,y)=>`coords.${p[y+d]}`).join(", "),`
    float ${r}() {
      ${l} coords = getOutputCoords();
      ${h}
      return get${s}(${f});
    }
  `}function Le(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Uh(n,e,t){const{newShape:s,keptDims:r}=rs(e),o=e.length,i=n&&o===3&&e[0]===1,a=i?e.slice(1):s,u=!n&&o>1&&!Ae(e,t)&&s.length<o||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:r}}function Tr(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Er(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gM(n,e,t,s){const r=t.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:h}}),o=r.map(c=>c.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=DV(r,i,e),u=lV(n.gl,a),l=n.createProgram(u);return M().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(l),Object.assign({program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i},F0(n,e,l)))}function F0(n,e,t){const s=[],r=[];let o,i,a,u=null,l=null;l=n.getUniformLocation(t,"NAN",!1),M().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const d of e.variableNames){const h={name:d,uniform:n.getUniformLocation(t,d,c),offset:n.getUniformLocation(t,`offset${d}`,c)};e.enableShapeUniforms&&(h.shape=n.getUniformLocation(t,`${d}Shape`,c),h.texShape=n.getUniformLocation(t,`${d}TexShape`,c)),s.push(h)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",c),a=n.getUniformLocation(t,"outShapeStrides",c),i=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const d of e.customUniforms)r.push(n.getUniformLocation(t,d.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function Am(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],i=o.shape;if(!Ae(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,u=o.isUniform?null:o.texData.texShape;if(!Ae(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function yM(n,e,t,s,r){e.program.enableShapeUniforms||(Am(e.inShapeInfos,t),Am([e.outShapeInfo],[s]));const o=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),M().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const l=t[u],{uniform:c,offset:d,shape:h,texShape:p}=e.variablesLocations[u];if(h){const{uniformShape:f}=Uh(e.program.packedInputs,l.shape,l.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(h,new Int32Array(f));break;case 2:n.gl.uniform2iv(h,new Int32Array(f));break;case 3:n.gl.uniform3iv(h,new Int32Array(f));break;case 4:n.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),c!=null){if(l.isUniform){if(H(l.shape)<2)n.gl.uniform1f(c,l.uniformValues[0]);else{let f=l.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(c,f)}continue}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,c,u)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=Xe(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const l=e.program.customUniforms[u],c=e.customUniformLocations[u],d=r[u];if(l.type==="float")n.gl.uniform1fv(c,d);else if(l.type==="vec2")n.gl.uniform2fv(c,d);else if(l.type==="vec3")n.gl.uniform3fv(c,d);else if(l.type==="vec4")n.gl.uniform4fv(c,d);else if(l.type==="int")n.gl.uniform1iv(c,d);else if(l.type==="ivec2")n.gl.uniform2iv(c,d);else if(l.type==="ivec3")n.gl.uniform3iv(c,d);else if(l.type==="ivec4")n.gl.uniform4iv(c,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}n.executeProgram()}function xM(n,e,t){let s="";e.concat(t).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:d}=Uh(n.packedInputs,i.shape,u);let h="",p="",f="";if(c.length===1&&n.packedInputs){const E=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];h=`${E[0]>1}_${E[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const E=Xe(c);f=`${E[0]===u[1]}_${E[E.length-1]===u[1]}`}const g=i.shape.length,y=c.length===2&&Ae(i.shape,u),x=H(i.shape)===1,w=hr(i.shape,t.shape),$=!n.packedInputs&&g===t.shape.length&&Ae(u,t.texData.texShape),S=n.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${g}_${$}_${l?d:""}_${c.length}_${x}_${w}_${y}_${h}_${p}_${f}_${S}_${a}`}else{const u=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${u}_${a}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${M().getNumber("WEBGL_VERSION")}`,o}function pt(n){return M().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bM{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=bo.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=wt();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?ca(["r","c","d"],e):Gs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=bo.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=wt();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?ca(["r","c","d"],e):Gs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vM{constructor(e){this.variableNames=["A"],this.outTexUsage=Vt.DOWNLOAD;const t=wt();this.outputShape=e,this.userCode=`
      ${A0}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vt.DOWNLOAD;const t=wt();this.outputShape=e,this.userCode=`
      ${A0}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM={R:0,G:1,B:2,A:3};class Pm{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=wt();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<s.length;a++){const u=s[a];i+=`
          if(offset == ${a}) {
            result = values[${SM[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Wh():Mh(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $M{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=wt();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const u=i*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Wh():Mh(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IM(n){const e=wt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return uV(n,t)}function kM(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return pV(n,e)}function NM(n){const e=new Uint16Array([0,1,2,2,1,3]);return fV(n,e)}function Do(n,e,t,s,r,o){gV(e,t);const i=mV(n),a=n.TEXTURE_2D;return re(n,()=>n.bindTexture(a,i)),re(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),re(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),re(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),re(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),M().getNumber("WEBGL_VERSION")===1?re(n,()=>n.texImage2D(a,0,s,e,t,0,r,o,null)):re(n,()=>n.texStorage2D(a,1,s,e,t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function L0(n){return n.internalFormatFloat}function TM(n,e,t,s){const[r,o]=Ao(e,t);return Do(n,r,o,L0(s),s.textureFormatFloat,n.FLOAT)}function B0(n){return n.internalFormatHalfFloat}function EM(n,e,t,s){const[r,o]=Ao(e,t);return Do(n,r,o,B0(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function z0(n){return n.downloadTextureFormat}function RM(n,e,t,s){const[r,o]=Ao(e,t);return Do(n,r,o,z0(s),n.RGBA,n.UNSIGNED_BYTE)}function V0(n){return n.internalFormatPackedFloat}function _M(n,e,t,s){const[r,o]=Ir(e,t);return Do(n,r,o,V0(s),n.RGBA,n.FLOAT)}function M0(n){return n.internalFormatPackedHalfFloat}function AM(n,e,t,s){const[r,o]=Ir(e,t);return Do(n,r,o,M0(s),n.RGBA,s.textureTypeHalfFloat)}function PM(n,e,t){return re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Em(n,e,"clipSpacePos",t,3,20,0)&&Em(n,e,"uv",t,2,20,12)}function DM(n,e,t,s,r,o){re(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,u;r instanceof Uint8Array?(i=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,u=n.RGBA):(i=new Float32Array(t*s*4),a=n.FLOAT,u=o.internalFormatPackedFloat),i.set(r),M().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,i)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,a,i)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function OM(n,e,t){re(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?M().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):M().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function FM(n,e,t,s){const r=n.createBuffer();re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return re(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function LM(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function BM(n,e,t,s){const[r,o]=Ao(e,t),i=4,a=new Uint8Array(tV(e*t,i));return re(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function zM(n,e,t,s,r,o,i,a){const u=n,l=new Float32Array(nV(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function VM(n,e,t){const s=new Float32Array(e*t*4);return re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lu{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=M().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Z4(t,e)):this.gl=cn(t),e=this.gl,M().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>re(o,()=>o.createVertexArray()),this.bindVertexArray=i=>re(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>re(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>re(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>re(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>re(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>re(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>re(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),M().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ei(this.gl,o),Xt(this.gl,i))this.textureHalfFloatExtension=ei(this.gl,i);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Xt(this.gl,r))this.colorBufferHalfFloatExtension=ei(this.gl,r);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Xt(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Xt(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=kM(this.gl),this.indexBuffer=NM(this.gl),this.framebuffer=yV(this.gl),this.textureConfig=Vh(this.gl,this.textureHalfFloatExtension)}get debug(){return M().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;re(e,()=>e.finish()),re(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),re(e,()=>e.deleteFramebuffer(this.framebuffer)),re(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),re(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),TM(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),EM(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),RM(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),OM(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),DM(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),AM(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),_M(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Rm(this.gl,this.framebuffer),this.outputTexture=null),re(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>BM(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,i){return zM(this.gl,e,t,s,r,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return LM(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=FM(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(M().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(o,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},t=o}else M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>VM(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=IM(t));const s=dV(t);re(t,()=>t.attachShader(s,this.vertexShader)),re(t,()=>t.attachShader(s,e)),hV(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&ou(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),PM(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(re(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&ou(this.gl,this.program),re(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?bV(this.gl,e,t):wV(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),re(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),vV(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=Ir(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&ou(this.gl,this.program),ti(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}re(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ei(this.gl,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Xp(()=>this.disposed||this.isQueryAvailable(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=MM(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in M().platform&&(s=M().platform.setTimeoutCustom.bind(M().platform)),Xp(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),iu(this.gl,e,this.framebuffer),this.debug&&ti(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(iu(this.gl,this.outputTexture,this.framebuffer),this.debug&&ti(this.gl)):Rm(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;iu(r,e,this.framebuffer),this.debug&&ti(r),this.outputTexture=e,re(r,()=>r.viewport(0,0,t,s)),re(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),re(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function MM(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:WM,bincountImpl:W0,bincountReduceImpl:UM,bitwiseAndImpl:GM,castImpl:HM,ceilImpl:jM,concatImpl:KM,equalImpl:XM,expImpl:qM,expm1Impl:YM,floorImpl:QM,gatherNdImpl:ZM,gatherV2Impl:JM,greaterImpl:eW,greaterEqualImpl:tW,lessImpl:nW,lessEqualImpl:sW,linSpaceImpl:rW,logImpl:oW,maxImpl:iW,maximumImpl:aW,minimumImpl:uW,multiplyImpl:lW,negImpl:cW,notEqualImpl:dW,prodImpl:hW,raggedGatherImpl:pW,raggedRangeImpl:fW,raggedTensorToTensorImpl:mW,rangeImpl:gW,rsqrtImpl:yW,scatterImpl:xW,sigmoidImpl:bW,simpleAbsImpl:U0,sliceImpl:wW,sparseFillEmptyRowsImpl:vW,sparseReshapeImpl:CW,sparseSegmentReductionImpl:G0,sqrtImpl:SW,staticRegexReplaceImpl:$W,stridedSliceImpl:IW,stringNGramsImpl:kW,stringSplitImpl:NW,stringToHashBucketFastImpl:TW,subImpl:EW,tileImpl:RW,topKImpl:_W,transposeImpl:Gh,uniqueImpl:AW}=Gx;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function yt(n,e){return e===1?[n]:H0(n,e)}function PW(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DW{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=pt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=yt("rc",this.rank),s=Le(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j0{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${OW(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Wh():Mh(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function OW(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?PV(["r","c","d"],"inputShape"):Gs(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FW{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=Om(t,s),o=Fm(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=Dm(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[o].pop();return this.usedTextures[o].push(u),u}let a;return r===ot.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===ot.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===ot.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===ot.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===ot.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=Om(s,r),i=Fm(t,o,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=Dm(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=M().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],c=l&&l.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function LW(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Dm(n,e,t,s,r){const o=BW(e,s);let i;if(r){const[u,l]=Ir(n[0],n[1]);i=u*l}else{const[u,l]=Ao(n[0],n[1]);i=u*l}const a=LW(t,o);return i*a}function BW(n,e){switch(n){case ot.PACKED_2X2_FLOAT32:return V0(e);case ot.PACKED_2X2_FLOAT16:return M0(e);case ot.UNPACKED_FLOAT32:return L0(e);case ot.UNPACKED_FLOAT16:return B0(e);case ot.PACKED_4X1_UNSIGNED_BYTE:return z0(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function zW(n){return M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?ot.PACKED_2X2_FLOAT32:ot.UNPACKED_FLOAT32:n?ot.PACKED_2X2_FLOAT16:ot.UNPACKED_FLOAT16}function Om(n,e){if(n===Vt.UPLOAD)return ot.PACKED_2X2_FLOAT32;if(n===Vt.RENDER||n==null)return zW(e);if(n===Vt.DOWNLOAD||n===Vt.PIXELS)return ot.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Fm(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const tn="if (isnan(x)) return x;",VW="return x;",Lm="return abs(x);",MW="return (x >= 0.0) ? x : (exp(x) - 1.0);",WW=tn+`
  return (x < 0.0) ? 0.0 : x;
`,UW=tn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jn="return x;",GW="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HW="return x;",jW=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,KW=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XW=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qW="return 1.0 / (1.0 + exp(-1.0 * x));";class qn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YW{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);const t=e.length,s=yt("rc",t),r=Le(t),o=PW(t,s),i=s.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QW=Xy,ZW=1e-7,JW=1e-4,ri={};function eU(n){return n in ri||(ri[n]={}),ri[n]}const tU=M().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),nU=600;function sU(){return M().global.screen==null?1024:M().global.screen.height*M().global.screen.width*window.devicePixelRatio*nU/1024/1024}class da extends rl{nextDataId(){return da.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!M().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof lu)t=e;else{const s=cn(M().getNumber("WEBGL_VERSION"),e);t=new lu(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=cn(M().getNumber("WEBGL_VERSION"));t=new lu(s),this.binaryCache=eU(M().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new FW(this.gpgpu),this.numMBBeforeWarning=sU(),this.texData=new rg(this,At())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,i){const a=this.makeTensorInfo(t,s),u=this.texData.get(a.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,o]},u.texShape=[r,o];const l=ni(t),c=new Pm(l,!1,i),d=this.runWebGLProgram(c,[a],s,[[r,o]]);return d.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(a),d.dataId}write(e,t,s){if((M().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||M().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Vt.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(M().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Vt.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:i,shape:a,isPacked:u}=t;if(i!=null){let h;u?h=new qn(a,jn):h=new bn(a,jn);const p=this.runWebGLProgram(h,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const l=this.activeTimers!=null;let c;l&&(c=on());let d;if(r==="complex64"){const h=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);d=mo(h,p)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=on()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=t;if(o!=null){let f;u?f=new qn(r,jn):f=new bn(r,jn);const g=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(M().getBool("DEBUG")&&!M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&M().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&M().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...Jo(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],y=f[1];d=mo(g,y)}else if(l==null)d=this.getValuesFromTexture(e);else{const f=H(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){const f=this.gpgpu.gl;re(f,()=>f.deleteBuffer(l))}const h=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&At().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:i,dtype:a,isPacked:u,texture:l}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;u?p=new qn(o,jn):p=new bn(o,jn);const f=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),d=At().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Pn(r));return Pe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Pe(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!iV(s))throw M().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=H(t);if(M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(e),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Jo(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(h),f}const i=M().getBool("WEBGL_PACK")&&r===!0,a=i?ni(t):t,u=i?new CM(a):new vM(a),l=this.runWebGLProgram(u,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=Dn(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=Dn(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);a.kernelMs=og(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:on(),endMs:null}}endTimer(e){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=on(),e)}async getQueryTime(e){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=tU){return M().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&H(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){ln("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return QW(e.shape,t)}packedUnaryOp(e,t,s){const r=new qn(e.shape,t),o=this.compileAndRun(r,[e],s);return At().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=U0(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(M().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Lm,e.dtype);const t=new bn(e.shape,Lm),s=this.compileAndRun(t,[e]);return At().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&So(s[0])){const o=s.map(i=>Qn(i));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return At().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new YW(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new DW(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[gr(e.shape),...yr(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[gr(t),...yr(t)],i=new j0(o,s),a=!0,u=[s],l=this.runWebGLProgram(i,[r],e.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:i}=s;if(t!=null){const h=H(o),p=t[0]*t[1]*4;T(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=ni(o);let u;r?u=new wM(a):u=new bM(a);const l=!0,c=[t??Jo(a)],d=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:e}],i,c,l,t);return{dtype:i,shape:o,dataId:d.dataId}}runWebGLProgram(e,t,s,r,o=!1,i){const a=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===bo.DENSE){const x=i??Jo(e.outputShape);u.texShape=x.map(w=>w*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),H(a.shape)===0)return u.values=Sn(a.dtype,0),a;const l=[],c=t.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(x.dataId);if(w.texture==null){if(!e.packedInputs&&H(x.shape)<=M().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!w.isPacked!=!!e.packedInputs)x=w.isPacked?this.unpackTensor(x):this.packTensor(x),l.push(x),w=this.texData.get(x.dataId);else if(w.isPacked&&!Bi(w.shape,x.shape)){const $=x,S=x.shape;x.shape=w.shape,x=this.packedReshape(x,S),l.push(x),w=this.texData.get(x.dataId),$.shape=S}return{shape:x.shape,texData:w,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:u,isUniform:!1},h=xM(e,c,d),p=this.getAndSaveBinary(h,()=>gM(this.gpgpu,e,c,d)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),M().get("ENGINE_COMPILE_ONLY")||yM(this.gpgpu,p,c,d,r),l.forEach(x=>this.disposeIntermediateTensorInfo(x)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=M().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const x=on();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!M().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(M().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=fe(()=>{if(!M().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=M().getBool("DEBUG");M().set("DEBUG",!1);const t=this.abs(ve(1e-8)).dataSync()[0];if(M().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?ZW:JW}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:i,usage:a,isPacked:u}=t;if(i!=null)return;const l=this.activeTimers!=null;let c;l&&(c=on());let d=t.texShape;if(d==null&&(d=$V(s,u),t.texShape=d),o!=null){const h=ni(s);let p,f=d[1],g=d[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!y)&&([f,g]=Ir(d[0],d[1])),u?p=new $M(h,y):p=new Pm(h,y);const x=y?[g,f]:d,w=this.makeTensorInfo(x,r),$=this.texData.get(w.dataId);y?$.usage=Vt.PIXELS:$.usage=Vt.UPLOAD,$.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),f,g,o);const S=[[g,f]],P=this.runWebGLProgram(p,[w],r,S,!0),F=this.texData.get(P.dataId);t.texShape=F.texShape,t.isPacked=F.isPacked,t.usage=F.usage,M().get("ENGINE_COMPILE_ONLY")?this.disposeData(P.dataId):(t.texture=F.texture,t.values=null,this.texData.delete(P.dataId)),this.disposeIntermediateTensorInfo(w),l&&(this.uploadWaitMs+=on()-c)}else{const h=this.acquireTexture(d,a,r,u);t.texture=h}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=rU(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*bi(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await NT(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(_0(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:u}=F0(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:i,channels:a}=e,u=At().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(r,t,s,o,i,a);return At().makeTensorFromDataId(l,t,s,u)}}da.nextDataId=0;function rU(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */qg()&&Zg("webgl",()=>new da,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hh=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Ls{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=be(t,s),this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const js=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Rr{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=be(t,s);const o=this.outputShape.length;this.enableShapeUniforms=pt(o);let i="";if(r)if(o===0||H(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Le(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=yt("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dt(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const oU={kernelName:Gi,backendName:"webgl",kernelFunc:Dt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),i=t.texData.get(o.dataId),a=Dt({inputs:{x:s},backend:t}),u=Dt({inputs:{x:r},backend:t});return i.complexTensorInfos={real:a,imag:u},o}const iU={kernelName:El,backendName:"webgl",kernelFunc:ls};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0="return (a < 0.) ? b * a : a;",X0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function aU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,i=t.makeTensorInfo([],"float32",wr(o,"float32")),a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rr(X0,r.shape,i.shape):new Ls(K0,r.shape,i.shape),u=t.runWebGLProgram(a,[r,i],"float32");return t.disposeIntermediateTensorInfo(i),u}const uU={kernelName:xc,backendName:"webgl",kernelFunc:aU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0="return (a < 0.) ? b * a : a;",Y0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function lU(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rr(Y0,s.shape,r.shape):new Ls(q0,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const cU={kernelName:qc,backendName:"webgl",kernelFunc:lU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _r="if (isnan(x)) return x;";function Te({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:i}=r,a=o,u=s||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const d=a.texData.get(i.dataId),h=t(d.values,u);return a.makeTensorInfo(i.shape,u,h)}const l=M().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return l?c=new qn(i.shape,e):c=new bn(i.shape,n),a.runWebGLProgram(c,[i],u)}}function at({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:l}=i,c=a;if(s&&u.dtype==="complex64"){const f=c.texData.get(u.dataId),g=c.texData.get(l.dataId),[y,x]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map($=>{const[S,E]=$,P={dataId:S.dataId,dtype:S.dtype,shape:u.shape},F={dataId:E.dataId,dtype:E.dtype,shape:l.shape},L=new Ls(n,u.shape,l.shape);return c.runWebGLProgram(L,[P,F],$t(S.dtype,E.dtype))}),w=ls({inputs:{real:y,imag:x},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(x),w}const d=o||$t(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&r!=null){const f=c.texData.get(u.dataId).values,g=c.texData.get(l.dataId).values,y=u.dtype==="string"?ss(f):f,x=u.dtype==="string"?ss(g):g,[w,$]=r(u.shape,l.shape,y,x,d),S=c.makeTensorInfo($,d),E=c.texData.get(S.dataId);return E.values=w,S}const h=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return h?p=new Rr(e,u.shape,l.shape,t):p=new Ls(n,u.shape,l.shape),c.runWebGLProgram(p,[u,l],d)}}function wo(n,e=!1){if(n==="linear")return e?HW:VW;if(n==="relu")return e?KW:WW;if(n==="elu")return e?jW:MW;if(n==="relu6")return e?XW:UW;if(n==="prelu")return e?Y0:q0;if(n==="leakyrelu")return e?X0:K0;if(n==="sigmoid")return e?qW:GW;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q0{constructor(e,t,s,r=!1,o=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=pt(this.outputShape.length);const c=r?e[1]:e[2],d=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",x="";a&&(u?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");const w=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let $="rc.x",S="rc.x";e[0]<t[0]?$=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(S=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${$};
        int batchB = ${S};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${x}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bm={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class zm{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=be(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vm="return a * b;";function jh(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=$t(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),u=t.texData.get(r.dataId),l=new zm(Bm.REAL,s.shape,r.shape),c=new zm(Bm.IMAG,s.shape,r.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],h=t.runWebGLProgram(l,d,"float32"),p=t.runWebGLProgram(c,d,"float32"),f=ls({inputs:{real:h,imag:p},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[l,c]=lW(s.shape,r.shape,a.values,u.values,o),d=t.makeTensorInfo(c,o),h=t.texData.get(d.dataId);return h.values=l,d}let i;return M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Rr(Vm,s.shape,r.shape):i=new Ls(Vm,s.shape,r.shape),t.runWebGLProgram(i,[s,r],o)}const dU={kernelName:zc,backendName:"webgl",kernelFunc:jh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(n,e,t){const s=[gr(n.shape),...yr(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[gr(e),...yr(e)],i=new j0(o,s),a=!0,u=[s],l=t.runWebGLProgram(i,[r],n.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,i=t,a=H(r.shape),u=ig(o,a),l=H(u);T(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!Bi(r.shape,u)&&!(c.texture!==null&&Bi(c.shape,u))?hU(r,u,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const pU={kernelName:td,backendName:"webgl",kernelFunc:te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mm{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];const a=Math.floor(s/4)*4,u=s%4;let l="sumValue += dot(values, ones);";if(t!=null){const d=1/t;l=`sumValue += dot(values * ${ur(d)?d.toPrecision(2):d}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fU{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];let a="0.0",u="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",u="min"):t==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const c=Math.floor(s/4)*4,d=s%4;let h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=oa(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Ks(n,e,t,s){const r=mU(n.shape);let o=n;for(let i=0;i<r.length;i++){const{inSize:a,windowSize:u,outSize:l}=r[i];let c,d;t==="mean"?c=i===0?new Mm({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},a):new Mm({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l}):c=new fU({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},t),d=o,o=s.runWebGLProgram(c,[o],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gU{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.rank=s.length;const r=Le(this.rank),o=yU(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function yU(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[t[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Le(this.rank),o=H0("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${s[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(n,e,t){const s=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xU(n.shape,e):new gU(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n,e,t,s){const r=e,o=n.shape.length,i=Ue(r,n.shape);let a=i;const u=dt(a,o),l=u!=null;let c=n;l&&(c=ha(n,u,s),a=ht(a.length,o)),Lt("sum",a,o);const[d,h]=Ut(c.shape,a);let p=d;t&&(p=Ft(d,i));const f=H(h),y=H(n.shape)/f,x=te({inputs:{x:c},attrs:{shape:[y,f]},backend:s}),w=Xi(n.dtype),$=Ks(x,w,"sum",s),S=te({inputs:{x:$},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo($),l&&s.disposeIntermediateTensorInfo(c),S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s;return bU(r,o,i,t)}const wU={kernelName:wd,backendName:"webgl",kernelFunc:pa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,i=t,a=r.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=r.shape[o[c]];let l;if(i.shouldExecuteOnCPU([r])){const d=i.texData.get(r.dataId).values,h=Gh(d,r.shape,r.dtype,o,u);l=i.makeTensorInfo(u,r.dtype);const p=i.texData.get(l.dataId);p.values=h}else l=ha(r,o,i);return l}const vU={kernelName:eo,backendName:"webgl",kernelFunc:xt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0=1e3;function zi({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,c=e.shape.length,d=t?n.shape[l-2]:n.shape[l-1],h=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[l-1]:n.shape[l-2],f=s?e.shape[c-2]:e.shape[c-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),x=H(g),w=H(y),S=be(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);T(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[x,d,p]:[x,p,d],P=s?[w,f,h]:[w,h,f],F=te({inputs:{x:n},backend:r,attrs:{shape:E}}),L=te({inputs:{x:e},backend:r,attrs:{shape:P}}),R=[F,L],A=Math.max(x,w),k=t?F.shape[1]:F.shape[2],W=o!=null,G=i!=null,K=u==="leakyrelu",X=u!=null?wo(u,!0):null,ee=W||G||K||X!=null;let ce;if((p===1||f===1)&&k>Z0&&ee===!1){let he=F,Ce=L;t&&(he=xt({inputs:{x:F},backend:r,attrs:{perm:[0,2,1]}}),R.push(he)),s&&(Ce=xt({inputs:{x:L},backend:r,attrs:{perm:[0,2,1]}}),R.push(Ce));const Re=f!==1,De=f===1;let je=he;Re&&(je=te({inputs:{x:he},backend:r,attrs:{shape:[A,k,1]}}),R.push(je));const nn=f===1?2:1;let Xs=Ce;De&&(Xs=te({inputs:{x:Ce},backend:r,attrs:{shape:[A,1,k]}}),R.push(Xs));const Pr=jh({inputs:{a:je,b:Xs},backend:r});ce=pa({inputs:{x:Pr},backend:r,attrs:{axis:nn,keepDims:!0}}),R.push(Pr)}else{const he=$t(n.dtype,e.dtype),Ce=new Q0(E,P,[A,p,f],t,s,W,X,G,K),Re=[F,L];if(o!=null&&Re.push(o),G&&Re.push(i),K){const De=r.makeTensorInfo([],"float32",wr(a,"float32"));Re.push(De),R.push(De)}ce=r.runWebGLProgram(Ce,Re,he)}const de=te({inputs:{x:ce},backend:r,attrs:{shape:S}});R.push(ce);for(const he of R)r.disposeIntermediateTensorInfo(he);return de}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;return zi({a:r,b:o,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}const SU={kernelName:vi,backendName:"webgl",kernelFunc:CU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wm="return abs(x);";function $U(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),i=U0(o.values);return t.makeTensorInfo(s.shape,s.dtype,i)}let r;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new qn(s.shape,Wm):r=new bn(s.shape,Wm),t.runWebGLProgram(r,[s],s.dtype)}const IU={kernelName:ul,backendName:"webgl",kernelFunc:$U};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU=tn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,NU=Te({opSnippet:kU}),TU={kernelName:ll,backendName:"webgl",kernelFunc:NU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EU=tn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,RU=Te({opSnippet:EU}),_U={kernelName:cl,backendName:"webgl",kernelFunc:RU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Um="return a + b;",AU=at({opSnippet:Um,packedOpSnippet:Um,supportsComplex:!0,cpuKernelImpl:WM}),PU={kernelName:Wi,backendName:"webgl",kernelFunc:AU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DU{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OU{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Dt({inputs:{x:s[0]},backend:t});if(s.length>M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),l=yi({inputs:s.slice(0,u),backend:t}),c=yi({inputs:s.slice(u),backend:t});return yi({inputs:[l,c],backend:t})}const r=s.map(u=>u.dtype).reduce((u,l)=>$t(u,l)),o=s.map(u=>u.shape),a=M().getBool("WEBGL_PACK")?new OU(s[0].shape,o):new DU(s[0].shape,o);return t.runWebGLProgram(a,s,r)}const FU={kernelName:dl,backendName:"webgl",kernelFunc:yi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=Ue(o,r.shape);let l=u;const c=dt(l,a);let d=r;c!=null&&(d=xt({inputs:{x:r},backend:t,attrs:{perm:c}}),l=ht(l.length,a)),Lt("all",l,a);const[h,p]=Ut(d.shape,l),f=H(p),g=te({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),y=Ks(g,g.dtype,"all",t);let x;if(i){const w=Ft(h,u);x=te({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=te({inputs:{x:y},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(d),x}const BU={kernelName:hl,backendName:"webgl",kernelFunc:LU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=Ue(o,r.shape);let l=u;const c=dt(l,a);let d=r;c!=null&&(d=xt({inputs:{x:r},backend:t,attrs:{perm:c}}),l=ht(l.length,a)),Lt("any",l,a);const[h,p]=Ut(d.shape,l),f=H(p),g=te({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),y=Ks(g,g.dtype,"any",t);let x;if(i){const w=Ft(h,u);x=te({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=te({inputs:{x:y},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(d),x}const VU={kernelName:pl,backendName:"webgl",kernelFunc:zU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MU{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WU{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,T(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,l=Le(u),c=yt("coords",u);let d,h;if(i===1){h=u+1;const L=Le(h);d=`
        ${L} sourceLocR = ${L}(${c.join()}, 0);
        ++${c[u-1]};
        ${L} sourceLocG = ${L}(${c.join()}, 0);
        ++${c[u-2]};
        ${L} sourceLocA = ${L}(${c.join()}, 0);
        --${c[u-1]};
        ${L} sourceLocB = ${L}(${c.join()}, 0);
        --${c[u-2]};`}else h=u,d=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],g=p.map(L=>"int "+L),y=yt("sourceLocR",h-1).concat("inIdx.r"),x=yt("sourceLocG",h-1).concat("inIdx.g"),w=yt("sourceLocB",h-1).concat("inIdx.b"),$=yt("sourceLocA",h-1).concat("inIdx.a"),S=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${$.join()})));`,P=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${$.join()}) : 0.)`,F=r?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${P};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${P};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const i=oa(o),a={windowSize:i,inSize:o,batchSize:r,outSize:Math.ceil(o/i)},u=new MU(a,t,s==null),l=[e];s!=null&&l.push(s);const c=n.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;const d=J0(n,e,t,c);return n.disposeIntermediateTensorInfo(c),d}function eb(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],i=oa(o),a=new WU(r,i,t,s==null),u=s==null?[e]:[e,s],l=n.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){const c=eb(n,e,t,l);return n.disposeIntermediateTensorInfo(l),c}return l}function tb(n,e,t,s){const r=[t];if(Lt("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!M().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked;let u=e;a&&(u=n.unpackTensor(e),o.push(u));const[l,c]=Ut(u.shape,r),d=H(c),h=te({inputs:{x:u},backend:n,attrs:{shape:[-1,d]}});o.push(h);const p=J0(n,h,s);o.push(p);const f=te({inputs:{x:p},backend:n,attrs:{shape:l}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return eb(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Ue(o,r.shape);const a=dt(i,r.shape.length);let u=r;const l=[];a!=null&&(u=xt({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),i=ht(i.length,u.shape.length)),Lt("argMax",[i[0]],u.shape.length);const c=tb(t,u,i[0],"max");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const GU={kernelName:fl,backendName:"webgl",kernelFunc:UU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let i=Ue(o,r.shape);const a=dt(i,r.shape.length);let u=r;const l=[];a!=null&&(u=xt({inputs:{x:r},backend:t,attrs:{perm:a}}),l.push(u),i=ht(i.length,u.shape.length)),Lt("argMin",[i[0]],u.shape.length);const c=tb(t,u,i[0],"min");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const jU={kernelName:ml,backendName:"webgl",kernelFunc:HU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KU=tn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,XU=Te({opSnippet:KU}),qU={kernelName:gl,backendName:"webgl",kernelFunc:XU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU=tn+"return log(x + sqrt(x * x + 1.0));",QU=Te({opSnippet:YU}),ZU={kernelName:yl,backendName:"webgl",kernelFunc:QU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JU=tn+`
  return atan(x);
`,eG=Te({opSnippet:JU}),tG={kernelName:xl,backendName:"webgl",kernelFunc:eG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nG=Hh+`
  return atan(a, b);
`,sG=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,rG=at({opSnippet:nG,packedOpSnippet:sG}),oG={kernelName:wl,backendName:"webgl",kernelFunc:rG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iG=tn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,aG=Te({opSnippet:iG}),uG={kernelName:bl,backendName:"webgl",kernelFunc:aG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vo{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(g||(w="-1.0 / 1e-20"),s){const L=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${L} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?y:x:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");const E=Math.floor(i/4)*4,P=i%4,F=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${E};
          if (${P===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${P===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${P===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${S});
      }
    `}}class Kh{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,x=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const $=t==="avg";let S="0.0";if($||(S="-1.0 / 1e-20"),s){const A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${y}, ${x}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let P=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(P="avgValue / max(count, 1.0)");const F=Math.floor(i/4)*4,L=i%4,R=`
      if (${$}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${y}, ${x}, ${w});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${F};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${P});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Po(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;T(bt(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Jt(r.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&Ae(c.inShape,c.outShape))return Dt({inputs:{x:r},backend:t});const d=new vo(c,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const cG={kernelName:vl,backendName:"webgl",kernelFunc:lG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=s,c=[1,1,1],d=Vn(r.shape,o,i,c,a,u,l),h=new Kh(d,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const hG={kernelName:Cl,backendName:"webgl",kernelFunc:dG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pG{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,d=l-1-e.padInfo.left,h=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class fG{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=d-1-e.padInfo.front,g=h-1-e.padInfo.top,y=p-1-e.padInfo.left,x=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,d=[1,1,1],h=Vn(i.shape,a,u,d,l,c),p=new fG(h);return t.runWebGLProgram(p,[r],i.dtype)}const gG={kernelName:pg,backendName:"webgl",kernelFunc:mG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o;Po([r,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Jt(i.shape,a,u,1,l),d=new pG(c);return t.runWebGLProgram(d,[r],i.dtype)}const xG={kernelName:hg,backendName:"webgl",kernelFunc:yG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bG(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return zi({a:r,b:o,transposeA:i,transposeB:a,backend:t})}const wG={kernelName:Sl,backendName:"webgl",kernelFunc:bG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vG{constructor(e,t,s,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],be(e,t),be(e,s);let a="0.0";r!=null&&(be(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";o!=null&&(be(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CG{constructor(e,t,s,r,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],be(e,t),be(e,s);let a="vec4(0.0)";r!=null&&(be(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(be(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:i,scale:a}=n;T(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),T(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),T(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const l=[s,r,o];let c=null;i!=null&&(c=i.shape,l.push(i));let d=null;a!=null&&(d=a.shape,l.push(a));const h=M().getBool("WEBGL_PACK_NORMALIZATION")?new CG(s.shape,r.shape,o.shape,c,d,u):new vG(s.shape,r.shape,o.shape,c,d,u);return e.runWebGLProgram(h,l,l[0].dtype)},$G={kernelName:uc,backendName:"webgl",kernelFunc:SG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IG{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Le(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=kG(this.rank);let r;const o=e.map((i,a)=>`sourceLoc.${Zu[a]} = start[${a}] + coords.${Zu[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Zu=["x","y","z","w","u","v"];function kG(n){if(n===1)return"sourceLoc";if(n<=6)return Zu.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NG{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Le(this.rank),s=yt("coords",this.rank),r=yt("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,d)=>`start[${d}]`).join()});`:e.map((c,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),i=s.texData.get(o.dataId);Object.assign(i,r),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=ch(e,Xe(n.shape));r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,u+1),o}function Ar(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:i}=s,[a,u]=dh(r,o,i);if(ah(r,a,u),H(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=t.texData.get(r.dataId),h=wW(d.values,a,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,h)}const{isPacked:l}=t.texData.get(r.dataId),c=lh(r.shape,a,u);if(l||!c){const d=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NG(u):new IG(u),h=[a];return t.runWebGLProgram(d,[r],r.dtype,h)}return t.uploadToGPU(r.dataId),TG(r,a,u,t)}const EG={kernelName:pd,backendName:"webgl",kernelFunc:Ar};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:i}=s;T(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((w,$)=>w*$),u=To(r.shape,o,a),l=Eo(u.length,o.length),c=Ro(r.shape,o,a),d=gh(i,o.length),h=yh(c,i,o.length),p=[],f=te({inputs:{x:r},backend:t,attrs:{shape:u}}),g=xt({inputs:{x:f},backend:t,attrs:{perm:l}}),y=te({inputs:{x:g},backend:t,attrs:{shape:c}}),x=Ar({inputs:{x:y},backend:t,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(y),p.forEach(w=>t.disposeIntermediateTensorInfo(w)),x},_G={kernelName:$l,backendName:"webgl",kernelFunc:RG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i}=s,a=t.readSync(r.dataId),u=t.readSync(o.dataId),l=W0(a,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,l)}const PG={kernelName:Il,backendName:"webgl",kernelFunc:AG};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,OG=`
  return float(int(a.r) & int(b.r));
`;function FG(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=M().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=M().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||i===1){const u=t.texData.get(s.dataId).values,l=t.texData.get(r.dataId).values,[c,d]=GM(s.shape,r.shape,u,l,s.dtype),h=t.makeTensorInfo(d,s.dtype),p=t.texData.get(h.dataId);return p.values=c,h}let a;return o?a=new Rr(DG,s.shape,r.shape,!1):a=new Ls(OG,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const LG={kernelName:fg,backendName:"webgl",kernelFunc:FG};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),i=t.readSync(r.dataId),a=be(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const zG={kernelName:kl,backendName:"webgl",kernelFunc:BG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG="return float(a != b);",nb=at({opSnippet:VG,cpuKernelImpl:dW,dtype:"bool"}),MG={kernelName:Mc,backendName:"webgl",kernelFunc:nb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Dt({inputs:{x:r.complexTensorInfos.real},backend:t})}const WG={kernelName:Zc,backendName:"webgl",kernelFunc:Oo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG="return float(int(x));";function GG(n,e){const t=new bn(n.shape,UG),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return Dt({inputs:{x:r},backend:t});const i=Bn(r.shape),a=Ju({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=ls({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),u}if(r.dtype==="complex64"){const i=Oo({inputs:{input:r},backend:t}),a=Ju({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!ag(r.dtype,o)){const i=Dt({inputs:{x:r},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId).values,[a,u,l]=HM(i,r.shape,r.dtype,o);return t.makeTensorInfo(a,u,l)}if(o==="int32")return GG(r,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Sn("bool",1)),u=nb({inputs:{a:r,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const HG={kernelName:Ui,backendName:"webgl",kernelFunc:Ju};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gm="return ceil(x);",jG=Te({opSnippet:Gm,packedOpSnippet:Gm,cpuKernelImpl:jM}),KG={kernelName:Nl,backendName:"webgl",kernelFunc:jG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XG{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;M().getBool("WEBGL_PACK_CLIP")?a=new qG(r.shape):a=new XG(r.shape);const u=[[o],[i]];return t.runWebGLProgram(a,[r],r.dtype,u)}const QG={kernelName:Tl,backendName:"webgl",kernelFunc:YG};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZG{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hm(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function JG(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new ZG(s.shape),i=[Hm(s,r.complexTensorInfos.real),Hm(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}const eH={kernelName:Rl,backendName:"webgl",kernelFunc:JG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tH{constructor(e){this.outputShape=[],this.outputShape=Zt(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const a=t[i-1];s.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nH{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zt(e,t);const s=this.outputShape,r=s.length,o=Le(r),i=yt("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((g,y)=>`T${y}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let g=1;g<u.length;g++)u[g]=u[g-1]+e[g][t];const l=a[t],c=a.slice(-2),d=a.join();let h=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let g=1;g<u.length;g++){const y=u[g-1];h+=`
        if (${l} < ${u[g]}  && ${l} >= ${u[g-1]}) {
          return getChannel(
            getT${g}(${oi(a,l,y)}),
            vec2(${oi(c,l,y)}));
        }`}const p=u.length,f=u[u.length-1];h+=`
        return getChannel(
          getT${p}(${oi(a,l,f)}),
          vec2(${oi(c,l,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${h}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function oi(n,e,t){const s=n.indexOf(e);return n.map((o,i)=>i===s?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Dt({inputs:{x:r.complexTensorInfos.imag},backend:t})}const sH={kernelName:fc,backendName:"webgl",kernelFunc:fa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zr(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(w=>Oo({inputs:{input:w},backend:t})),f=n.map(w=>fa({inputs:{input:w},backend:t})),g=Zr(p,e,t),y=Zr(f,e,t),x=ls({inputs:{real:g,imag:y},backend:t});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),f.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),x}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(S=>{const P=[-1,H(S.shape.slice(e))];return te({inputs:{x:S},backend:t,attrs:{shape:P}})}),f=p.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=Zt(p.map(S=>S.shape),1),y=p[0].shape[0]===1,x=KM(f,g,s,y),w=Zt(n.map(S=>S.shape),e),$=t.makeTensorInfo(w,s,x);return p.forEach(S=>t.disposeIntermediateTensorInfo(S)),$}const o=n.filter(p=>H(p.shape)>0),i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const p=i?new bn(n[0].shape,jn):new qn(n[0].shape,jn);return t.runWebGLProgram(p,n,s)}const a=M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const p=[];for(let g=0;g<o.length;g+=a){const y=o.slice(g,g+a);p.push(Zr(y,e,t))}const f=Zr(p,e,t);for(const g of p)t.disposeIntermediateTensorInfo(g);return f}if(i){const p=new nH(o.map(f=>f.shape),e);return t.runWebGLProgram(p,o,s)}const{tensors2D:u,outShape:l}=rH(o,e,t),c=new tH(u.map(p=>p.shape)),d=t.runWebGLProgram(c,u,s);u.forEach(p=>t.disposeIntermediateTensorInfo(p));const h=te({inputs:{x:d},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(d),h}function rH(n,e,t){const s=Zt(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>te({inputs:{x:o},attrs:{shape:[-1,H(o.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Ue(r,e[0].shape)[0],i=e.map(l=>l.shape);ph(i,o);const a=Zt(e.map(l=>l.shape),o);if(H(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>H(l.shape)>0);return u.length===1?Dt({inputs:{x:u[0]},backend:t}):Zr(u,o,t)}const oH={kernelName:_l,backendName:"webgl",kernelFunc:sb};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rb{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",x=y?1:2,w=y?2:3,$=y?3:1;let S="",E="";s&&(r?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:S=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const P=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${$}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${P}
        ${E}
        setOutput(result);
      }
    `}}class iH{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterDepth,h=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ob{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,d=c;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)h+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)h+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(d+1)/2;y++){const x=y*2;if(h+=`
           xC = xCCorner + ${x*u};
           `,a===1){if(x<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,u===1&&x>0?h+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<c)){const w=i%2===0?ol(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,u>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:h+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):w===1?h+=`
                     xC${x+1} = xTexelC${x};
                     `:h+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<c&&(h+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<c&&(h+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<c&&(h+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);const{dataFormat:s}=t,r=wt(),o=s==="channelsLast",i=o?1:2,a=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vi(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function ib({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=n.shape,l=s.texData.get(n.dataId),c=t.inChannels,d=u[0]*u[1]*u[2],h=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,g=!1;let y;const x=[];if(o!=null){const S=Vi(o.shape,p);S!=null&&(o=te({inputs:{x:o},backend:s,attrs:{shape:S}}),x.push(o))}if(r!=null){const S=Vi(r.shape,p);S!=null&&(r=te({inputs:{x:r},backend:s,attrs:{shape:S}}),x.push(r))}if(!((d===1||h===1)&&c>Z0)&&l.isPacked&&p&&l.texture!=null&&u[2]%2!==0&&Ae(l.shape.slice(-3),u.slice(-3))){const S=u[0]*u[1]*(u[2]+1),E={dataId:n.dataId,shape:[1,S,t.inChannels],dtype:n.dtype},P=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,T(Bi(l.shape,E.shape),()=>`packed reshape ${l.shape} to ${E.shape} isn't free`);const F=te({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(F);const L=zi({a:E,b:F,backend:s,transposeA:f,transposeB:g,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),R=s.texData.get(L.dataId);T(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=P,R.shape=t.outShape,y=Dt({inputs:{x:L},backend:s}),y.shape=t.outShape,x.push(L)}else{const S=t.outHeight*t.outWidth,E=te({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,S,t.inChannels]:[t.batchSize,t.inChannels,S]}}),P=te({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),F=zi({a:p?E:P,b:p?P:E,transposeA:!p,transposeB:g,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});y=te({inputs:{x:F},backend:s,attrs:{shape:t.outShape}}),x.push(E),x.push(P),x.push(F)}for(const S of x)s.disposeIntermediateTensorInfo(S);return y}function ab({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=t,f=p==="channelsLast",g=u*l*c,y=h*d,x=[t.batchSize,g,y],w=!0,$=!1,S=[];if(o!=null){const de=Vi(o.shape,f);de!=null&&(o=te({inputs:{x:o},backend:s,attrs:{shape:de}}),S.push(o))}if(r!=null){const de=Vi(r.shape,f);de!=null&&(r=te({inputs:{x:r},backend:s,attrs:{shape:de}}),S.push(r))}const E=te({inputs:{x:e},backend:s,attrs:{shape:[1,g,H(e.shape)/g]}});S.push(E);const P=new aH(x,t),F=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=s.runWebGLProgram(P,[n],"float32",F),R=te({inputs:{x:L},backend:s,attrs:{shape:x}});S.push(L),S.push(R);const A=r!=null,k=o!=null,W=a==="leakyrelu",G=a?wo(a,!0):null,K=new Q0(f?R.shape:E.shape,f?E.shape:R.shape,f?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],w,$,A,G,k,W),X=f?[R,E]:[E,R];if(r&&X.push(r),k&&X.push(o),W){const de=s.makeTensorInfo([],"float32",wr(i,"float32"));X.push(de),S.push(de)}const ee=s.runWebGLProgram(K,X,"float32"),ce=te({inputs:{x:ee},backend:s,attrs:{shape:t.outShape}});S.push(ee);for(const de of S)s.disposeIntermediateTensorInfo(de);return ce}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s,d=hn(u),h=Ze(r.shape,o.shape,i,l,a,c,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=ib({x:r,filter:o,convInfo:h,backend:t});else if(h.strideWidth<=2&&d==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){const g=new ob(h),y=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=t.runWebGLProgram(g,[r,o],"float32",y)}else if(M().getBool("WEBGL_CONV_IM2COL"))p=ab({x:r,filter:o,convInfo:h,backend:t});else{const g=new rb(h);p=t.runWebGLProgram(g,[r,o],"float32")}const f=te({inputs:{x:p},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(p),f}const lH={kernelName:Al,backendName:"webgl",kernelFunc:uH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class dH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,u=s-1-e.padInfo.left,l=i?1:2,c=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class hH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,l=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,d=hn(u),h=Ze(r.shape,c,i,1,a,l,!1,d),p=new cH(h);return t.runWebGLProgram(p,[r,o],"float32")}const mH={kernelName:Pl,backendName:"webgl",kernelFunc:fH};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gH{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=pt(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s,d=hn(l),h=Ze(i,o.shape,a,1,u,c,!1,d);if(M().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],f=new gH(h);return t.runWebGLProgram(f,[r,o],"float32",p)}else{const p=new dH(h);return t.runWebGLProgram(p,[r,o],"float32")}}const xH={kernelName:Dl,backendName:"webgl",kernelFunc:yH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=as(r.shape,o.shape,i,u,a),c=new iH(l);return t.runWebGLProgram(c,[r,o],"float32")}const wH={kernelName:Ol,backendName:"webgl",kernelFunc:bH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:u}=s,l=as(r.shape,u,i,1,a),c=new hH(l);return t.runWebGLProgram(c,[r,o],"float32")}const CH={kernelName:mg,backendName:"webgl",kernelFunc:vH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SH(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:u}=s,l=as(u,o.shape,a,1,i),c=new pH(l);return t.runWebGLProgram(c,[r,o],"float32")}const $H={kernelName:Fl,backendName:"webgl",kernelFunc:SH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IH=_r+`
  return cos(x);
`,kH=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${js}
  return result;
`,NH=Te({opSnippet:IH,packedOpSnippet:kH}),TH={kernelName:Ll,backendName:"webgl",kernelFunc:NH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EH=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,RH=Te({opSnippet:EH}),_H={kernelName:Bl,backendName:"webgl",kernelFunc:RH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AH{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,u,l]=e,[c]=t,[d,h]=s;this.outputShape=[c,d,h,l];const p=r==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${u-1}.0`],[y,x,w]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[$,S,E]=h>1?[`${(u-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${$});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${S};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PH=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=s,c=new AH(r.shape,o.shape,a,u,l);return t.runWebGLProgram(c,[r,o,i],"float32")},DH={kernelName:Ml,backendName:"webgl",kernelFunc:PH};var Co;(function(n){n.Prod="*",n.Sum="+"})(Co||(Co={}));class jm{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===Co.Prod?"1.0":"0.0",a=s?i:`getX(${Km(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",c="";s?(l=r?`end != ${u-1}`:"end != 0",c=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${u}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Le(o)} coords = getOutputCoords();
        int end = ${Xm(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${Xm(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${Km(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Km(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Xm(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(n,e,t,s,r,o){const i=e.shape.length,a=dt([s],i);let u=e;a!=null&&(u=xt({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=ht(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=u.shape[l];let d=Dt({inputs:{x:u},backend:t});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new jm(n,u.shape,!1,o),f=[[h]],g=d;d=t.runWebGLProgram(p,[d],d.dtype,f),t.disposeIntermediateTensorInfo(g)}if(r){const h=new jm(n,u.shape,r,o),p=d;d=t.runWebGLProgram(h,[d],d.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const h=No(a),p=xt({inputs:{x:d},backend:t,attrs:{perm:h}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(u),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return ub(Co.Prod,r,t,o,i,a)}const FH={kernelName:zl,backendName:"webgl",kernelFunc:OH};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return ub(Co.Sum,r,t,o,i,a)}const BH={kernelName:Vl,backendName:"webgl",kernelFunc:LH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),l=t.readSync(o.dataId),c=W0(u,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const u=t.bufferSync(r),l=t.bufferSync(o),c=UM(u,l,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const VH={kernelName:Wl,backendName:"webgl",kernelFunc:zH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MH{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],l=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],d=u*o,h=l*o,p=c/(o*o),f=i==="NHWC"?[a,d,h,p]:[a,p,d,h],g=new MH(f,o,i);return t.runWebGLProgram(g,[r],r.dtype)}const UH={kernelName:Ul,backendName:"webgl",kernelFunc:WH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lb{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels;let l="",c="";s&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:l=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cb{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<d;x++)p+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let x=0;x<d;x++)p+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(h+1)/2;x++){const w=x*2;if(p+=`
          xC = xCCorner + ${w*l};
          `,u===1){if(w<d&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,l===1&&w>0?p+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<d)){const $=a%2===0?ol(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${$};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:p+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):$===1?p+=`
                    xC${w+1} = xTexelC${w};
                    `:p+=`
                    xCOffset = xC + ${$};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<d&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<d&&(p+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<d&&(p+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<d&&(p+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",g="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=s;let c=u;c==null&&(c=[1,1]),T(bt(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Ze(r.shape,o.shape,i,c,a,l,!0);let h;M().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new cb(d):h=new lb(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(h,[r,o],"float32",p)}const HH={kernelName:Gl,backendName:"webgl",kernelFunc:GH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jH{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class KH{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s,d=Ze(r.shape,c,i,a,u,l,!0),h=new jH(d);return t.runWebGLProgram(h,[r,o],"float32")}const qH={kernelName:Hl,backendName:"webgl",kernelFunc:XH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YH(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s,d=Ze(c,o.shape,i,a,u,l,!0),h=new KH(d);return t.runWebGLProgram(h,[r,o],"float32")}const QH={kernelName:jl,backendName:"webgl",kernelFunc:YH};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZH{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=H(s.shape),i=te({inputs:{x:s},backend:t,attrs:{shape:[o]}}),a=new ZH(o),u=t.runWebGLProgram(a,[i],i.dtype),l=te({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}const e6={kernelName:Kl,backendName:"webgl",kernelFunc:JH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t6{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:d,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=Io(r.shape,o.shape,i,a,"NHWC",u);let c;const d=new t6(l);c=t.runWebGLProgram(d,[r,o],"float32");const h=te({inputs:{x:c},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(c),h}const s6={kernelName:Xl,backendName:"webgl",kernelFunc:n6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:u}=kh(r,o.length);Th(i.length,u,o);const{path:l,steps:c}=Eh(a,u),d=c.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const y of c[g]){const{permutationIndices:x,expandDims:w}=Nh(p,u[y]);let $;Rh(x)?$=o[y]:($=xt({inputs:{x:o[y]},backend:t,attrs:{perm:x}}),f.push($));const S=$.shape.slice();for(let E=0;E<w.length;++E)S.splice(w[E],0,1);Ae($.shape,S)||($=te({inputs:{x:$},backend:t,attrs:{shape:S}}),f.push($)),h===null?h=$:(h=jh({inputs:{a:$,b:h},backend:t}),f.push(h))}g<d-1&&(l[g]>=0&&(h=pa({inputs:{x:h},backend:t,attrs:{axis:l[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&t.disposeIntermediateTensorInfo(g);return h}const o6={kernelName:Yl,backendName:"webgl",kernelFunc:r6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i6="return (x >= 0.0) ? x : (exp(x) - 1.0);",a6=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,u6=Te({opSnippet:i6,packedOpSnippet:a6}),l6={kernelName:Ql,backendName:"webgl",kernelFunc:u6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6="return (b >= 0.0) ? a : a * (b + 1.0);",d6=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,h6=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Rr(d6,s.shape,r.shape):new Ls(c6,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},p6={kernelName:yg,backendName:"webgl",kernelFunc:h6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f6=`
  return vec4(equal(a, b));
`,m6="return float(a == b);",g6=at({opSnippet:m6,packedOpSnippet:f6,dtype:"bool",cpuKernelImpl:XM}),y6={kernelName:Jl,backendName:"webgl",kernelFunc:g6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${wh};
  float a1 = ${vh};
  float a2 = ${Ch};
  float a3 = ${Sh};
  float a4 = ${$h};
  float a5 = ${Ih};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,b6=Te({opSnippet:x6}),w6={kernelName:Zl,backendName:"webgl",kernelFunc:b6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v6=_r+`
  return exp(x);
`,C6=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,db=Te({opSnippet:v6,packedOpSnippet:C6,cpuKernelImpl:qM,dtype:"float32"}),S6={kernelName:ec,backendName:"webgl",kernelFunc:db};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=r;return r<0&&(T(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),a.splice(u,0,1),te({inputs:{x:o},backend:s,attrs:{shape:a}})}const $6={kernelName:tc,backendName:"webgl",kernelFunc:el};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qm="return exp(x) - 1.0;",I6=Te({opSnippet:qm,packedOpSnippet:qm,cpuKernelImpl:YM}),k6={kernelName:nc,backendName:"webgl",kernelFunc:I6};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ym{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hb(n,e,t){const s=t.texData.get(n.dataId),r=H(n.shape),o=n.shape[n.shape.length-1],i=r/o,a=te({inputs:{x:n},backend:t,attrs:{shape:[i,o]}}),u=a.shape,l=new Ym("real",u,e),c=new Ym("imag",u,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],h=t.runWebGLProgram(l,d,"float32"),p=t.runWebGLProgram(c,d,"float32"),f=ls({inputs:{real:h,imag:p},backend:t});t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p);const g=te({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6(n){const{inputs:e,backend:t}=n,{input:s}=e;return hb(s,!1,t)}const T6={kernelName:sc,backendName:"webgl",kernelFunc:N6};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E6{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fo(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||br(r),o==="string"){const i=Je(o,H(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new E6(s,r),a=[[r]];return e.runWebGLProgram(i,[],o,a)}}const R6={kernelName:rc,backendName:"webgl",kernelFunc:Fo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _6{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A6={kernelName:oc,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new _6(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qm="return floor(x);",P6=Te({opSnippet:Qm,packedOpSnippet:Qm,cpuKernelImpl:QM}),D6={kernelName:ic,backendName:"webgl",kernelFunc:P6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O6=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,F6=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,L6=at({opSnippet:O6,packedOpSnippet:F6,dtype:"int32"}),B6={kernelName:ac,backendName:"webgl",kernelFunc:L6};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z6{constructor(e){this.variableNames=["A"];const t=wt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V6{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=wt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M6={kernelName:wi,backendName:"webgl",kernelFunc:W6};let er,cu=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function W6(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,l]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],d=[l,u,o];if(a||i){const g=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(er==null||g!==cu)&&(cu=g,er=document.createElement("canvas").getContext("2d",{willReadFrequently:cu})),er.canvas.width=u,er.canvas.height=l,er.drawImage(r,0,0,u,l),r=er.canvas}const h=t.makeTensorInfo(c,"int32");t.texData.get(h.dataId).usage=Vt.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(h.dataId),r);const p=M().getBool("WEBGL_PACK")?new V6(d):new z6(d),f=t.runWebGLProgram(p,[h],"int32");return t.disposeData(h.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s,g=hn(c),y=Ze(r.shape,o.shape,u,d,l,h,!1,g);let x;const w=[],$=i!=null,S=a!=null,E=p==="leakyrelu",P=()=>{const L=[r,o],R=(A,k)=>{if(k==="NCHW"&&A.shape.length===1&&A.shape[0]!==1){const W=te({inputs:{x:A},backend:t,attrs:{shape:[A.shape[0],1,1]}});return w.push(W),W}return A};if($&&L.push(R(i,c)),S&&L.push(R(a,c)),E){const A=t.makeTensorInfo([],"float32",wr(f,"float32"));L.push(A),w.push(A)}return L};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))x=ib({x:r,filter:o,convInfo:y,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(y.strideWidth<=2&&g==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){const L=p?wo(p,!0):null,R=new ob(y,$,L,S,E),A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],k=P();x=t.runWebGLProgram(R,k,"float32",A)}else if(M().getBool("WEBGL_CONV_IM2COL"))x=ab({x:r,filter:o,convInfo:y,backend:t,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const L=p?wo(p,!1):null,R=new rb(y,$,L,S,E),A=P();x=t.runWebGLProgram(R,A,"float32")}const F=te({inputs:{x},backend:t,attrs:{shape:y.outShape}});return w.push(x),w.forEach(L=>t.disposeIntermediateTensorInfo(L)),F}const G6={kernelName:Ci,backendName:"webgl",kernelFunc:U6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s,f=[];let g=c;g==null&&(g=[1,1]),T(bt(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);const y=Ze(r.shape,o.shape,u,g,l,d,!0),x=M().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=h?wo(h,x):null,$=[r,o],S=i!=null,E=a!=null,P=h==="leakyrelu";if(S&&$.push(i),E&&$.push(a),P){const A=t.makeTensorInfo([],"float32",wr(p,"float32"));$.push(A),f.push(A)}let F;x?F=new cb(y,S,w,E,P):F=new lb(y,S,w,E,P);const L=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],R=t.runWebGLProgram(F,$,"float32",L);return f.forEach(A=>t.disposeIntermediateTensorInfo(A)),R}const j6={kernelName:Si,backendName:"webgl",kernelFunc:H6};class K6{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=Le(s.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=H(s.shape),[u,l,c,d]=ih(s,r),h=te({inputs:{x:r},backend:t,attrs:{shape:[l,i]}}),p=te({inputs:{x:s},backend:t,attrs:{shape:[H(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const x=t.readSync(r.dataId),w=t.bufferSync(s),$=ZM(x,w,s.dtype,l,i,c,d,s.shape,a);return t.makeTensorInfo(u,s.dtype,$.values)}const f=new K6(i,d,[l,c],s.shape),g=t.runWebGLProgram(f,[p,h],p.dtype),y=te({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),y}const q6={kernelName:cc,backendName:"webgl",kernelFunc:X6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y6{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Le(this.rank),r=Q6(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function Q6(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pb(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,u=Ue(i,r.shape)[0];if(M().get("DEBUG")){const w=t.readSync(o.dataId),$=r.shape[u];for(let S=0;S<w.length;++S){const E=w[S];T(E<=$-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${$-1}]`)}}const l=Ph(r,o,u,a),c=H(o.shape),d=[],h=te({inputs:{x:r},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=te({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,c/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const w=t.bufferSync(p),$=t.bufferSync(h),S=JM($,w,f);return d.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(l.outputShape,S.dtype,S.values)}const g=new Y6(h.shape,f),y=t.runWebGLProgram(g,[h,p],h.dtype);d.push(y);const x=te({inputs:{x:y},backend:t,attrs:{shape:l.outputShape}});return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const Z6={kernelName:lc,backendName:"webgl",kernelFunc:pb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J6="return float(a > b);",ej=`
  return vec4(greaterThan(a, b));
`,tj=at({opSnippet:J6,packedOpSnippet:ej,cpuKernelImpl:eW,dtype:"bool"}),nj={kernelName:dc,backendName:"webgl",kernelFunc:tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sj="return float(a >= b);",rj=`
  return vec4(greaterThanEqual(a, b));
`,oj=at({opSnippet:sj,packedOpSnippet:rj,dtype:"bool",cpuKernelImpl:tW}),ij={kernelName:hc,backendName:"webgl",kernelFunc:oj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(n){const{inputs:e,backend:t}=n,{input:s}=e;return hb(s,!0,t)}const uj={kernelName:pc,backendName:"webgl",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lj="return float(!isnan(x) && !isinf(x));",cj=Te({opSnippet:lj,dtype:"bool"}),dj={kernelName:mc,backendName:"webgl",kernelFunc:cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hj="return float(isinf(x));",pj=Te({opSnippet:hj,dtype:"bool"}),fj={kernelName:gc,backendName:"webgl",kernelFunc:pj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mj="return float(isnan(x));",gj=Te({opSnippet:mj,dtype:"bool"}),yj={kernelName:yc,backendName:"webgl",kernelFunc:gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xj="return float(a < b);",bj=`
  return vec4(lessThan(a, b));
`,wj=at({opSnippet:xj,packedOpSnippet:bj,cpuKernelImpl:nW,dtype:"bool"}),vj={kernelName:bc,backendName:"webgl",kernelFunc:wj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cj="return float(a <= b);",Sj=`
  return vec4(lessThanEqual(a, b));
`,$j=at({opSnippet:Cj,packedOpSnippet:Sj,cpuKernelImpl:sW,dtype:"bool"}),Ij={kernelName:wc,backendName:"webgl",kernelFunc:$j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,i=rW(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const Nj={kernelName:vc,backendName:"webgl",kernelFunc:kj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tj=_r+`
  return x < 0.0 ? 0./0. : log(x);
`,Ej=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Rj=Te({opSnippet:Tj,packedOpSnippet:Ej,cpuKernelImpl:oW}),_j={kernelName:Cc,backendName:"webgl",kernelFunc:Rj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aj=_r+`
  return log(1.0 + x);
`,Pj=Te({opSnippet:Aj}),Dj={kernelName:Sc,backendName:"webgl",kernelFunc:Pj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oj="return float(a >= 1.0 && b >= 1.0);",Fj=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Lj=at({opSnippet:Oj,packedOpSnippet:Fj,dtype:"bool"}),Bj={kernelName:$c,backendName:"webgl",kernelFunc:Lj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zj="return float(!(x >= 1.0));",Vj=Te({opSnippet:zj}),Mj={kernelName:Ic,backendName:"webgl",kernelFunc:Vj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wj="return float(a >= 1.0 || b >= 1.0);",Uj=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Gj=at({opSnippet:Wj,packedOpSnippet:Uj,dtype:"bool"}),Hj={kernelName:kc,backendName:"webgl",kernelFunc:Gj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jj{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kj{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=s,l=M().getBool("WEBGL_PACK_NORMALIZATION")?new Kj(r.shape,o,i,a,u):new jj(r.shape,o,i,a,u);return t.runWebGLProgram(l,[r],r.dtype)},qj={kernelName:Nc,backendName:"webgl",kernelFunc:Xj};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yj{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=s,d=new Yj(r.shape,a,u,l,c);return t.runWebGLProgram(d,[r,o,i],r.dtype)},Zj={kernelName:xg,backendName:"webgl",kernelFunc:Qj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jj(n,e,t,s){const r=H(e),i=H(n.shape)/r,a=te({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),u=Ks(a,n.dtype,"max",s),l=te({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fb(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=r.shape.length,u=Ue(o,r.shape);let l=u;const c=dt(l,a),d=c!=null,h=t.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const $=t.texData.get(p.dataId).values,S=new Array(a);for(let F=0;F<S.length;F++)S[F]=r.shape[c[F]];const E=Gh($,r.shape,r.dtype,c,S);p=t.makeTensorInfo(S,r.dtype);const P=t.texData.get(p.dataId);P.values=E}else p=ha(r,c,t);l=ht(l.length,a)}Lt("max",l,a);const[f,g]=Ut(p.shape,l);let y=f;i&&(y=Ft(f,u));let x;if(h){const $=t.texData.get(p.dataId).values,S=iW($,H(g),y,r.dtype);x=t.makeTensorInfo(y,r.dtype);const E=t.texData.get(x.dataId);E.values=S}else x=Jj(p,g,y,t);return d&&t.disposeIntermediateTensorInfo(p),x}const eK={kernelName:Tc,backendName:"webgl",kernelFunc:fb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tK=Hh+`
  return max(a, b);
`,nK=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,sK=at({opSnippet:tK,packedOpSnippet:nK,cpuKernelImpl:aW}),rK={kernelName:Ec,backendName:"webgl",kernelFunc:sK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Po(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;T(bt(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Jt(r.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&Ae(c.inShape,c.outShape))return Dt({inputs:{x:r},backend:t});const d=new vo(c,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const iK={kernelName:Rc,backendName:"webgl",kernelFunc:oK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],d=Vn(r.shape,o,i,c,a,l,u),h=new Kh(d,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const uK={kernelName:_c,backendName:"webgl",kernelFunc:aK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,u=i-1-e.padInfo.left,l=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class cK{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=u-1-e.padInfo.front,h=l-1-e.padInfo.top,p=c-1-e.padInfo.left,f=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,d=[1,1,1],h=Vn(i.shape,a,u,d,l,c),p=new Kh(h,"max",!0),f=t.runWebGLProgram(p,[i],i.dtype),g=new cK(h),y=t.runWebGLProgram(g,[r,f],i.dtype);return t.disposeIntermediateTensorInfo(f),y}const hK={kernelName:wg,backendName:"webgl",kernelFunc:dK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:i}=e,a=o;Po([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,h=Jt(a.shape,u,l,1,c,d),p=!0,f=new vo(h,"max",p),g=t.runWebGLProgram(f,[a],a.dtype),y=new lK(h),x=t.runWebGLProgram(y,[r,g],a.dtype);return t.disposeIntermediateTensorInfo(g),x}const fK={kernelName:bg,backendName:"webgl",kernelFunc:pK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mK(n,e,t,s){let r=new vo(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new vo(t,"max",!0,!0,e);const i=s.runWebGLProgram(r,[n],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK={kernelName:Ac,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,u=t;T(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];T(bt(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Jt(s.shape,r,o,l,i),[d,h]=mK(s,a,c,u);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(n,e,t,s){const r=H(e),i=H(n.shape)/r,a=te({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),u=Ks(a,"float32","mean",s),l=te({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xK={kernelName:Pc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,i=t,a=s.shape.length,u=Ue(o,s.shape);let l=u;const c=dt(l,a),d=c!=null,h=i.shouldExecuteOnCPU([s]),p=[];let f=s;if(d){if(h){const S=i.texData.get(f.dataId).values,E=new Array(a);for(let L=0;L<E.length;L++)E[L]=s.shape[c[L]];const P=Gh(S,s.shape,s.dtype,c,E);f=i.makeTensorInfo(E,s.dtype);const F=i.texData.get(f.dataId);F.values=P}else f=ha(s,c,i);p.push(f),l=ht(l.length,a)}Lt("sum",l,a);const[g,y]=Ut(f.shape,l);let x=g;r&&(x=Ft(g,u));const w=yK(f,y,x,i);for(const $ of p)i.disposeIntermediateTensorInfo($);return w}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=Ue(o,r.shape);let l=u;const c=dt(l,a);let d=r;c!=null&&(d=xt({inputs:{x:r},backend:t,attrs:{perm:c}}),l=ht(l.length,r.shape.length)),Lt("min",l,a);const[h,p]=Ut(d.shape,l),f=H(p),g=te({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),y=Ks(g,g.dtype,"min",t);let x;if(i){const w=Ft(h,u);x=te({inputs:{x:y},backend:t,attrs:{shape:w}})}else x=te({inputs:{x:y},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(d),x}const wK={kernelName:Dc,backendName:"webgl",kernelFunc:bK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vK=Hh+`
  return min(a, b);
`,CK=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,SK=at({opSnippet:vK,packedOpSnippet:CK,cpuKernelImpl:uW}),$K={kernelName:Oc,backendName:"webgl",kernelFunc:SK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IK{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,o=Le(r),i=t.map(c=>c[0]).join(","),a=t.map((c,d)=>c[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kK{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const r=e.length,o=Le(r),i=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),u=yt("rc",r),l=yt("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,h=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${u[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NK=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kK(s.shape,r,o):new IK(s.shape,r,o);return e.runWebGLProgram(i,[s],s.dtype)},TK={kernelName:Fc,backendName:"webgl",kernelFunc:NK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK=`if (b == 0.0) return NAN;
  return mod(a, b);`,RK=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+js+`
  return result;
`,_K=at({opSnippet:EK,packedOpSnippet:RK}),AK={kernelName:Lc,backendName:"webgl",kernelFunc:_K};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PK{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK=`
if (a == b) {
  return 1.0;
};
return a / b;`,OK=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,mb=at({opSnippet:DK,packedOpSnippet:OK,checkOutOfBounds:!0}),FK={kernelName:ql,backendName:"webgl",kernelFunc:mb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm="return a - b;",gb=at({opSnippet:Zm,packedOpSnippet:Zm,supportsComplex:!0,cpuKernelImpl:EW}),LK={kernelName:Rd,backendName:"webgl",kernelFunc:gb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yb(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,i=Ue([o],r.shape),a=fb({inputs:{x:r},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),u=Ft(a.shape,i),l=te({inputs:{x:a},backend:t,attrs:{shape:u}}),c=gb({inputs:{a:r,b:l},backend:t}),d=db({inputs:{x:c},backend:t}),h=pa({inputs:{x:d},backend:t,attrs:{axis:i,keepDims:!1}}),p=te({inputs:{x:h},backend:t,attrs:{shape:u}}),f=mb({inputs:{a:d,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),f}const BK={kernelName:Sd,backendName:"webgl",kernelFunc:yb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,u=a?r:yb({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new PK(l,c,o),h=[[i]],p=t.runWebGLProgram(d,[u],"int32",h);return a||t.disposeIntermediateTensorInfo(u),p}const VK={kernelName:Bc,backendName:"webgl",kernelFunc:zK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MK=tn+`
  return -x;
`,WK=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function UK(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[i,a]=cW(o.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}let r;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new qn(s.shape,WK):r=new bn(s.shape,MK),t.runWebGLProgram(r,[s],s.dtype)}const GK={kernelName:Vc,backendName:"webgl",kernelFunc:UK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HK=eh;function jK(n){ln("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=s,l=t.readSync(r.dataId),c=t.readSync(o.dataId),{selectedIndices:d}=HK(l,c,i,a,u);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const KK={kernelName:Wc,backendName:"webgl",kernelFunc:jK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XK=Jy;function qK(n){ln("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s,c=t.readSync(r.dataId),d=t.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=XK(c,d,i,a,u,l);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const YK={kernelName:vg,backendName:"webgl",kernelFunc:qK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QK=th;function ZK(n){ln("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,c=t.readSync(r.dataId),d=t.readSync(o.dataId),h=i,p=a,f=u,g=l,{selectedIndices:y,selectedScores:x}=QK(c,d,h,p,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const JK={kernelName:Uc,backendName:"webgl",kernelFunc:ZK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eX{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tX=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:u}=s,l=H(r.shape),c=new eX(l,i,a,u),d=te({inputs:{x:r},backend:t,attrs:{shape:[l]}}),h=t.runWebGLProgram(c,[d],o);t.disposeIntermediateTensorInfo(d);const p=[...r.shape,i],f=te({inputs:{x:h},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(h),f},nX={kernelName:Hc,backendName:"webgl",kernelFunc:tX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Oo({inputs:{input:s},backend:t}),o=Mi({inputs:{x:r},backend:t}),i=fa({inputs:{input:s},backend:t}),a=Mi({inputs:{x:i},backend:t}),u=ls({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Fo({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const sX={kernelName:Ld,backendName:"webgl",kernelFunc:Mi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Oo({inputs:{input:s},backend:t}),o=xb({inputs:{x:r},backend:t}),i=fa({inputs:{input:s},backend:t}),a=Mi({inputs:{x:i},backend:t}),u=ls({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Fo({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const rX={kernelName:Gc,backendName:"webgl",kernelFunc:xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return el({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Ot(o,c.shape,"All tensors passed to stack must have matching shapes"),T(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const d=el({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(d),d}),l=sb({inputs:u,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),l}const iX={kernelName:jc,backendName:"webgl",kernelFunc:oX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aX{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);const r=e.length,o=Le(r),i=t.map(l=>l[0]).join(","),a=t.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uX{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const r=e.length,o=Le(r),i=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),u=yt("rc",r),l=yt("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,y=r===1?2:4;g<y;g++)f+=`
        ${h[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${l.join()}), ${d});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bb=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:i}=s;if(H(r.shape)===0){const l=o.map((c,d)=>c[0]+r.shape[d]+c[1]);return Fo({backend:t,attrs:{shape:l,value:i,dtype:r.dtype}})}const a=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uX(r.shape,o,i):new aX(r.shape,o,i),u=[[i]];return t.runWebGLProgram(a,[r],r.dtype,u)},lX={kernelName:Kc,backendName:"webgl",kernelFunc:bb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cX=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,dX=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+js+`
  return result;
`,hX=at({opSnippet:cX,packedOpSnippet:dX}),pX={kernelName:Xc,backendName:"webgl",kernelFunc:hX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=[],l=Ue(o,r.shape);let c=l;const d=dt(c,a);let h=r;d!=null&&(h=xt({inputs:{x:r},backend:t,attrs:{perm:d}}),c=ht(c.length,a),u.push(h)),Lt("prod",c,a);let p;if(t.shouldExecuteOnCPU([h])){const f=t.texData.get(h.dataId).values,{outVals:g,outShape:y,outDtype:x}=hW(h.shape,h.dtype,f,c);p=t.makeTensorInfo(y,x,g)}else{const[f,g]=Ut(h.shape,c),y=H(g),x=te({inputs:{x:h},backend:t,attrs:{shape:[-1,y]}}),w=Xi(r.dtype),$=Ks(x,w,"prod",t);p=te({inputs:{x:$},backend:t,attrs:{shape:f}}),u.push(x),u.push($)}if(i){u.push(p);const f=Ft(p.shape,l);p=te({inputs:{x:p},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const mX={kernelName:Yc,backendName:"webgl",kernelFunc:fX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,u=r.map(x=>t.readSync(x.dataId)),l=r.map(x=>x.shape),c=t.readSync(o.dataId),d=t.readSync(i.dataId),[h,p,f]=pW(u,l,c,o.shape,o.dtype,d,i.shape,a),g=h.map(x=>t.makeTensorInfo([x.length],"int32",x)),y=t.makeTensorInfo(f,o.dtype,p);return g.concat([y])}const yX={kernelName:Cg,backendName:"webgl",kernelFunc:gX};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xX(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(o.dataId),[l,c]=fW(i,s.shape,s.dtype,a,r.shape,u,o.shape),d=t.makeTensorInfo([l.length],"int32",l),h=t.makeTensorInfo([c.length],s.dtype,c);return[d,h]}const bX={kernelName:Sg,backendName:"webgl",kernelFunc:xX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=s,l=t.readSync(r.dataId),c=t.readSync(o.dataId),d=t.readSync(i.dataId),h=a.map(y=>t.readSync(y.dataId)),p=a.map(y=>y.shape),[f,g]=mW(l,r.shape,c,o.shape,o.dtype,d,i.shape,h,p,u);return t.makeTensorInfo(f,o.dtype,g)}const vX={kernelName:$g,backendName:"webgl",kernelFunc:wX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wb=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:i}=t,a=gW(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},CX={kernelName:Qc,backendName:"webgl",kernelFunc:wb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SX="return 1.0 / x;",$X=Te({opSnippet:SX}),IX={kernelName:Jc,backendName:"webgl",kernelFunc:$X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kX=tn+`
  return (x < 0.0) ? 0.0 : x;
`,NX=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TX=Te({opSnippet:kX,packedOpSnippet:NX}),EX={kernelName:ed,backendName:"webgl",kernelFunc:TX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=tn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_X=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,AX=Te({opSnippet:RX,packedOpSnippet:_X}),PX={kernelName:rd,backendName:"webgl",kernelFunc:AX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DX{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,s,l];const c=[r&&t>1?a-1:a,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let h;o?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OX{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,s,l];const c=[r&&t>1?a-1:a,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let h;o?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FX(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new OX(r.shape,u,l,o,i):new DX(r.shape,u,l,o,i);return t.runWebGLProgram(c,[r],"float32")}const LX={kernelName:sd,backendName:"webgl",kernelFunc:FX};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BX{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,u=[s&&i>1?r-1:r,s&&a>1?o-1:o],l=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=u[0]/l[0],d=u[1]/l[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zX(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new BX(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const VX={kernelName:kg,backendName:"webgl",kernelFunc:zX};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MX{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,s,l];const c=[r&&t>1?a-1:a,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],h=r?"0.5":"0.0";let p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WX{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,s,l];const c=[r&&t>1?a-1:a,r&&s>1?u-1:u],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],h=r?"0.5":"0.0";let p;o?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UX(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new WX(r.shape,u,l,o,i):new MX(r.shape,u,l,o,i);return t.runWebGLProgram(c,[r],r.dtype)}const GX={kernelName:nd,backendName:"webgl",kernelFunc:UX};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HX{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,i,a]=e,u=[s&&i>1?r-1:r,s&&a>1?o-1:o],l=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=u[0]/l[0],d=u[1]/l[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jX(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:i}=s,a=new HX(o.shape,r.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const KX={kernelName:Ig,backendName:"webgl",kernelFunc:jX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XX{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,u)=>r(u)).join(","),i=Le(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qX{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=yt("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Le(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${o}){
            result.g = ${l(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return h(f)}function l(f){return f[s-1]="("+f[s-1]+" + 1)",h(f)}function c(f){return f[s-2]="("+f[s-2]+" + 1)",h(f)}function d(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",h(f)}function h(f){const g=e.map((w,$)=>p($,f)),y=g.join(","),x=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${x}))`}function p(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,i=r.shape.length,a=Ue(o,r.shape);if(i===0)return Dt({inputs:{x:r},backend:t});const u=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qX(r.shape,a):new XX(r.shape,a);return t.runWebGLProgram(u,[r],r.dtype)}const QX={kernelName:od,backendName:"webgl",kernelFunc:YX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZX{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JX={kernelName:zd,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:i}=e,a=t,u=new ZX(s.shape,o),[l,c]=mh(i,s.shape[1],s.shape[2]),d=[[l,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(u,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eq=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,tq=Te({opSnippet:eq}),nq={kernelName:id,backendName:"webgl",kernelFunc:tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sq="return inversesqrt(x);",rq=Te({opSnippet:sq,cpuKernelImpl:yW}),oq={kernelName:ad,backendName:"webgl",kernelFunc:rq};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xh{constructor(e,t,s,r,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=Le(o.length),c=Le(i.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";u&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iq{constructor(e,t,s,r,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const l=Le(o.length),c=Le(i.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let g="";u&&(g="coords[0], coords[1]");const y=`getDefaultValue(${g})`,x=t>1?"strides[j]":"strides",w=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aq(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=Bs(o,r,i),h=[d/l,l];if(d===0)return t.makeTensorInfo(i,r.dtype);const p=te({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),f=te({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let y;M().getBool("WEBGL_PACK")?y=new iq(u,a,p.shape.length,f.shape.length,c,h):y=new Xh(u,a,p.shape.length,f.shape.length,c,h);const x=t.runWebGLProgram(y,[f,p,g],f.dtype),w=te({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(g),w}const uq={kernelName:ud,backendName:"webgl",kernelFunc:aq};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lq{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=M().getNumber("WEBGL_VERSION")===2?o:i,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:i}=s,a=new lq(r.shape[0],r.shape[1],o.shape[1],i),u=[[r.shape[1]]];return t.runWebGLProgram(a,[r,o],"int32",u)}const dq={kernelName:cd,backendName:"webgl",kernelFunc:cq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hq{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<t.length;c++)l.push(`${a[c]}`),c<e&&u.push(`${a[c]}`);r=u.join(),o=l.join()}const i=Le(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pq(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,i=new hq(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[s,r,o],$t(r.dtype,o.dtype))}const fq={kernelName:dd,backendName:"webgl",kernelFunc:pq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${xh};
  float scale = ${bh};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,gq=Te({opSnippet:mq}),yq={kernelName:hd,backendName:"webgl",kernelFunc:gq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=_r+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,bq=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wq=Te({opSnippet:xq,packedOpSnippet:bq,cpuKernelImpl:bW}),vq={kernelName:yd,backendName:"webgl",kernelFunc:wq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Sq=Te({opSnippet:Cq}),$q={kernelName:gd,backendName:"webgl",kernelFunc:Sq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iq=_r+`
  return sin(x);
`,kq=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${js}
  return result;
`,Nq=Te({opSnippet:Iq,packedOpSnippet:kq}),Tq={kernelName:fd,backendName:"webgl",kernelFunc:Nq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eq=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Rq=Te({opSnippet:Eq}),_q={kernelName:md,backendName:"webgl",kernelFunc:Rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Pq=Te({opSnippet:Aq}),Dq={kernelName:xd,backendName:"webgl",kernelFunc:Pq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oq=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:i}=s;T(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((x,w)=>x*w),u=[[0,0]];u.push(...i);for(let x=1+o.length;x<r.shape.length;++x)u.push([0,0]);const l=[],c=bb({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),d=To(c.shape,o,a,!1),h=Eo(d.length,o.length,!1),p=Ro(c.shape,o,a,!1),f=te({inputs:{x:c},backend:t,attrs:{shape:d}}),g=xt({inputs:{x:f},backend:t,attrs:{perm:h}}),y=te({inputs:{x:g},backend:t,attrs:{shape:p}});return l.push(c),l.push(f),l.push(g),l.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},Fq={kernelName:vd,backendName:"webgl",kernelFunc:Oq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.readSync(s.dataId),u=t.readSync(r.dataId),l=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[d,h,p,f,g]=vW(a,s.shape,s.dtype,u,r.dtype,l,c);return[t.makeTensorInfo(h,s.dtype,d),t.makeTensorInfo([h[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const Bq={kernelName:Ng,backendName:"webgl",kernelFunc:Lq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),u=Array.from(t.readSync(o.dataId)),[l,c,d]=CW(a,s.shape,s.dtype,i,u);return[t.makeTensorInfo(c,s.dtype,l),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}const Vq={kernelName:Tg,backendName:"webgl",kernelFunc:zq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mq(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(o.dataId),[l,c]=G0(i,s.shape,s.dtype,a,u,!0);return t.makeTensorInfo(c,s.dtype,l)}const Wq={kernelName:$d,backendName:"webgl",kernelFunc:Mq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uq(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=t.readSync(s.dataId),a=t.readSync(r.dataId),u=t.readSync(o.dataId),[l,c]=G0(i,s.shape,s.dtype,a,u);return t.makeTensorInfo(c,s.dtype,l)}const Gq={kernelName:Id,backendName:"webgl",kernelFunc:Uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hq(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:h}=Bs(o,r,a),p=!1;if(o.dtype==="string"){const x=t.bufferSync(r),w=t.bufferSync(o),$=Pn(t.readSync(i.dataId)[0]),S=xW(x,w,a,h,c,l,u,d,$,p);return t.makeTensorInfo(a,S.dtype,S.values)}const f=new Xh(l,u,r.shape.length,o.shape.length,d,[h,1],p),g=t.runWebGLProgram(f,[o,r,i],o.dtype),y=te({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),y}const jq={kernelName:kd,backendName:"webgl",kernelFunc:Hq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kq(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=Ue(i,r.shape)[0],u=_h(r,o,a),l=r.shape.length,c=new Array(l).fill(0),d=r.shape.slice();return u.map(h=>{const p=[...d];p[a]=h;const f=Ar({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=h,f})}const Xq={kernelName:Cd,backendName:"webgl",kernelFunc:Kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jm="return sqrt(x);",qq=Te({opSnippet:Jm,packedOpSnippet:Jm,cpuKernelImpl:SW}),Yq={kernelName:bd,backendName:"webgl",kernelFunc:qq};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qq="return x * x;",Zq=Te({opSnippet:Qq}),Jq={kernelName:Eg,backendName:"webgl",kernelFunc:Zq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eg="return (a - b) * (a - b);",e5=at({opSnippet:eg,packedOpSnippet:eg}),t5={kernelName:Nd,backendName:"webgl",kernelFunc:e5};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),i=ss(o),a=$W(i,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const s5={kernelName:Rg,backendName:"webgl",kernelFunc:n5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=tn+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new bn(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const o5={kernelName:Bd,backendName:"webgl",kernelFunc:r5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i5{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=Le(s.length),i=Le(s.length);let a="";if(r===1)a="coords * strides + begin";else{let u=0;a=s.map((l,c)=>(u++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:w,end:$,strides:S}=hh(r.shape,o,i,a,u,l,c,d,h);let E;if(g)E=te({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||x){T(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const F=uh(w,$,S),L=Ar({inputs:{x:r},backend:t,attrs:{begin:w,size:F}});E=te({inputs:{x:L},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([r])){const L=t.readSync(r.dataId),R=Pe(r.shape,r.dtype,L),A=IW(p,R,S,w);E=t.makeTensorInfo(f,r.dtype,A.values)}else{const L=new i5(w,S,p);E=t.runWebGLProgram(L,[r],r.dtype)}const P=te({inputs:{x:E},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(E),P}const u5={kernelName:Td,backendName:"webgl",kernelFunc:a5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:d}=e,h=t.readSync(c.dataId),p=t.readSync(d.dataId),[f,g]=kW(h,p,r,o,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",g)]}const c5={kernelName:Ed,backendName:"webgl",kernelFunc:l5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),u=t.readSync(i.dataId)[0],[l,c,d]=NW(a,u,r),h=c.length;return[t.makeTensorInfo([h,2],"int32",l),t.makeTensorInfo([h],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const h5={kernelName:_g,backendName:"webgl",kernelFunc:d5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=TW(i,r);return t.makeTensorInfo(o.shape,"int32",a)}const f5={kernelName:Ag,backendName:"webgl",kernelFunc:p5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m5="return tan(x);",g5=Te({opSnippet:m5}),y5={kernelName:_d,backendName:"webgl",kernelFunc:g5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x5=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,b5=Te({opSnippet:x5}),w5={kernelName:Ad,backendName:"webgl",kernelFunc:b5};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=Bs(i,o,r.shape),h=[d/l,l];if(d===0)return t.makeTensorInfo(r.shape,o.dtype);const p=te({inputs:{x:o},backend:t,attrs:{shape:[u,a]}}),f=te({inputs:{x:i},backend:t,attrs:{shape:[u,l]}}),g=te({inputs:{x:r},backend:t,attrs:{shape:h}}),y=new Xh(u,a,p.shape.length,f.shape.length,c,h,!1,!0),x=t.runWebGLProgram(y,[f,p,g],g.dtype),w=te({inputs:{x},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),w}const C5={kernelName:ld,backendName:"webgl",kernelFunc:v5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S5{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.rank=s.length;const r=Le(this.rank),o=$5(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function $5(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vb(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),l=r.dtype==="string"?u.map(h=>Pn(h)):u,c=Pe(r.shape,r.dtype,l),d=RW(c,o);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new S5(r.shape,o);return t.runWebGLProgram(i,[r],r.dtype)}const I5={kernelName:Hi,backendName:"webgl",kernelFunc:vb};class k5{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class N5{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function tg(n){let e=1;for(;e<n;)e*=2;return e}function T5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:i}=s,a=M().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=M().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,c=l[l.length-1];if(t.shouldExecuteOnCPU([r])||c<a||o>u){const A=t.readSync(r.dataId),[k,W]=_W(A,l,r.dtype,o,i);return[t.makeTensorInfo(k.shape,k.dtype,k.values),t.makeTensorInfo(W.shape,W.dtype,W.values)]}if(o===0)return l[l.length-1]=0,[t.makeTensorInfo(l,r.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(c===1)return[r,Fo({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const d=t.texData.get(r.dataId),h=d!==null&&d.isPacked,p=h?t.unpackTensor(r):r,g=H(l)/c,y=te({inputs:{x:p},attrs:{shape:[g,c]},backend:t});h&&ms(t,p);const x=tg(o),w=tg(c);let $=null;const S=()=>$===null?[y,y]:[y,$],E=(A,k,W)=>{const G=S(),K=new k5(W),ee=[[c],[$===null?1:0],[Number.NEGATIVE_INFINITY],[A],[k]],ce=$;$=t.runWebGLProgram(K,G,"int32",ee),ms(t,ce)};for(let A=1;A<x;A*=2){const k=A*2;for(let W=A;W>=1;W/=2)E(k,W,[g,w])}for(let A=w;A>x;A/=2){const k=S(),W=new N5([g,A/2]),K=[[c],[$===null?1:0],[x]],X=$;$=t.runWebGLProgram(W,k,"int32",K),ms(t,X);const ee=x/2,ce=ee*2;for(let de=ee;de>=1;de/=2)E(ce,de,$.shape)}let P=$;$=Ar({inputs:{x:$},backend:t,attrs:{begin:0,size:[g,o]}}),ms(t,P);let F=pb({inputs:{x:y,indices:$},backend:t,attrs:{axis:1,batchDims:1}});ms(t,y);const L=l.slice(0,-1);L.push(o),P=$,$=te({inputs:{x:$},attrs:{shape:L},backend:t}),ms(t,P);const R=F;return F=te({inputs:{x:F},attrs:{shape:L},backend:t}),ms(t,R),[F,$]}const E5={kernelName:Pd,backendName:"webgl",kernelFunc:T5};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R5{constructor(e,t,s,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=s,[c,d,h,p]=r.shape,[f,g]=l??[d,h],y=[c,f,g,p],x=new R5(d,h,i,a,u,y);return t.runWebGLProgram(x,[r,o],"float32")}const A5={kernelName:Dd,backendName:"webgl",kernelFunc:_5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;Po(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(o.dataId),{outputValues:a,outputShape:u,indices:l}=AW(i,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const D5={kernelName:Pg,backendName:"webgl",kernelFunc:P5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,u=r.shape[o],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(l[c++]=i.shape[g]);const d=[],h=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(u);for(let g=0;g<f.length;g++){h[o]=g;const y=Ar({inputs:{x:i},backend:t,attrs:{begin:h,size:p}}),x=te({inputs:{x:y},backend:t,attrs:{shape:l}});f[g]=x,d.push(y)}return d.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const F5={kernelName:Od,backendName:"webgl",kernelFunc:O5};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L5{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/s);this.outputShape=[r,a];const u="0.0",l="sumValue",c=Math.floor(s/4)*4,d=s%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,u=[];let l=0;const c=dt([l],a);let d=r;c!=null&&(d=xt({inputs:{x:r},backend:t,attrs:{perm:c}}),u.push(d),l=ht(1,a)[0]);const h=Ah(d.shape,l,i),p=H([d.shape[l]]),f=te({inputs:{x:d},backend:t,attrs:{shape:[-1,p]}});u.push(f);const g=Xi(r.dtype),y=(S,E,P,F,L)=>{const R=S.shape[0],A=S.shape[1],k=_x(A,L),W={windowSize:k,inSize:A,batchSize:R,numSegments:L},G=new L5(W,E),K=t.compileAndRun(G,[S,P],F);if(u.push(K),K.shape[1]===L)return K;const X=wb({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),ee=vb({inputs:{x:X},backend:t,attrs:{reps:[A/k]}});return u.push(X),u.push(ee),y(K,E,ee,F,L)},x=y(f,"unsortedSegmentSum",o,g,i),w=te({inputs:{x},backend:t,attrs:{shape:h}});let $=w;if(c!=null){u.push(w);const S=No(c);$=xt({inputs:{x:$},backend:t,attrs:{perm:S}})}return u.forEach(S=>t.disposeIntermediateTensorInfo(S)),$}const z5={kernelName:Fd,backendName:"webgl",kernelFunc:B5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V5=[SU,IU,TU,_U,PU,FU,BU,VU,GU,jU,qU,ZU,tG,oG,uG,cG,hG,gG,xG,wG,$G,_G,PG,LG,zG,HG,KG,QG,iU,eH,oH,lH,mH,xH,wH,CH,$H,TH,_H,DH,FH,BH,VH,UH,HH,qH,QH,e6,s6,o6,l6,p6,y6,w6,S6,$6,k6,T6,R6,A6,D6,B6,M6,G6,j6,q6,Z6,nj,ij,oU,uj,sH,dj,fj,yj,uU,vj,Ij,Nj,_j,Dj,Bj,Mj,Hj,qj,Zj,eK,rK,iK,uK,hK,fK,gK,xK,wK,$K,TK,AK,VK,dU,GK,KK,YK,JK,MG,nX,rX,iX,lX,pX,cU,mX,yX,bX,vX,CX,WG,FK,IX,EX,PX,pU,LX,VX,GX,KX,QX,JX,nq,oq,uq,dq,fq,yq,vq,$q,Tq,_q,EG,BK,Dq,Fq,Bq,Vq,Wq,Gq,jq,Xq,Yq,Jq,t5,s5,o5,u5,c5,h5,f5,LK,wU,y5,w5,C5,I5,E5,A5,vU,D5,F5,z5,sX];for(const n of V5)Dg(n);async function M5(){return await Tm,await Tm(Cn.MoveNet,{modelType:"Lightning",enableSmoothing:!0})}let Kr=null;function W5(n,e,t){if(e.clearRect(0,0,e.canvas.width,e.canvas.height),n.length>0&&n[0].score>.3){Kr||(Kr=performance.now());const r=performance.now()-Kr;if(U5(n[0],e),r>t)return Kr=null,!0}else Kr=null;return!1}function U5(n,e){e.fillStyle="#00FF00",n.keypoints.forEach(t=>{t.score>.3&&(e.beginPath(),e.arc(t.x,t.y,4,0,2*Math.PI),e.fill())})}function G5(n){H5(),j5(),K5(n)}function H5(){const n=document.getElementById("flash");n.style.opacity="1",setTimeout(()=>{n.style.opacity="0"},150)}function j5(){const n=document.getElementById("beep");n&&(n.currentTime=0,n.play().catch(e=>{console.warn("Beep :",e)}))}async function K5(n){try{const[e]=n.getVideoTracks();e.getCapabilities().torch&&(await e.applyConstraints({advanced:[{torch:!0}]}),setTimeout(async()=>{await e.applyConstraints({advanced:[{torch:!1}]})},150))}catch{}}const ng="lean-trainer-hits",sg="lean-trainer-successes";function X5(){const n=Number(localStorage.getItem(ng)||0)+1;localStorage.setItem(ng,n.toString())}function q5(){const n=Number(localStorage.getItem(sg)||0)+1;localStorage.setItem(sg,n.toString())}const Jr=document.getElementById("cam"),tl=document.getElementById("overlay"),Y5=tl.getContext("2d"),nl=document.getElementById("status"),Q5=document.getElementById("threshold");let Cb,sl;async function Z5(){try{sl=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}}),Jr.srcObject=sl,await Jr.play(),Cb=await M5(),tl.width=Jr.videoWidth,tl.height=Jr.videoHeight,Sb()}catch(n){console.error(":",n),nl.textContent="CAMERA ERROR"}"serviceWorker"in navigator&&navigator.serviceWorker.register("/src/sw.js")}function Sb(){Cb.estimatePoses(Jr).then(n=>{W5(n,Y5,Number(Q5.value))?(G5(sl),X5(),nl.textContent="HIT!",setTimeout(()=>{nl.textContent="READY"},500)):n.length&&n[0].score>.3&&q5(),requestAnimationFrame(Sb)})}Z5();
